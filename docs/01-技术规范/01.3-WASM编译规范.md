# WASM 编译规范（WebAssembly Compilation Specification）

> **更新日期**: 2025年10月20日  
> **WASM版本**: WASI Preview 1  
> **OPA版本**: v0.60+  
> **参考**: <https://www.openpolicyagent.org/docs/latest/wasm/>

---

## 目录

- [WASM 编译规范（WebAssembly Compilation Specification）](#wasm-编译规范webassembly-compilation-specification)
  - [目录](#目录)
  - [1. WASM编译概述](#1-wasm编译概述)
    - [1.1 为什么需要WASM](#11-为什么需要wasm)
    - [1.2 WASM vs Native Rego](#12-wasm-vs-native-rego)
    - [1.3 WASM运行时架构](#13-wasm运行时架构)
  - [2. 编译流程](#2-编译流程)
    - [2.1 编译管道](#21-编译管道)
    - [2.2 编译命令](#22-编译命令)
    - [2.3 编译选项](#23-编译选项)
    - [2.4 Entrypoint指定](#24-entrypoint指定)
  - [3. WASM模块结构](#3-wasm模块结构)
    - [3.1 导出函数](#31-导出函数)
    - [3.2 内存布局](#32-内存布局)
    - [3.3 数据嵌入](#33-数据嵌入)
  - [4. ABI接口规范](#4-abi接口规范)
    - [4.1 主求值函数](#41-主求值函数)
    - [4.2 内存管理函数](#42-内存管理函数)
    - [4.3 内置函数](#43-内置函数)
    - [4.4 数据访问](#44-数据访问)
  - [5. JavaScript SDK](#5-javascript-sdk)
    - [5.1 加载WASM模块](#51-加载wasm模块)
    - [5.2 执行查询](#52-执行查询)
    - [5.3 数据更新](#53-数据更新)
    - [5.4 完整示例](#54-完整示例)
  - [6. Go SDK](#6-go-sdk)
    - [6.1 使用wazero运行时](#61-使用wazero运行时)
    - [6.2 嵌入WASM策略](#62-嵌入wasm策略)
  - [7. 其他语言SDK](#7-其他语言sdk)
    - [7.1 Python (wasmtime-py)](#71-python-wasmtime-py)
    - [7.2 Rust (wasmtime)](#72-rust-wasmtime)
    - [7.3 .NET (Wasmtime.Dotnet)](#73-net-wasmtimedotnet)
  - [8. 性能优化](#8-性能优化)
    - [8.1 编译优化级别](#81-编译优化级别)
    - [8.2 策略优化](#82-策略优化)
    - [8.3 缓存策略](#83-缓存策略)
    - [8.4 性能基准](#84-性能基准)
  - [9. 限制与权衡](#9-限制与权衡)
    - [9.1 功能限制](#91-功能限制)
    - [9.2 性能权衡](#92-性能权衡)
    - [9.3 调试难度](#93-调试难度)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 何时使用WASM](#101-何时使用wasm)
    - [10.2 Entrypoint设计](#102-entrypoint设计)
    - [10.3 数据管理](#103-数据管理)
  - [附录A：WASM模块完整示例](#附录awasm模块完整示例)
  - [附录B：性能调优检查清单](#附录b性能调优检查清单)

---

## 1. WASM编译概述

### 1.1 为什么需要WASM

**业务场景**：

```text
场景1: 浏览器端策略执行
  ├── 前端应用需要本地授权决策
  ├── 减少网络延迟
  └── 提升用户体验

场景2: 边缘计算/Serverless
  ├── Cloudflare Workers
  ├── Fastly Compute@Edge
  └── AWS Lambda@Edge

场景3: 多语言集成
  ├── Python应用集成策略引擎
  ├── Rust服务嵌入授权逻辑
  └── .NET应用策略管理

场景4: 沙箱隔离
  ├── 策略在隔离环境执行
  ├── 防止恶意策略攻击
  └── 资源使用限制
```

**核心优势**：

- 🚀 **高性能**: 接近原生代码速度（~80%）
- 🌐 **跨平台**: 一次编译，处处运行
- 🔒 **安全隔离**: 沙箱环境，内存安全
- 📦 **体积小**: 压缩后通常 < 1MB
- 🔌 **易集成**: 支持主流语言运行时

### 1.2 WASM vs Native Rego

**特性对比**：

| 特性 | Native Rego | WASM |
|------|-------------|------|
| **执行速度** | ⭐⭐⭐⭐⭐ (基准) | ⭐⭐⭐⭐ (80-90%) |
| **启动速度** | ⭐⭐⭐ (需要解析) | ⭐⭐⭐⭐⭐ (预编译) |
| **内存占用** | ⭐⭐⭐ (Go运行时) | ⭐⭐⭐⭐⭐ (轻量级) |
| **跨语言** | ❌ (仅Go) | ✅ (所有语言) |
| **调试** | ⭐⭐⭐⭐⭐ (完整工具) | ⭐⭐ (有限) |
| **动态更新** | ✅ (热加载) | ⚠️ (需重新加载) |
| **内置函数** | ✅ (全部支持) | ⚠️ (部分支持) |

**选择指南**：

```text
选择Native Rego:
  ✅ Go应用
  ✅ 需要完整内置函数
  ✅ 需要动态策略更新
  ✅ 开发调试阶段

选择WASM:
  ✅ 非Go语言应用
  ✅ 浏览器/边缘计算
  ✅ 需要沙箱隔离
  ✅ 生产环境部署
```

### 1.3 WASM运行时架构

```text
┌─────────────────────────────────────────┐
│         Host Application                │
│  (Go / JS / Python / Rust / .NET)       │
├─────────────────────────────────────────┤
│         WASM SDK / Runtime              │
│  ┌───────────────────────────────────┐  │
│  │   opa.wasm (Compiled Policy)      │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │  Exported Functions:        │  │  │
│  │  │  - opa_eval()              │  │  │
│  │  │  - opa_malloc()            │  │  │
│  │  │  - opa_heap_ptr_get()      │  │  │
│  │  └─────────────────────────────┘  │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │  Linear Memory (64KB-16MB)  │  │  │
│  │  │  ├── Stack                  │  │  │
│  │  │  ├── Heap (JSON data)       │  │  │
│  │  │  └── Embedded Data           │  │  │
│  │  └─────────────────────────────┘  │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

---

## 2. 编译流程

### 2.1 编译管道

```text
Rego策略 (.rego)
    ↓
┌───────────────────────────────┐
│ 1. 词法分析 & 语法解析          │
│    Lexer → Parser → AST        │
└───────────────────────────────┘
    ↓
┌───────────────────────────────┐
│ 2. 类型检查 & 语义分析          │
│    Type Checker → Annotated AST│
└───────────────────────────────┘
    ↓
┌───────────────────────────────┐
│ 3. 编译为中间表示 (IR)          │
│    Planner → IR                │
└───────────────────────────────┘
    ↓
┌───────────────────────────────┐
│ 4. IR优化                      │
│    - 常量折叠                   │
│    - 死代码消除                 │
│    - 内联展开                   │
└───────────────────────────────┘
    ↓
┌───────────────────────────────┐
│ 5. WASM代码生成                │
│    IR → WASM Instructions      │
└───────────────────────────────┘
    ↓
┌───────────────────────────────┐
│ 6. 数据嵌入（可选）             │
│    Embed JSON data in WASM     │
└───────────────────────────────┘
    ↓
policy.wasm
```

### 2.2 编译命令

**基本编译**：

```bash
# 编译单个Entrypoint
opa build -t wasm -e data.authz.allow policy.rego

# 输出到指定文件
opa build -t wasm -e data.authz.allow -o bundle.tar.gz policy.rego

# 提取WASM文件
tar -xzf bundle.tar.gz policy.wasm
```

**多Entrypoint编译**：

```bash
# 编译多个决策点
opa build -t wasm \
  -e data.authz.allow \
  -e data.authz.deny \
  -e data.validation.errors \
  policy/

# 结果：一个WASM模块包含所有Entrypoints
```

**包含数据**：

```bash
# 嵌入静态数据到WASM
opa build -t wasm -e data.authz.allow \
  policy/ \
  data.json

# 数据会编译到WASM模块中
```

### 2.3 编译选项

**优化级别**：

```bash
# 默认优化（级别1）
opa build -t wasm -e data.authz.allow policy.rego

# 最大优化（级别2）
opa build -t wasm -e data.authz.allow \
  --optimize=2 \
  policy.rego

# 禁用优化（调试用）
opa build -t wasm -e data.authz.allow \
  --optimize=0 \
  policy.rego
```

**优化级别说明**：

| 级别 | 说明 | 编译时间 | 执行性能 | WASM大小 |
|------|------|---------|---------|---------|
| 0 | 无优化 | 快 | 慢 | 大 |
| 1 | 标准优化 | 中等 | 好 | 中等 |
| 2 | 激进优化 | 慢 | 最佳 | 小 |

**调试符号**：

```bash
# 保留调试信息（用于错误追踪）
opa build -t wasm -e data.authz.allow \
  --debug \
  policy.rego
```

### 2.4 Entrypoint指定

**Entrypoint语法**：

```text
-e <package>.<rule>

示例:
  -e data.authz.allow           # 简单规则
  -e data.api.v1.permissions    # 嵌套包
  -e data["my-pkg"].result      # 包含特殊字符
```

**Entrypoint查询**：

```javascript
// JavaScript中调用不同Entrypoint
const result1 = await policy.evaluate(input, 'data.authz.allow');
const result2 = await policy.evaluate(input, 'data.authz.deny');
```

**默认Entrypoint**：

```bash
# 如果不指定-e，需要在查询时提供完整路径
opa build -t wasm policy.rego

# 查询时必须明确指定路径
policy.evaluate(input, 'data.authz.allow')
```

---

## 3. WASM模块结构

### 3.1 导出函数

**核心导出**：

```wasm
;; 主求值函数
(export "eval" (func $opa_eval))
  params: i32  ;; context pointer
  result: i32  ;; result pointer

;; 内存分配
(export "malloc" (func $opa_malloc))
  params: i32  ;; size
  result: i32  ;; pointer

;; 获取堆指针
(export "heap_ptr_get" (func $opa_heap_ptr_get))
  result: i32  ;; heap base pointer

;; 堆指针设置
(export "heap_ptr_set" (func $opa_heap_ptr_set))
  params: i32  ;; new heap pointer

;; 入口点调用
(export "entrypoints" (func $opa_entrypoints))
  result: i32  ;; JSON array of entrypoints

;; 策略元数据
(export "builtins" (func $opa_builtins))
  result: i32  ;; JSON object of required builtins
```

### 3.2 内存布局

```text
WASM Linear Memory (默认 2MB, 最大 16MB)

0x00000000  ┌──────────────────────────┐
            │   Stack (64KB)            │
            │   ↓ grows down            │
0x00010000  ├──────────────────────────┤
            │   Heap (JSON data)        │
            │   ↑ grows up              │
            │                           │
            │   - Input data            │
            │   - Evaluation results    │
            │   - Temporary objects     │
            │                           │
0x001F0000  ├──────────────────────────┤
            │   Embedded Data (optional)│
            │   - Static base documents │
            │   - Role definitions      │
0x00200000  └──────────────────────────┘
```

**内存管理**：

```javascript
// JavaScript内存操作示例
class WasmMemory {
  constructor(wasmInstance) {
    this.memory = wasmInstance.exports.memory;
    this.malloc = wasmInstance.exports.malloc;
  }

  // 分配内存并写入JSON
  allocateJSON(obj) {
    const json = JSON.stringify(obj);
    const bytes = new TextEncoder().encode(json);
    const ptr = this.malloc(bytes.length);
    const buffer = new Uint8Array(this.memory.buffer);
    buffer.set(bytes, ptr);
    return ptr;
  }

  // 从指针读取JSON
  readJSON(ptr) {
    const buffer = new Uint8Array(this.memory.buffer);
    const nullIdx = buffer.indexOf(0, ptr);
    const slice = buffer.slice(ptr, nullIdx);
    const json = new TextDecoder().decode(slice);
    return JSON.parse(json);
  }
}
```

### 3.3 数据嵌入

**编译时嵌入**：

```bash
# data.json
{
  "roles": {
    "admin": ["read", "write", "delete"],
    "user": ["read"]
  }
}

# 编译时嵌入
opa build -t wasm -e data.authz.allow \
  policy.rego data.json

# WASM中可以直接访问 data.roles
```

**策略访问嵌入数据**：

```rego
package authz

import rego.v1

# 直接引用嵌入的数据
user_permissions := data.roles[input.user.role]

allow if {
    input.action in user_permissions
}
```

---

## 4. ABI接口规范

### 4.1 主求值函数

**函数签名**：

```c
int32_t opa_eval(int32_t ctx_addr);
```

**参数格式（ctx_addr指向的JSON）**：

```json
{
  "input": {
    "user": "alice",
    "action": "read",
    "resource": "/api/data"
  },
  "entrypoint": 0
}
```

**返回值（指向JSON的指针）**：

```json
[
  {
    "result": true,
    "expressions": [
      {
        "value": true,
        "text": "data.authz.allow",
        "location": {
          "row": 5,
          "col": 1
        }
      }
    ]
  }
]
```

### 4.2 内存管理函数

**malloc**：

```c
int32_t opa_malloc(int32_t size);

// 用法
int32_t ptr = opa_malloc(1024);  // 分配1KB
```

**heap_ptr_get/set**：

```c
int32_t opa_heap_ptr_get();
void opa_heap_ptr_set(int32_t ptr);

// 重置堆（清理临时数据）
int32_t heap_top = opa_heap_ptr_get();
// ... 执行操作 ...
opa_heap_ptr_set(heap_top);  // 恢复堆状态
```

### 4.3 内置函数

**entrypoints**：

```c
int32_t opa_entrypoints();

// 返回 (JSON字符串指针):
[
  {
    "id": 0,
    "path": "data/authz/allow"
  },
  {
    "id": 1,
    "path": "data/authz/deny"
  }
]
```

**builtins**：

```c
int32_t opa_builtins();

// 返回 (JSON对象指针):
{
  "http.send": {
    "decl": {
      "args": [...],
      "result": {...}
    }
  }
}
```

### 4.4 数据访问

**Base Documents**：

编译时嵌入的数据可通过标准Rego引用访问：

```rego
# 访问嵌入的 data.json
user_roles := data.roles[input.user]

# 访问嵌入的 config.yaml
max_retries := data.config.retry.max_attempts
```

---

## 5. JavaScript SDK

### 5.1 加载WASM模块

**使用@open-policy-agent/opa-wasm**：

```bash
npm install @open-policy-agent/opa-wasm
```

```javascript
const { loadPolicy } = require('@open-policy-agent/opa-wasm');
const fs = require('fs');

// 加载WASM文件
const wasm = fs.readFileSync('policy.wasm');
const policy = await loadPolicy(wasm);
```

**浏览器中加载**：

```html
<script type="module">
import { loadPolicy } from 'https://cdn.skypack.dev/@open-policy-agent/opa-wasm';

fetch('/policy.wasm')
  .then(response => response.arrayBuffer())
  .then(buffer => loadPolicy(buffer))
  .then(policy => {
    console.log('Policy loaded');
    window.policy = policy;
  });
</script>
```

### 5.2 执行查询

**基本查询**：

```javascript
const input = {
  user: 'alice',
  action: 'read',
  resource: '/api/data'
};

// 求值
const result = await policy.evaluate(input);

console.log(result);
// 输出: [{ result: true }]
```

**指定Entrypoint**：

```javascript
// 查询特定规则
const allowed = await policy.evaluate(input, 'data/authz/allow');
const denied = await policy.evaluate(input, 'data/authz/deny');
```

**设置外部数据**：

```javascript
// 更新外部数据
policy.setData({
  users: {
    alice: { role: 'admin' },
    bob: { role: 'user' }
  }
});

const result = await policy.evaluate({ user: 'alice', action: 'write' });
```

### 5.3 数据更新

**完整替换**：

```javascript
policy.setData({
  roles: {
    admin: ['read', 'write', 'delete'],
    user: ['read']
  }
});
```

**部分更新（路径）**：

```javascript
policy.setDataPath(['roles', 'admin'], ['read', 'write', 'delete', 'admin']);
```

**删除数据**：

```javascript
policy.removeDataPath(['roles', 'guest']);
```

### 5.4 完整示例

```javascript
const { loadPolicy } = require('@open-policy-agent/opa-wasm');
const fs = require('fs');

async function main() {
  // 1. 加载策略
  const wasm = fs.readFileSync('authz.wasm');
  const policy = await loadPolicy(wasm);

  // 2. 设置基础数据
  policy.setData({
    users: {
      alice: { role: 'admin', department: 'engineering' },
      bob: { role: 'user', department: 'sales' }
    },
    roles: {
      admin: { permissions: ['read', 'write', 'delete'] },
      user: { permissions: ['read'] }
    }
  });

  // 3. 执行授权查询
  const requests = [
    { user: 'alice', action: 'write', resource: '/api/data' },
    { user: 'bob', action: 'write', resource: '/api/data' },
    { user: 'alice', action: 'delete', resource: '/api/data' }
  ];

  for (const req of requests) {
    const result = await policy.evaluate(req);
    console.log(`${req.user} ${req.action} ${req.resource}: ${result[0].result}`);
  }

  // 4. 清理
  policy.close();
}

main().catch(console.error);
```

---

## 6. Go SDK

### 6.1 使用wazero运行时

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "os"

    "github.com/tetratelabs/wazero"
    "github.com/tetratelabs/wazero/api"
)

func main() {
    ctx := context.Background()

    // 1. 创建WASM运行时
    runtime := wazero.NewRuntime(ctx)
    defer runtime.Close(ctx)

    // 2. 加载WASM模块
    wasmBytes, _ := os.ReadFile("policy.wasm")
    mod, _ := runtime.Instantiate(ctx, wasmBytes)
    defer mod.Close(ctx)

    // 3. 准备输入
    input := map[string]interface{}{
        "user":     "alice",
        "action":   "read",
        "resource": "/api/data",
    }
    inputJSON, _ := json.Marshal(input)

    // 4. 分配内存并写入
    malloc := mod.ExportedFunction("malloc")
    results, _ := malloc.Call(ctx, uint64(len(inputJSON)))
    ptr := api.DecodeU32(results[0])

    memory := mod.Memory()
    memory.Write(ptr, inputJSON)

    // 5. 执行求值
    eval := mod.ExportedFunction("eval")
    results, _ = eval.Call(ctx, uint64(ptr))
    resultPtr := api.DecodeU32(results[0])

    // 6. 读取结果
    resultBytes, _ := memory.Read(resultPtr, 4096)
    nullIdx := bytes.IndexByte(resultBytes, 0)
    var result []map[string]interface{}
    json.Unmarshal(resultBytes[:nullIdx], &result)

    fmt.Printf("Result: %+v\n", result)
}
```

### 6.2 嵌入WASM策略

```go
package authz

import (
    _ "embed"
    "github.com/tetratelabs/wazero"
)

//go:embed policy.wasm
var policyWASM []byte

type Authorizer struct {
    runtime wazero.Runtime
    module  api.Module
}

func NewAuthorizer(ctx context.Context) (*Authorizer, error) {
    runtime := wazero.NewRuntime(ctx)
    module, err := runtime.Instantiate(ctx, policyWASM)
    if err != nil {
        return nil, err
    }

    return &Authorizer{
        runtime: runtime,
        module:  module,
    }, nil
}

func (a *Authorizer) Evaluate(ctx context.Context, input map[string]interface{}) (bool, error) {
    // 实现求值逻辑
    // ...
}

func (a *Authorizer) Close(ctx context.Context) error {
    a.module.Close(ctx)
    return a.runtime.Close(ctx)
}
```

---

## 7. 其他语言SDK

### 7.1 Python (wasmtime-py)

```python
from wasmtime import Store, Module, Instance
import json

# 加载WASM
store = Store()
module = Module.from_file(store.engine, 'policy.wasm')
instance = Instance(store, module, [])

# 准备输入
input_data = {
    'user': 'alice',
    'action': 'read',
    'resource': '/api/data'
}
input_json = json.dumps(input_data).encode('utf-8')

# 分配内存
malloc = instance.exports(store)['malloc']
ptr = malloc(store, len(input_json))

# 写入数据
memory = instance.exports(store)['memory']
memory.write(store, input_json, ptr)

# 执行求值
eval_func = instance.exports(store)['eval']
result_ptr = eval_func(store, ptr)

# 读取结果
result_bytes = memory.read(store, result_ptr, 4096)
result_json = result_bytes.split(b'\0')[0].decode('utf-8')
result = json.loads(result_json)

print(f"Result: {result}")
```

### 7.2 Rust (wasmtime)

```rust
use wasmtime::*;
use serde_json::json;

fn main() -> Result<()> {
    // 创建引擎和存储
    let engine = Engine::default();
    let mut store = Store::new(&engine, ());

    // 加载模块
    let module = Module::from_file(&engine, "policy.wasm")?;
    let instance = Instance::new(&mut store, &module, &[])?;

    // 获取导出函数
    let malloc = instance.get_typed_func::<i32, i32>(&mut store, "malloc")?;
    let eval = instance.get_typed_func::<i32, i32>(&mut store, "eval")?;
    let memory = instance.get_memory(&mut store, "memory").unwrap();

    // 准备输入
    let input = json!({
        "user": "alice",
        "action": "read",
        "resource": "/api/data"
    });
    let input_json = serde_json::to_string(&input)?;
    let input_bytes = input_json.as_bytes();

    // 分配并写入
    let ptr = malloc.call(&mut store, input_bytes.len() as i32)?;
    memory.write(&mut store, ptr as usize, input_bytes)?;

    // 执行求值
    let result_ptr = eval.call(&mut store, ptr)?;

    // 读取结果
    let mut result_bytes = vec![0u8; 4096];
    memory.read(&store, result_ptr as usize, &mut result_bytes)?;
    let null_idx = result_bytes.iter().position(|&b| b == 0).unwrap();
    let result_json = String::from_utf8(result_bytes[..null_idx].to_vec())?;
    let result: serde_json::Value = serde_json::from_str(&result_json)?;

    println!("Result: {}", result);
    Ok(())
}
```

### 7.3 .NET (Wasmtime.Dotnet)

```csharp
using System;
using System.Text;
using System.Text.Json;
using Wasmtime;

class Program
{
    static void Main()
    {
        // 创建引擎和模块
        using var engine = new Engine();
        using var module = Module.FromFile(engine, "policy.wasm");
        using var linker = new Linker(engine);
        using var store = new Store(engine);

        // 实例化
        var instance = linker.Instantiate(store, module);

        // 获取函数
        var malloc = instance.GetFunction<int, int>("malloc");
        var eval = instance.GetFunction<int, int>("eval");
        var memory = instance.GetMemory("memory");

        // 准备输入
        var input = new {
            user = "alice",
            action = "read",
            resource = "/api/data"
        };
        var inputJson = JsonSerializer.Serialize(input);
        var inputBytes = Encoding.UTF8.GetBytes(inputJson);

        // 分配并写入
        var ptr = malloc(inputBytes.Length);
        memory.WriteString(ptr, inputJson);

        // 执行求值
        var resultPtr = eval(ptr);

        // 读取结果
        var resultJson = memory.ReadString(resultPtr, 0, 4096);
        var result = JsonSerializer.Deserialize<object>(resultJson);

        Console.WriteLine($"Result: {result}");
    }
}
```

---

## 8. 性能优化

### 8.1 编译优化级别

```bash
# 级别0: 无优化（调试）
opa build -t wasm -e data.authz.allow --optimize=0 policy.rego
# 编译时间: 5s, WASM大小: 2.5MB, 执行速度: 100ms

# 级别1: 标准优化（默认）
opa build -t wasm -e data.authz.allow --optimize=1 policy.rego
# 编译时间: 10s, WASM大小: 1.2MB, 执行速度: 15ms

# 级别2: 激进优化（生产）
opa build -t wasm -e data.authz.allow --optimize=2 policy.rego
# 编译时间: 30s, WASM大小: 800KB, 执行速度: 10ms
```

### 8.2 策略优化

**避免昂贵操作**：

```rego
# ❌ 慢: 多次数组遍历
allow if {
    some role in input.user.roles
    role in data.admin_roles
}

# ✅ 快: 使用集合交集
allow if {
    count(input.user.roles & data.admin_roles) > 0
}
```

**缓存中间结果**：

```rego
# ❌ 慢: 重复计算
allow if {
    expensive_check(input.resource)
    expensive_check(input.resource).level > 5
}

# ✅ 快: 缓存结果
check_result := expensive_check(input.resource)

allow if {
    check_result.level > 5
}
```

### 8.3 缓存策略

**WASM模块缓存**：

```javascript
// 浏览器: 使用IndexedDB缓存编译后的模块
const cachedModule = await WebAssembly.compileStreaming(
  fetch('/policy.wasm')
);

// 存储到IndexedDB
await idb.put('wasm-cache', 'policy', cachedModule);

// 后续加载
const module = await idb.get('wasm-cache', 'policy');
const instance = await WebAssembly.instantiate(module);
```

**求值结果缓存**：

```javascript
class CachedPolicy {
  constructor(policy) {
    this.policy = policy;
    this.cache = new Map();
  }

  async evaluate(input) {
    const key = JSON.stringify(input);
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }

    const result = await this.policy.evaluate(input);
    this.cache.set(key, result);
    return result;
  }
}
```

### 8.4 性能基准

**测试场景**：简单RBAC策略

| 运行时 | 冷启动 | 热执行 | 内存占用 |
|--------|-------|-------|---------|
| **Native OPA** | 50ms | 0.1ms | 50MB |
| **WASM (Node.js)** | 10ms | 0.15ms | 10MB |
| **WASM (Browser)** | 15ms | 0.2ms | 8MB |
| **WASM (Go/wazero)** | 5ms | 0.12ms | 15MB |

**吞吐量对比**：

```text
Native OPA:    10,000 req/s
WASM (Node):    8,000 req/s  (80%)
WASM (Browser): 6,000 req/s  (60%)
WASM (Go):      9,000 req/s  (90%)
```

---

## 9. 限制与权衡

### 9.1 功能限制

**不支持的内置函数**：

```text
❌ http.send           # 网络请求
❌ opa.runtime         # 运行时信息
❌ trace               # 调试追踪
❌ time.now_ns         # 高精度时间（部分运行时）

✅ 大部分内置函数都支持:
   - 字符串操作
   - 数组/对象操作
   - 加密函数
   - 正则表达式
   - JSON操作
```

**解决方案**：

```javascript
// 在宿主环境实现缺失的内置函数
policy.setBuiltins({
  'http.send': async (req) => {
    const response = await fetch(req.url, req);
    return await response.json();
  },
  'time.now_ns': () => Date.now() * 1000000
});
```

### 9.2 性能权衡

**首次编译开销**：

```text
Scenario: 第一次加载WASM模块

Native OPA:
  解析Rego: 50ms
  编译: 100ms
  总计: 150ms

WASM:
  下载WASM: 100ms (网络依赖)
  编译WASM: 50ms
  总计: 150ms

✅ 相似的冷启动时间
✅ 但WASM可以缓存编译结果
```

**内存overhead**：

```text
WASM额外开销:
  - WASM Runtime: ~2MB
  - Linear Memory: 2-16MB
  - 宿主绑定: ~1MB

对比Native:
  - Go Runtime: ~20MB
  - GC overhead: ~10MB

✅ WASM总体更轻量
```

### 9.3 调试难度

**限制**：

```text
❌ 无法使用 print() / trace()
❌ 难以单步调试
❌ 错误堆栈信息有限
```

**调试策略**：

```bash
# 1. 使用Native OPA开发和测试
opa eval -d policy.rego 'data.authz.allow' --input input.json

# 2. 编译为WASM前充分测试
opa test policy/ -v

# 3. 编译时保留调试信息
opa build -t wasm -e data.authz.allow --debug policy.rego

# 4. 使用WASM调试工具
wasmtime run --invoke eval policy.wasm
```

---

## 10. 最佳实践

### 10.1 何时使用WASM

**适合使用WASM**：

```text
✅ 非Go语言应用集成
✅ 浏览器/边缘计算场景
✅ 需要策略沙箱隔离
✅ 生产环境大规模部署
✅ 策略变更频率低（天/周级别）
✅ 不依赖http.send等特殊内置函数
```

**不适合使用WASM**：

```text
❌ Go语言应用（直接用Native）
❌ 需要频繁热更新策略
❌ 严重依赖不支持的内置函数
❌ 需要详细的调试和追踪
❌ 开发阶段（迭代速度慢）
```

### 10.2 Entrypoint设计

**最佳实践**：

```rego
# ✅ 好的设计: 明确的入口点
package authz.api

import rego.v1

# 主决策点
default allow := false

allow if {
    is_admin
}

allow if {
    is_resource_owner
}

# 辅助规则
is_admin if {
    input.user.role == "admin"
}

is_resource_owner if {
    input.user.id == data.resources[input.resource_id].owner
}
```

**编译**：

```bash
# 只导出主决策点
opa build -t wasm -e data.authz.api.allow policy/
```

### 10.3 数据管理

**策略**：

```text
嵌入式数据（编译时）:
  ✅ 静态配置（角色定义、权限矩阵）
  ✅ 不常变化的引用数据
  ✅ 小型数据集（<100KB）

外部数据（运行时）:
  ✅ 用户信息、资源属性
  ✅ 频繁变化的数据
  ✅ 大型数据集（>1MB）
  ✅ 多租户数据
```

**示例**：

```bash
# 嵌入静态角色定义
opa build -t wasm -e data.authz.allow \
  policy/ \
  static/roles.json

# 运行时设置动态用户数据
policy.setDataPath(['users'], dynamicUserData);
```

---

## 附录A：WASM模块完整示例

**policy.rego**：

```rego
package authz

import rego.v1

default allow := false

# Admin全局访问
allow if {
    input.user.role == "admin"
}

# 资源所有者访问
allow if {
    input.user.id == data.resources[input.resource].owner
    input.action in ["read", "write"]
}

# 团队成员只读访问
allow if {
    input.user.team == data.resources[input.resource].team
    input.action == "read"
}
```

**编译**：

```bash
opa build -t wasm -e data.authz.allow \
  --optimize=2 \
  -o authz-bundle.tar.gz \
  policy.rego

tar -xzf authz-bundle.tar.gz policy.wasm
```

**JavaScript使用**：

```javascript
const { loadPolicy } = require('@open-policy-agent/opa-wasm');
const fs = require('fs');

async function main() {
  const wasm = fs.readFileSync('policy.wasm');
  const policy = await loadPolicy(wasm);

  // 设置资源数据
  policy.setData({
    resources: {
      'doc-123': {
        owner: 'alice',
        team: 'engineering'
      }
    }
  });

  // 测试用例
  const tests = [
    { user: { id: 'alice', role: 'user' }, resource: 'doc-123', action: 'write' },
    { user: { id: 'bob', role: 'admin' }, resource: 'doc-123', action: 'delete' },
    { user: { id: 'charlie', team: 'engineering' }, resource: 'doc-123', action: 'read' }
  ];

  for (const input of tests) {
    const result = await policy.evaluate(input);
    console.log(`${input.user.id} ${input.action}: ${result[0].result}`);
  }
}

main().catch(console.error);
```

---

## 附录B：性能调优检查清单

**编译阶段**：

- [ ] 使用 `--optimize=2` 进行生产构建
- [ ] 移除不必要的策略和规则
- [ ] 合并多个小策略文件
- [ ] 嵌入静态数据而非运行时加载
- [ ] 最小化Entrypoint数量

**运行时**：

- [ ] 缓存WASM模块编译结果
- [ ] 复用WASM实例处理多个请求
- [ ] 实现求值结果缓存
- [ ] 批量设置数据而非逐条更新
- [ ] 使用对象池管理内存

**策略优化**：

- [ ] 避免深度嵌套的迭代
- [ ] 使用索引加速数据查找
- [ ] 提取公共子表达式
- [ ] 使用早期退出优化
- [ ] 减少不必要的类型转换

**监控**：

- [ ] 跟踪求值延迟（P50/P99）
- [ ] 监控WASM内存使用
- [ ] 记录缓存命中率
- [ ] 检测内存泄漏
- [ ] 定期性能基准测试

---

**相关文档**：

- [Bundle格式规范](./01.2-Bundle格式规范.md)
- [性能基准与度量](./01.4-性能基准与度量.md)
- [Kubernetes集成](../04-生态系统/04.1-Kubernetes集成.md)

**参考资源**：

- WASM Compilation: <https://www.openpolicyagent.org/docs/latest/wasm/>
- JavaScript SDK: <https://github.com/open-policy-agent/npm-opa-wasm>
- WASI Specification: <https://wasi.dev/>
