# 安全合规标准（Security and Compliance Standards）

> **更新日期**: 2025年10月21日  
> **安全等级**: 企业级  
> **合规框架**: SOC 2, ISO 27001, NIST  
> **参考**: <https://www.openpolicyagent.org/docs/latest/security/>

---

## 目录

- [安全合规标准（Security and Compliance Standards）](#安全合规标准security-and-compliance-standards)
  - [目录](#目录)
  - [1. 安全概述](#1-安全概述)
    - [1.1 安全架构原则](#11-安全架构原则)
    - [1.2 威胁模型](#12-威胁模型)
    - [1.3 安全边界](#13-安全边界)
  - [2. 策略安全](#2-策略安全)
    - [2.1 策略隔离](#21-策略隔离)
    - [2.2 策略验证](#22-策略验证)
    - [2.3 策略审计](#23-策略审计)
  - [3. 数据安全](#3-数据安全)
    - [3.1 敏感数据保护](#31-敏感数据保护)
    - [3.2 数据加密](#32-数据加密)
    - [3.3 数据访问控制](#33-数据访问控制)
  - [4. 通信安全](#4-通信安全)
    - [4.1 TLS配置](#41-tls配置)
    - [4.2 证书管理](#42-证书管理)
    - [4.3 mTLS双向认证](#43-mtls双向认证)
  - [5. 认证与授权](#5-认证与授权)
    - [5.1 API认证机制](#51-api认证机制)
    - [5.2 Token管理](#52-token管理)
    - [5.3 RBAC授权](#53-rbac授权)
  - [6. Bundle签名与验证](#6-bundle签名与验证)
    - [6.1 签名工作流](#61-签名工作流)
    - [6.2 密钥管理](#62-密钥管理)
    - [6.3 验证策略](#63-验证策略)
  - [7. 审计与日志](#7-审计与日志)
    - [7.1 决策日志](#71-决策日志)
    - [7.2 审计追踪](#72-审计追踪)
    - [7.3 日志保护](#73-日志保护)
  - [8. 漏洞管理](#8-漏洞管理)
    - [8.1 漏洞扫描](#81-漏洞扫描)
    - [8.2 依赖管理](#82-依赖管理)
    - [8.3 安全更新](#83-安全更新)
  - [9. 合规标准](#9-合规标准)
    - [9.1 SOC 2合规](#91-soc-2合规)
    - [9.2 ISO 27001合规](#92-iso-27001合规)
    - [9.3 GDPR/CCPA](#93-gdprccpa)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 安全配置清单](#101-安全配置清单)
    - [10.2 安全加固指南](#102-安全加固指南)
    - [10.3 事件响应](#103-事件响应)
  - [附录A：安全配置模板](#附录a安全配置模板)
  - [附录B：常见安全问题Q\&A](#附录b常见安全问题qa)

---

## 1. 安全概述

### 1.1 安全架构原则

**核心安全原则**：

```text
纵深防御（Defense in Depth）
├── 网络层: TLS/mTLS加密
├── 应用层: 认证授权
├── 数据层: 加密存储
├── 策略层: 签名验证
└── 审计层: 完整日志

最小权限（Principle of Least Privilege）
├── API访问控制
├── 策略命名空间隔离
├── 数据访问限制
└── 运行时权限最小化

零信任（Zero Trust）
├── 默认拒绝
├── 持续验证
├── 最小暴露面
└── 微分段隔离
```

**安全设计哲学**：

- 🔒 **默认安全**: 安全配置开箱即用
- 🛡️ **防御编程**: 输入验证，输出编码
- 🔍 **可观测性**: 全面审计跟踪
- 🚨 **快速响应**: 漏洞修复SLA < 7天
- ✅ **合规优先**: 满足主流安全标准

### 1.2 威胁模型

**威胁分类**：

```text
T1. 恶意策略注入
   └── 风险: 未授权策略执行
   └── 缓解: Bundle签名验证

T2. 数据泄露
   └── 风险: 敏感数据暴露
   └── 缓解: 数据加密 + 访问控制

T3. 拒绝服务（DoS）
   └── 风险: 资源耗尽
   └── 缓解: 速率限制 + 资源配额

T4. 中间人攻击（MitM）
   └── 风险: 通信窃听/篡改
   └── 缓解: TLS/mTLS

T5. 权限提升
   └── 风险: 未授权访问
   └── 缓解: 最小权限 + RBAC

T6. 供应链攻击
   └── 风险: 依赖污染
   └── 缓解: SBOM + 签名验证
```

**STRIDE威胁建模**：

| 威胁类型 | OPA场景 | 防护措施 |
|---------|---------|---------|
| **Spoofing** (欺骗) | 伪造API请求 | Token认证 + mTLS |
| **Tampering** (篡改) | 修改Bundle | 数字签名 |
| **Repudiation** (否认) | 否认决策 | 决策日志 + 审计 |
| **Information Disclosure** | 策略泄露 | 访问控制 + 加密 |
| **Denial of Service** | 恶意策略消耗资源 | 超时 + 配额 |
| **Elevation of Privilege** | 突破命名空间 | 策略隔离 |

### 1.3 安全边界

**部署边界**：

```text
┌─────────────────────────────────────────┐
│         外部网络（不受信）                  │
│  ┌───────────────────────────────────┐  │
│  │   负载均衡器 (TLS Termination)     │  │
│  └───────────────┬───────────────────┘  │
│                  │ HTTPS/gRPC            │
│  ┌───────────────▼───────────────────┐  │
│  │   OPA Server (mTLS Optional)      │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │  认证中间件                  │  │  │
│  │  │  ├── Token验证              │  │  │
│  │  │  └── RBAC授权               │  │  │
│  │  └─────────────┬───────────────┘  │  │
│  │                │                   │  │
│  │  ┌─────────────▼───────────────┐  │  │
│  │  │  策略执行引擎（隔离）         │  │  │
│  │  │  ├── 策略验证               │  │  │
│  │  │  └── 数据访问控制            │  │  │
│  │  └─────────────────────────────┘  │  │
│  └───────────────────────────────────┘  │
│                                         │
│  ┌───────────────────────────────────┐  │
│  │   Bundle存储 (签名验证)            │  │
│  │   - S3/GCS (Server-side加密)      │  │
│  │   - OCI Registry (Cosign签名)     │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

---

## 2. 策略安全

### 2.1 策略隔离

**命名空间隔离**：

```rego
# ❌ 不安全: 跨命名空间访问
package tenant_a.policies

import data.tenant_b.secrets  # 危险!

allow if {
    data.tenant_b.secrets.api_key == input.key
}

# ✅ 安全: 严格命名空间边界
package tenant_a.policies

# 只访问本租户数据
allow if {
    user := data.tenant_a.users[input.user_id]
    input.action in user.permissions
}
```

**策略沙箱配置**：

```yaml
# config.yaml
bundles:
  tenant_a:
    resource: "s3://bundles/tenant_a.tar.gz"
    persist: true
    # 限制访问路径
    roots:
      - data/tenant_a
      - system/authz/tenant_a
```

### 2.2 策略验证

**静态分析**：

```bash
# 1. 语法检查
opa check policy/

# 2. 类型检查
opa check --strict policy/

# 3. 安全扫描
conftest test policy/ --policy security-rules/

# 4. 代码质量检查
opa fmt --check --diff policy/
```

**测试覆盖率**：

```bash
# 单元测试（覆盖率 > 80%）
opa test policy/ --coverage --threshold=80

# 集成测试
opa test policy/ integration_test/ -v

# 性能测试
opa bench policy/ --count 10000
```

**策略Lint规则**：

```rego
# security-rules/no-hardcoded-secrets.rego
package security

violation[{"msg": msg}] {
    # 检测硬编码密钥
    some i
    walk(input.modules[_], [path, value])
    is_string(value)
    regex.match(`(?i)(password|secret|key)\s*[:=]\s*["'][^"']+["']`, value)
    msg := sprintf("硬编码敏感信息: %v", [path])
}
```

### 2.3 策略审计

**版本控制**：

```bash
# Git提交钩子
#!/bin/bash
# .git/hooks/pre-commit

# 运行策略验证
opa check --strict policy/
opa test policy/ --coverage --threshold=80

# 安全扫描
conftest test policy/ --policy security-rules/

# 如果失败，拒绝提交
if [ $? -ne 0 ]; then
    echo "策略验证失败，无法提交"
    exit 1
fi
```

**变更审计**：

```yaml
# 策略变更审批流程
version: 2
approvals:
  - name: security-review
    required: true
    reviewers:
      teams:
        - security-team
    conditions:
      - files_modified:
          patterns:
            - "policy/**/*.rego"
```

---

## 3. 数据安全

### 3.1 敏感数据保护

**数据分类**：

```rego
package data_classification

# 定义敏感数据级别
sensitivity := {
    "public": 0,
    "internal": 1,
    "confidential": 2,
    "restricted": 3
}

# 数据字段分类
field_classification := {
    "user.email": "internal",
    "user.ssn": "restricted",
    "user.name": "internal",
    "transaction.amount": "confidential",
    "audit_log.timestamp": "public"
}

# 访问控制规则
allow_access if {
    user_clearance := data.users[input.user].clearance_level
    field_level := sensitivity[field_classification[input.field]]
    user_clearance >= field_level
}
```

**数据脱敏**：

```rego
package data_masking

import rego.v1

# 脱敏敏感字段
mask_pii(data) := masked if {
    masked := object.union(
        object.remove(data, ["ssn", "credit_card"]),
        {
            "ssn": mask_ssn(data.ssn),
            "credit_card": mask_card(data.credit_card)
        }
    )
}

mask_ssn(ssn) := sprintf("***-**-%s", [substring(ssn, -4, -1)])
mask_card(card) := sprintf("****-****-****-%s", [substring(card, -4, -1)])

# 决策中使用脱敏数据
result := response if {
    raw_data := data.users[input.user_id]
    response := {
        "allowed": true,
        "user": mask_pii(raw_data)
    }
}
```

### 3.2 数据加密

**静态加密（at-rest）**：

```yaml
# Bundle存储加密
# AWS S3 Server-Side Encryption
services:
  s3:
    credentials:
      aws_access_key_id: "${AWS_ACCESS_KEY_ID}"
      aws_secret_access_key: "${AWS_SECRET_ACCESS_KEY}"
    
bundles:
  main:
    service: s3
    resource: "s3://opa-bundles/policy.tar.gz"
    # S3自动使用SSE-S3/SSE-KMS加密
```

**传输加密（in-transit）**：

```yaml
# TLS配置
services:
  - name: bundle-server
    url: https://bundles.example.com
    credentials:
      bearer:
        token: "${BUNDLE_TOKEN}"
    # TLS证书验证
    tls:
      ca_cert: /certs/ca.crt
      client_cert: /certs/client.crt
      client_key: /certs/client.key
```

**内存加密**：

```text
注意: OPA运行时内存中的数据是明文
      需要在操作系统/硬件层面实现内存加密

推荐方案:
  - Intel SGX (Software Guard Extensions)
  - AMD SEV (Secure Encrypted Virtualization)
  - 使用加密的Swap分区
```

### 3.3 数据访问控制

**最小权限数据访问**：

```rego
package data_access

import rego.v1

# 只查询必要的数据
user_permissions[perm] if {
    # ❌ 不好: 加载所有用户
    # user := data.users[_]
    
    # ✅ 好: 直接索引
    user := data.users[input.user_id]
    some perm in user.permissions
}

# 使用部分求值减少数据暴露
# opa compile --partial --unknowns input.user_id
```

---

## 4. 通信安全

### 4.1 TLS配置

**最佳TLS配置**：

```yaml
# OPA配置: 强制TLS 1.3
services:
  - name: opa-server
    url: https://opa.example.com:8181
    tls:
      # 最低TLS版本
      min_version: 1.3
      # 允许的加密套件（仅强加密）
      cipher_suites:
        - TLS_AES_128_GCM_SHA256
        - TLS_AES_256_GCM_SHA384
        - TLS_CHACHA20_POLY1305_SHA256
```

**OPA Server TLS启动**：

```bash
# 生成自签名证书（开发环境）
openssl req -x509 -newkey rsa:4096 -nodes \
  -keyout server-key.pem \
  -out server-cert.pem \
  -days 365 \
  -subj "/CN=opa.local"

# 启动OPA with TLS
opa run --server \
  --tls-cert-file server-cert.pem \
  --tls-private-key-file server-key.pem \
  --addr https://0.0.0.0:8181
```

### 4.2 证书管理

**证书生命周期**：

```text
证书管理流程
├── 1. 生成 (生产环境使用CA签名证书)
│   └── Let's Encrypt / 企业PKI
├── 2. 分发 (使用Secret管理)
│   └── Kubernetes Secrets / HashiCorp Vault
├── 3. 轮换 (自动化)
│   └── cert-manager (K8s)
└── 4. 撤销 (紧急情况)
    └── OCSP/CRL检查
```

**Kubernetes证书管理**：

```yaml
# cert-manager签发证书
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: opa-tls
  namespace: opa
spec:
  secretName: opa-tls-secret
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - opa.example.com
  duration: 2160h  # 90天
  renewBefore: 360h  # 提前15天续期

---
# OPA Deployment使用证书
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
spec:
  template:
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:latest
        args:
          - "run"
          - "--server"
          - "--tls-cert-file=/certs/tls.crt"
          - "--tls-private-key-file=/certs/tls.key"
        volumeMounts:
        - name: tls-certs
          mountPath: /certs
          readOnly: true
      volumes:
      - name: tls-certs
        secret:
          secretName: opa-tls-secret
```

### 4.3 mTLS双向认证

**mTLS配置**：

```yaml
# OPA Server要求客户端证书
services:
  - name: opa-mtls
    url: https://opa.example.com:8181
    credentials:
      client_tls:
        cert: /certs/client.crt
        private_key: /certs/client.key
        ca: /certs/ca.crt
        # 强制验证客户端证书
        insecure_skip_verify: false
```

**启动参数**：

```bash
opa run --server \
  --tls-cert-file /certs/server.crt \
  --tls-private-key-file /certs/server.key \
  --tls-ca-cert-file /certs/ca.crt \
  --tls-client-auth required \
  --addr https://0.0.0.0:8181
```

**客户端证书访问**：

```bash
# 使用客户端证书调用API
curl --cert /certs/client.crt \
     --key /certs/client.key \
     --cacert /certs/ca.crt \
     https://opa.example.com:8181/v1/data/authz/allow \
     -d '{"input": {"user": "alice"}}'
```

---

## 5. 认证与授权

### 5.1 API认证机制

**Bearer Token认证**：

```yaml
# config.yaml
services:
  - name: bundle-api
    url: https://api.example.com
    credentials:
      bearer:
        token: "${BEARER_TOKEN}"
        scheme: "Bearer"
```

**OAuth 2.0认证**：

```yaml
services:
  - name: oauth-api
    url: https://api.example.com
    credentials:
      oauth2:
        token_url: https://auth.example.com/token
        client_id: "${CLIENT_ID}"
        client_secret: "${CLIENT_SECRET}"
        scopes:
          - opa.read
          - opa.write
```

**自定义认证中间件**：

```go
// Go中间件示例
func AuthMiddleware(apiKey string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            token := r.Header.Get("Authorization")
            if token != "Bearer "+apiKey {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            next.ServeHTTP(w, r)
        })
    }
}

// 使用中间件
http.Handle("/v1/", AuthMiddleware(os.Getenv("API_KEY"))(opaHandler))
```

### 5.2 Token管理

**Token生成与验证**：

```rego
package api.authz

import rego.v1

# JWT验证
default allow := false

allow if {
    # 验证JWT签名
    io.jwt.verify_hs256(input.token, data.jwt_secret)
    
    # 解码JWT
    [_, payload, _] := io.jwt.decode(input.token)
    
    # 检查过期时间
    payload.exp > time.now_ns() / 1000000000
    
    # 检查作用域
    required_scope := sprintf("%s:%s", [input.method, input.path])
    required_scope in payload.scopes
}
```

### 5.3 RBAC授权

**API级别RBAC**：

```rego
package system.authz

import rego.v1

# API访问控制矩阵
api_permissions := {
    "admin": {
        "/v1/policies": ["GET", "PUT", "DELETE"],
        "/v1/data": ["GET", "POST"],
        "/health": ["GET"]
    },
    "operator": {
        "/v1/policies": ["GET"],
        "/v1/data": ["GET", "POST"],
        "/health": ["GET"]
    },
    "readonly": {
        "/v1/data": ["GET"],
        "/health": ["GET"]
    }
}

# 授权决策
default allow := false

allow if {
    user_role := data.users[input.user].role
    allowed_methods := api_permissions[user_role][input.path]
    input.method in allowed_methods
}
```

---

## 6. Bundle签名与验证

### 6.1 签名工作流

**端到端签名流程**：

```bash
# 1. 生成密钥对
openssl genrsa -out private_key.pem 2048
openssl rsa -in private_key.pem -pubout -out public_key.pem

# 2. 构建Bundle
opa build -b policy/ data/ -o bundle.tar.gz

# 3. 签名Bundle
opa sign --signing-key private_key.pem \
  --bundle bundle.tar.gz \
  --output .signatures.json

# 4. 创建签名Bundle
tar -czf signed_bundle.tar.gz bundle.tar.gz .signatures.json

# 5. 上传到Bundle服务器
aws s3 cp signed_bundle.tar.gz s3://opa-bundles/
```

**OPA验证配置**：

```yaml
# config.yaml
bundles:
  main:
    resource: "s3://opa-bundles/signed_bundle.tar.gz"
    signing:
      keyid: "my-key"
      scope: "write"
    verification:
      keyid: "my-key"
      scope: "write"
      public_key: |
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
        -----END PUBLIC KEY-----
```

### 6.2 密钥管理

**密钥存储方案**：

```text
生产环境密钥管理
├── 1. HSM (Hardware Security Module)
│   └── 最高安全级别，FIPS 140-2 Level 3
├── 2. KMS (Key Management Service)
│   ├── AWS KMS
│   ├── GCP Cloud KMS
│   └── Azure Key Vault
├── 3. Secret Manager
│   ├── HashiCorp Vault
│   └── Kubernetes Secrets (加密存储)
└── 4. 文件系统（仅开发环境）
    └── 0600权限保护
```

**Vault集成示例**：

```yaml
# OPA从Vault获取签名公钥
bundles:
  main:
    resource: "https://bundles.example.com/policy.tar.gz"
    signing:
      keyid: "prod-bundle-key"
    verification:
      keyid: "prod-bundle-key"
      # 从Vault读取公钥
      public_key_path: "vault://secret/opa/bundle-public-key"

services:
  vault:
    url: https://vault.example.com:8200
    credentials:
      token: "${VAULT_TOKEN}"
```

### 6.3 验证策略

**严格验证策略**：

```yaml
# config.yaml - 生产环境配置
bundles:
  main:
    resource: "https://bundles.example.com/policy.tar.gz"
    signing:
      keyid: "prod-2025"
    verification:
      # 强制验证签名
      keyid: "prod-2025"
      scope: "write"
      public_key: "${BUNDLE_PUBLIC_KEY}"
      # 签名失败时拒绝加载
      exclude_files:
        - "*_test.rego"  # 排除测试文件
```

**签名审计日志**：

```json
{
  "level": "info",
  "msg": "Bundle loaded and verified successfully",
  "bundle": "main",
  "revision": "abc123",
  "signature_verified": true,
  "keyid": "prod-2025",
  "timestamp": "2025-10-21T10:30:00Z"
}
```

---

## 7. 审计与日志

### 7.1 决策日志

**决策日志配置**：

```yaml
# config.yaml
decision_logs:
  service: audit-log-service
  resource: /logs/decisions
  reporting:
    min_delay_seconds: 10
    max_delay_seconds: 30
  
  # 脱敏配置
  mask_decision:
    - path: ["input", "user", "password"]
      value: "***REDACTED***"
    - path: ["result", "api_key"]
      value: "***REDACTED***"
```

**日志格式**：

```json
{
  "decision_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2025-10-21T10:30:00.123456Z",
  "query": "data.authz.allow",
  "input": {
    "user": "alice",
    "action": "read",
    "resource": "/api/data"
  },
  "result": true,
  "metrics": {
    "timer_rego_query_eval_ns": 1523456
  },
  "labels": {
    "environment": "production",
    "service": "api-gateway"
  }
}
```

### 7.2 审计追踪

**完整审计链**：

```text
审计事件类型
├── 1. 策略变更
│   ├── Bundle上传
│   ├── 策略激活
│   └── 策略删除
├── 2. 配置变更
│   ├── OPA配置更新
│   └── 权限变更
├── 3. 访问事件
│   ├── API调用
│   ├── 认证失败
│   └── 授权拒绝
└── 4. 系统事件
    ├── OPA启动/停止
    ├── Bundle加载失败
    └── 性能告警
```

**Syslog集成**：

```yaml
# 发送日志到Syslog
decision_logs:
  plugin: syslog
  config:
    network: udp
    address: syslog.example.com:514
    priority: 86  # LOG_LOCAL5 | LOG_INFO
    tag: opa-decisions
```

### 7.3 日志保护

**日志完整性**：

```bash
# 使用签名保护日志
opa run --server \
  --set decision_logs.service=log-server \
  --set decision_logs.signing.key_id=log-key \
  --signing-key /keys/log-private.pem
```

**日志加密传输**：

```yaml
services:
  log-server:
    url: https://logs.example.com
    credentials:
      bearer:
        token: "${LOG_TOKEN}"
    tls:
      ca_cert: /certs/ca.crt
```

---

## 8. 漏洞管理

### 8.1 漏洞扫描

**容器镜像扫描**：

```bash
# Trivy扫描OPA镜像
trivy image openpolicyagent/opa:0.60.0

# Grype扫描
grype openpolicyagent/opa:0.60.0

# Snyk扫描
snyk container test openpolicyagent/opa:0.60.0
```

**SBOM生成**：

```bash
# 生成软件物料清单
syft openpolicyagent/opa:0.60.0 -o cyclonedx-json > opa-sbom.json

# 验证SBOM
cyclonedx-cli validate --input-file opa-sbom.json
```

### 8.2 依赖管理

**Go模块审计**：

```bash
# 检查Go依赖漏洞
cd opa-project/
go list -json -m all | nancy sleuth

# Govulncheck
govulncheck ./...
```

**依赖更新策略**：

```text
依赖更新优先级
├── P0: 严重漏洞 (CVSSv3 >= 9.0)
│   └── SLA: 24小时内修复
├── P1: 高危漏洞 (7.0 <= CVSSv3 < 9.0)
│   └── SLA: 7天内修复
├── P2: 中危漏洞 (4.0 <= CVSSv3 < 7.0)
│   └── SLA: 30天内修复
└── P3: 低危漏洞 (CVSSv3 < 4.0)
    └── SLA: 季度更新
```

### 8.3 安全更新

**漏洞通知机制**：

```yaml
# GitHub Security Advisories订阅
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "gomod"
    directory: "/"
    schedule:
      interval: "daily"
    open-pull-requests-limit: 10
    # 自动合并安全更新
    allow:
      - dependency-type: "direct"
        update-types: ["security"]
```

---

## 9. 合规标准

### 9.1 SOC 2合规

**SOC 2控制点映射**：

| SOC 2原则 | OPA实现 |
|----------|---------|
| **CC6.1** (逻辑访问控制) | API认证授权 + RBAC |
| **CC6.6** (数据传输保护) | TLS/mTLS加密 |
| **CC6.8** (审计日志) | 决策日志 + 审计追踪 |
| **CC7.2** (系统监控) | Prometheus metrics + 告警 |
| **CC8.1** (变更管理) | Bundle签名 + Git审计 |

### 9.2 ISO 27001合规

**控制措施**：

```text
A.9 访问控制
  ├── A.9.1.1: 访问控制策略 → OPA策略
  ├── A.9.2.1: 用户注册 → RBAC配置
  └── A.9.4.1: 系统访问限制 → API认证

A.10 密码学
  ├── A.10.1.1: 密码控制使用策略 → TLS/签名
  └── A.10.1.2: 密钥管理 → Vault/KMS

A.12 运营安全
  ├── A.12.4.1: 日志记录 → 决策日志
  └── A.12.6.1: 漏洞管理 → 扫描+更新
```

### 9.3 GDPR/CCPA

**个人数据保护**：

```rego
package gdpr

import rego.v1

# 数据最小化
collect_minimum_data(full_data) := minimal_data if {
    # 只收集必要字段
    minimal_data := {
        "user_id": full_data.user_id,
        "consent_given": full_data.consent_given
        # 不收集敏感字段: email, phone, address
    }
}

# 用户同意检查
allow_data_processing if {
    user := data.users[input.user_id]
    user.gdpr_consent == true
    user.consent_date > time.parse_rfc3339_ns("2025-01-01T00:00:00Z")
}

# 数据删除权（被遗忘权）
allow_data_deletion if {
    input.action == "delete_user_data"
    input.user_id == input.requesting_user  # 用户本人请求
}
```

**数据留存策略**：

```yaml
# 日志留存配置
decision_logs:
  service: gdpr-compliant-logs
  # 自动删除90天前的日志
  retention:
    days: 90
  # 匿名化字段
  anonymize:
    - path: ["input", "user", "email"]
      method: "hash"  # SHA-256哈希
```

---

## 10. 最佳实践

### 10.1 安全配置清单

**生产环境检查清单**：

```text
网络安全
□ TLS 1.3启用
□ mTLS配置（可选但推荐）
□ 防火墙规则限制访问
□ 负载均衡器健康检查配置

认证授权
□ API Token认证启用
□ Token定期轮换（<90天）
□ RBAC策略定义
□ 最小权限原则实施

数据保护
□ 敏感数据加密
□ Bundle签名验证启用
□ 决策日志脱敏配置
□ PII数据访问审计

审计合规
□ 决策日志启用
□ 审计日志集中收集
□ 日志留存策略定义
□ 定期安全审查

运维安全
□ 漏洞扫描自动化
□ 依赖更新策略
□ 安全事件响应计划
□ 灾难恢复计划
```

### 10.2 安全加固指南

**Kubernetes部署加固**：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa-hardened
spec:
  template:
    spec:
      # 安全上下文
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      
      containers:
      - name: opa
        image: openpolicyagent/opa:0.60.0
        
        # 容器安全上下文
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
              - ALL
        
        # 资源限制
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        
        # 健康检查
        livenessProbe:
          httpGet:
            path: /health?bundle=true
            port: 8181
            scheme: HTTPS
        
        # 只读文件系统需要临时目录
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      
      volumes:
      - name: tmp
        emptyDir: {}
      
      # Pod安全策略
      automountServiceAccountToken: false
```

### 10.3 事件响应

**安全事件分类**：

| 严重程度 | 事件类型 | 响应时间 | 响应措施 |
|---------|---------|---------|---------|
| **Critical** | 0-day漏洞利用 | < 1小时 | 立即隔离 + 回滚 |
| **High** | 未授权访问成功 | < 4小时 | 吊销凭证 + 审计 |
| **Medium** | 策略验证失败 | < 24小时 | 调查 + 修复 |
| **Low** | 配置偏差 | < 1周 | 计划修复 |

**事件响应剧本**：

```text
1. 检测（Detection）
   ├── 监控告警触发
   ├── 日志异常检测
   └── 漏洞扫描发现

2. 隔离（Containment）
   ├── 网络隔离
   ├── 禁用受影响账户
   └── 回滚到已知良好版本

3. 根因分析（Root Cause Analysis）
   ├── 收集日志和指标
   ├── 时间线重建
   └── 漏洞复现

4. 修复（Remediation）
   ├── 应用安全补丁
   ├── 更新配置
   └── 部署新版本

5. 恢复（Recovery）
   ├── 逐步恢复服务
   ├── 验证修复有效性
   └── 监控异常行为

6. 事后总结（Post-Incident Review）
   ├── 事件报告
   ├── 改进措施
   └── 更新剧本
```

---

## 附录A：安全配置模板

**生产级配置**：

```yaml
# opa-production-config.yaml

# 服务器配置
server:
  addr: :8181
  encoding:
    gzip:
      min_length: 1024

# TLS配置
services:
  - name: main
    url: https://opa.example.com:8181
    tls:
      cert_file: /certs/server.crt
      key_file: /certs/server.key
      ca_file: /certs/ca.crt
      min_version: 1.3

# Bundle配置（含签名验证）
bundles:
  main:
    service: bundle-server
    resource: https://bundles.example.com/policy.tar.gz
    signing:
      keyid: prod-2025
    verification:
      keyid: prod-2025
      scope: write
      public_key: |
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMI...
        -----END PUBLIC KEY-----
    persist: false  # 安全：不持久化到磁盘
    polling:
      min_delay_seconds: 60
      max_delay_seconds: 120

# 决策日志（含脱敏）
decision_logs:
  service: log-collector
  resource: /api/logs/decisions
  reporting:
    min_delay_seconds: 10
    max_delay_seconds: 30
  mask_decision:
    - path: ["input", "user", "password"]
      value: "***REDACTED***"
    - path: ["input", "token"]
      value: "***REDACTED***"

# 分布式追踪
distributed_tracing:
  type: grpc
  address: tempo.example.com:4317
  sample_percentage: 10

# 插件配置
plugins:
  envoy_ext_authz_grpc:
    addr: :9191
    enable_reflection: false

# 状态API
status:
  service: status-collector
  prometheus: true

# 认证
authentication:
  token:
    verification_key: "${JWT_PUBLIC_KEY}"
    issuer: "https://auth.example.com"

# 授权
authorization:
  path: system/authz/allow
```

---

## 附录B：常见安全问题Q&A

**Q1: OPA是否需要防火墙保护？**

A: 是的。生产环境应：

- 仅允许必要的源IP访问
- 使用网络策略（Kubernetes NetworkPolicy）
- 在VPC内部署，不暴露公网

**Q2: 如何保护存储在OPA中的敏感数据？**

A: 多层防护：

- Bundle签名验证
- 数据加密传输（TLS）
- 策略中敏感数据脱敏
- 使用Secret管理器（Vault）而非直接存储

**Q3: OPA的决策日志会泄露敏感信息吗？**

A: 可能，需要配置：

- `mask_decision`脱敏配置
- 日志传输加密
- 访问控制限制日志查看
- 定期审计日志内容

**Q4: 如何验证Bundle没有被篡改？**

A: 使用数字签名：

```bash
# 签名
opa sign --signing-key private.pem bundle.tar.gz

# 验证（OPA自动）
bundles:
  main:
    verification:
      public_key: ...
```

**Q5: OPA支持审计合规吗？**

A: 支持主流标准：

- SOC 2: 决策日志、访问控制
- ISO 27001: 加密、审计、变更管理
- GDPR: 数据最小化、脱敏、留存策略

**Q6: 如何防止恶意策略消耗资源导致DoS？**

A: 多种措施：

- 策略求值超时限制
- 资源配额（CPU/内存limits）
- 速率限制
- 策略复杂度检查（CI阶段）

**Q7: OPA的密钥管理最佳实践？**

A: 推荐方案：

- 生产：HSM或云KMS
- 密钥轮换：每90天
- 权限：最小权限访问
- 审计：所有密钥操作记录

**Q8: 如何实现多租户隔离？**

A: 命名空间隔离：

```rego
package tenant_a.policies
# 限制只能访问 data.tenant_a.*
```

配合：

- Bundle分租户签名
- 独立OPA实例（可选）
- 严格的策略Review

---

**相关文档**：

- [API规范](./01.1-API规范.md)
- [Bundle格式规范](./01.2-Bundle格式规范.md)
- [Kubernetes集成](../04-生态系统/04.1-Kubernetes集成.md)

**参考资源**：

- OPA Security Best Practices: <https://www.openpolicyagent.org/docs/latest/security/>
- Bundle Signing: <https://www.openpolicyagent.org/docs/latest/management-bundles/#signing>
- CNCF Security TAG: <https://github.com/cncf/tag-security>
- OWASP Top 10: <https://owasp.org/www-project-top-ten/>
