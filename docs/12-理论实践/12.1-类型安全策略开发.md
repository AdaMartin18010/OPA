# 类型安全策略开发

> **文档类型**: 理论实践桥梁  
> **核心主题**: 基于类型系统的安全策略开发实践  
> **适用读者**: 策略开发者、类型系统研究者、DevSecOps工程师  
> **先修知识**: [Rego语言基础](../02-语言模型/02.1-Rego语言规范.md)、[类型系统形式化](../06-形式化证明/06.5-类型系统形式化.md)  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 4.1 - 理论实践  
> **实践价值**: 编写类型安全、可维护的Rego策略

---

## 🎯 文档目标

本文档将**类型系统理论**应用于**实际策略开发**，帮助开发者编写类型安全、健壮的Rego策略。

**核心内容**:

- 类型推导在策略开发中的应用
- 常见类型错误及诊断方法
- 类型驱动开发（Type-Driven Development）
- 类型安全模式与反模式
- 静态类型检查工具

**学习价值**:

- 💪 编写更健壮的策略
- 🐛 快速定位类型错误
- 🛡️ 防止运行时类型异常
- 📚 提高代码可维护性

---

## 目录

- [类型安全策略开发](#类型安全策略开发)
  - [🎯 文档目标](#-文档目标)
  - [目录](#目录)
  - [1. 类型系统回顾](#1-类型系统回顾)
    - [1.1 Rego类型系统基础](#11-rego类型系统基础)
    - [1.2 类型推导规则](#12-类型推导规则)
    - [1.3 类型安全的重要性](#13-类型安全的重要性)
  - [2. 类型驱动开发](#2-类型驱动开发)
    - [2.1 TDD原则](#21-tdd原则)
    - [2.2 类型作为规约](#22-类型作为规约)
    - [2.3 类型优先设计](#23-类型优先设计)
  - [3. 常见类型错误](#3-常见类型错误)
    - [3.1 类型不匹配](#31-类型不匹配)
    - [3.2 空值错误](#32-空值错误)
    - [3.3 集合类型错误](#33-集合类型错误)
  - [4. 类型注解与文档](#4-类型注解与文档)
    - [4.1 注释中的类型信息](#41-注释中的类型信息)
    - [4.2 输入输出契约](#42-输入输出契约)
    - [4.3 类型示例](#43-类型示例)
  - [5. 类型安全模式](#5-类型安全模式)
    - [5.1 防御性编程](#51-防御性编程)
    - [5.2 类型卫语句](#52-类型卫语句)
    - [5.3 安全的类型转换](#53-安全的类型转换)
  - [6. 高级类型技术](#6-高级类型技术)
    - [6.1 泛型模式](#61-泛型模式)
    - [6.2 类型多态](#62-类型多态)
    - [6.3 依赖类型模拟](#63-依赖类型模拟)
  - [7. 静态分析工具](#7-静态分析工具)
    - [7.1 OPA类型检查器](#71-opa类型检查器)
    - [7.2 Regal Linter](#72-regal-linter)
    - [7.3 自定义检查规则](#73-自定义检查规则)
  - [8. 测试与验证](#8-测试与验证)
    - [8.1 类型测试](#81-类型测试)
    - [8.2 属性测试](#82-属性测试)
    - [8.3 模糊测试](#83-模糊测试)
  - [9. 实战案例](#9-实战案例)
    - [9.1 RBAC策略](#91-rbac策略)
    - [9.2 数据验证策略](#92-数据验证策略)
    - [9.3 API授权策略](#93-api授权策略)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 设计原则](#101-设计原则)
    - [10.2 代码组织](#102-代码组织)
    - [10.3 持续改进](#103-持续改进)
  - [附录](#附录)
    - [A. 类型速查表](#a-类型速查表)
    - [B. 错误诊断指南](#b-错误诊断指南)
    - [C. 工具配置](#c-工具配置)

---

## 1. 类型系统回顾

### 1.1 Rego类型系统基础

**Rego的类型层次**:

```text
any
├── null
├── boolean
├── number
├── string
├── array<T>
├── object<K, V>
└── set<T>
```

**类型示例**:

```rego
# 标量类型
null_value := null
bool_value := true
num_value := 42
str_value := "hello"

# 集合类型
arr_value := [1, 2, 3]              # array<number>
obj_value := {"key": "value"}       # object<string, string>
set_value := {1, 2, 3}              # set<number>

# 嵌套类型
nested := {                         # object<string, array<object<string, number>>>
    "users": [
        {"id": 1, "age": 30},
        {"id": 2, "age": 25}
    ]
}
```

### 1.2 类型推导规则

**算术运算**:

```rego
# ✓ 正确：number + number = number
result := 10 + 20  # result: number = 30

# ✗ 错误：string + number
result := "10" + 20  # 类型错误！
```

**字符串拼接**:

```rego
# ✓ 使用 sprintf
name := "Alice"
greeting := sprintf("Hello, %s!", [name])  # string

# ✓ 使用 concat
parts := ["Hello", "World"]
message := concat(", ", parts)  # string
```

**集合操作**:

```rego
# ✓ 正确：set<T> | set<T> = set<T>
s1 := {1, 2, 3}
s2 := {3, 4, 5}
union := s1 | s2  # {1, 2, 3, 4, 5}

# ✗ 错误：array | set
arr := [1, 2, 3]
s := {4, 5}
result := arr | s  # 类型错误！
```

### 1.3 类型安全的重要性

**运行时错误示例**:

```rego
# 不安全的策略
allow {
    # 假设 input.age 是 number
    input.age >= 18
}

# 问题：如果 input.age 是 string "18" 或 null？
# 结果：运行时错误或意外行为
```

**类型安全版本**:

```rego
allow {
    # 类型卫语句
    is_number(input.age)
    input.age >= 18
}
```

---

## 2. 类型驱动开发

### 2.1 TDD原则

**类型优先思考**:

1. **设计类型契约** → 定义输入输出类型
2. **编写类型检查** → 确保类型正确
3. **实现业务逻辑** → 在类型安全的基础上

### 2.2 类型作为规约

**示例：用户权限检查**:

**步骤1：定义类型契约**:

```rego
# 类型契约（注释形式）
# @input: {
#   "user": string,
#   "resource": string,
#   "action": string
# }
# @output: boolean
# @requires: data.permissions[user][resource][action] exists
```

**步骤2：实现类型检查**:

```rego
# 辅助函数：验证输入类型
valid_input {
    is_string(input.user)
    is_string(input.resource)
    is_string(input.action)
}
```

**步骤3：实现业务逻辑**:

```rego
allow {
    valid_input  # 类型检查
    data.permissions[input.user][input.resource][input.action]
}
```

### 2.3 类型优先设计

**设计模式**:

```rego
# 1. 定义数据模型
package model

# User类型
# type User = {
#   id: string,
#   name: string,
#   roles: set<string>,
#   metadata: object<string, any>
# }

# 2. 定义类型验证
is_valid_user(user) {
    is_string(user.id)
    is_string(user.name)
    is_set(user.roles)
    is_object(user.metadata)
}

# 3. 使用类型安全的函数
get_user_roles(user) := roles {
    is_valid_user(user)
    roles := user.roles
}
```

---

## 3. 常见类型错误

### 3.1 类型不匹配

**错误示例**:

```rego
# 错误1：比较不同类型
allow {
    input.count == "10"  # number vs string
}

# 错误2：对非集合使用集合操作
allow {
    input.value in 42  # 42不是集合
}

# 错误3：对非数字进行算术
total := input.price + input.tax  # 如果是字符串？
```

**修正方法**:

```rego
# 修正1：类型转换
allow {
    to_number(input.count) == 10
}

# 修正2：类型检查
allow {
    is_array(input.values)
    input.value in input.values
}

# 修正3：类型验证
total := result {
    is_number(input.price)
    is_number(input.tax)
    result := input.price + input.tax
}
```

### 3.2 空值错误

**问题：空引用**:

```rego
# 不安全
user_name := input.user.name  # 如果 input.user 不存在？

# 不安全
age := data.users[id].age  # 如果 id 不存在？
```

**安全处理**:

```rego
# 方法1：使用默认值
user_name := name {
    name := input.user.name
} else := "anonymous"

# 方法2：显式检查
safe_age := age {
    data.users[id]
    age := data.users[id].age
}

# 方法3：使用 object.get (OPA 0.43+)
age := object.get(data.users[id], "age", 0)
```

### 3.3 集合类型错误

**Array vs Set vs Object**:

```rego
# 错误：混淆 array 和 set
arr := [1, 2, 3, 2]  # array: [1, 2, 3, 2]
set := {1, 2, 3, 2}  # set: {1, 2, 3}

# 错误：对 array 使用 set 操作
result := [1, 2] | [3, 4]  # 错误！应该用 array.concat

# 正确：转换后操作
result := arr_union(arr1, arr2)

arr_union(a1, a2) := result {
    s1 := {x | some x in a1}
    s2 := {x | some x in a2}
    result := s1 | s2
}
```

---

## 4. 类型注解与文档

### 4.1 注释中的类型信息

**标准格式**:

```rego
# has_permission 检查用户是否有特定权限
#
# @param user: string - 用户ID
# @param resource: string - 资源标识
# @param action: string - 操作类型
# @return: boolean - 是否有权限
# @example: has_permission("alice", "/api/users", "read") == true
has_permission(user, resource, action) {
    data.acl[user][resource][action]
}
```

### 4.2 输入输出契约

**Schema定义**:

```rego
package schema

# 定义输入Schema
input_schema := {
    "type": "object",
    "properties": {
        "user": {"type": "string"},
        "resource": {"type": "string"},
        "action": {"type": "string"},
        "context": {
            "type": "object",
            "properties": {
                "ip": {"type": "string"},
                "timestamp": {"type": "number"}
            }
        }
    },
    "required": ["user", "resource", "action"]
}

# 验证输入
validate_input {
    # 使用内置函数或自定义验证
    check_required_fields
    check_field_types
}

check_required_fields {
    input.user
    input.resource
    input.action
}

check_field_types {
    is_string(input.user)
    is_string(input.resource)
    is_string(input.action)
}
```

### 4.3 类型示例

**测试数据作为类型文档**:

```rego
# 测试文件提供类型示例
test_allow_admin {
    allow with input as {
        "user": "admin",        # string
        "resource": "/api",     # string
        "action": "write",      # string
        "context": {            # object
            "ip": "10.0.0.1",   # string
            "timestamp": 1234567890  # number
        }
    }
}
```

---

## 5. 类型安全模式

### 5.1 防御性编程

**Always Validate**:

```rego
# 不安全
process_user {
    age := input.user.age
    age >= 18
}

# 安全
process_user {
    # 多层防御
    input.user                    # 检查存在
    is_object(input.user)         # 检查类型
    input.user.age                # 检查字段
    is_number(input.user.age)     # 检查字段类型
    input.user.age >= 0           # 检查值域
    input.user.age < 150          # 合理性检查
    
    # 业务逻辑
    input.user.age >= 18
}
```

### 5.2 类型卫语句

**Guard Pattern**:

```rego
# 定义类型卫士
guard_string(x) {
    is_string(x)
    count(x) > 0  # 非空
}

guard_positive_number(x) {
    is_number(x)
    x > 0
}

guard_valid_email(x) {
    is_string(x)
    regex.match(`^[^@]+@[^@]+\.[^@]+$`, x)
}

# 使用卫士
allow {
    guard_string(input.user)
    guard_string(input.action)
    # 业务逻辑...
}
```

### 5.3 安全的类型转换

**类型转换函数**:

```rego
# 安全的字符串转数字
safe_to_number(str) := num {
    is_string(str)
    num := to_number(str)
} else := 0  # 默认值

# 安全的数组访问
safe_array_get(arr, idx) := val {
    is_array(arr)
    is_number(idx)
    idx >= 0
    idx < count(arr)
    val := arr[idx]
} else := null

# 安全的对象访问
safe_object_get(obj, key, default) := val {
    is_object(obj)
    is_string(key)
    val := obj[key]
} else := default
```

---

## 6. 高级类型技术

### 6.1 泛型模式

**泛型函数模拟**:

```rego
# 泛型 map 函数
map_array(arr, f) := [y | some i; x := arr[i]; y := f(x)]

# 使用
double(x) := x * 2
numbers := [1, 2, 3]
doubled := map_array(numbers, double)  # [2, 4, 6]

# 泛型 filter 函数
filter_array(arr, pred) := [x | some i; x := arr[i]; pred(x)]

# 使用
is_even(x) { x % 2 == 0 }
numbers := [1, 2, 3, 4]
evens := filter_array(numbers, is_even)  # [2, 4]
```

### 6.2 类型多态

**多态函数**:

```rego
# 接受多种类型的函数
length(x) := count(x) {
    # 对 array, set, object, string 都适用
    is_collection(x)
}

is_collection(x) {
    is_array(x)
} {
    is_set(x)
} {
    is_object(x)
} {
    is_string(x)
}
```

### 6.3 依赖类型模拟

**值依赖的类型检查**:

```rego
# 检查数组长度在范围内
valid_array_length(arr, min, max) {
    is_array(arr)
    is_number(min)
    is_number(max)
    length := count(arr)
    length >= min
    length <= max
}

# 检查对象包含特定键
valid_object_keys(obj, required_keys) {
    is_object(obj)
    is_set(required_keys)
    object_keys := {k | obj[k]}
    required_keys & object_keys == required_keys
}

# 使用
validate_user(user) {
    valid_object_keys(user, {"id", "name", "email"})
    is_string(user.id)
    count(user.id) > 0
}
```

---

## 7. 静态分析工具

### 7.1 OPA类型检查器

**使用OPA内置类型检查**:

```bash
# 检查策略
opa check policy.rego

# 严格模式
opa check --strict policy.rego

# 输出示例
policy.rego:10: error: undefined function concat/1
```

**常见检查**:

- ✅ 未定义规则引用
- ✅ 参数数量不匹配
- ✅ 明显的类型错误
- ⚠️ 注意：不是完整的类型检查器

### 7.2 Regal Linter

**安装Regal**:

```bash
# 安装
go install github.com/styrainc/regal@latest

# 或使用 Homebrew
brew install styrainc/packages/regal
```

**配置 .regal.yaml**:

```yaml
rules:
  style:
    prefer-snake-case:
      level: error
  bugs:
    undefined-function:
      level: error
    constant-condition:
      level: warning
  idiomatic:
    no-defined-entrypoint:
      level: warning
  custom:
    prefer-explicit-types:
      level: warning
```

**运行Linter**:

```bash
# 检查单个文件
regal lint policy.rego

# 检查整个目录
regal lint policies/

# 修复可修复的问题
regal lint --fix policies/
```

### 7.3 自定义检查规则

**编写自定义Regal规则**:

```rego
# custom-rules/type-annotations.rego
package custom.rules.type_annotations

import data.regal.ast

# METADATA
# description: 函数应有类型注释
rule := {
    "category": "custom",
    "title": "missing-type-annotation"
}

violations[msg] {
    some rule in ast.rules
    not has_type_annotation(rule)
    
    msg := {
        "location": rule.location,
        "message": sprintf("函数 %s 缺少类型注释", [rule.head.name])
    }
}

has_type_annotation(rule) {
    some comment in rule.comments
    contains(comment, "@param")
    contains(comment, "@return")
}
```

---

## 8. 测试与验证

### 8.1 类型测试

**测试不同类型输入**:

```rego
# 测试正常情况
test_allow_with_valid_input {
    allow with input as {
        "user": "alice",
        "action": "read"
    }
}

# 测试类型错误情况
test_reject_with_number_user {
    not allow with input as {
        "user": 123,  # 应该是 string
        "action": "read"
    }
}

test_reject_with_null_action {
    not allow with input as {
        "user": "alice",
        "action": null  # 应该是 string
    }
}

# 测试缺失字段
test_reject_with_missing_field {
    not allow with input as {
        "user": "alice"
        # 缺少 action
    }
}
```

### 8.2 属性测试

**基于属性的测试**:

```rego
# 属性：函数应该是纯函数
test_function_purity {
    # 相同输入应该产生相同输出
    result1 := compute_score("alice")
    result2 := compute_score("alice")
    result1 == result2
}

# 属性：函数应该是幂等的
test_function_idempotence {
    input1 := {"user": "bob"}
    result1 := process(input1)
    result2 := process(result1)
    result1 == result2
}

# 属性：类型保持
test_type_preservation {
    is_number(input.value)
    result := transform(input.value)
    is_number(result)  # 应保持类型
}
```

### 8.3 模糊测试

**生成随机测试数据**:

```python
# fuzzer.py - 生成Rego测试数据
import json
import random
import string

def generate_input():
    return {
        "user": random_string(10),
        "age": random.randint(0, 100),
        "roles": random_set(5),
        "metadata": random_object()
    }

def random_string(length):
    return ''.join(random.choices(string.ascii_letters, k=length))

def random_set(max_size):
    return list(set(random.choices(range(100), k=random.randint(1, max_size))))

def random_object():
    return {
        random_string(5): random.choice([
            random_string(10),
            random.randint(0, 1000),
            random.choice([True, False]),
            None
        ])
        for _ in range(random.randint(1, 5))
    }

# 生成测试用例
for i in range(100):
    test_input = generate_input()
    with open(f'test_cases/fuzz_{i}.json', 'w') as f:
        json.dump(test_input, f)
```

**运行模糊测试**:

```bash
# 对所有生成的测试用例运行策略
for file in test_cases/fuzz_*.json; do
    opa eval --data policy.rego --input "$file" 'data.policy.allow' || echo "Failed on $file"
done
```

---

## 9. 实战案例

### 9.1 RBAC策略

**类型安全的RBAC实现**:

```rego
package rbac

# 类型定义（注释）
# type User = string
# type Role = string
# type Resource = string
# type Action = string
# type Permission = {resource: Resource, actions: set<Action>}

# 类型验证
valid_permission_check {
    is_string(input.user)
    count(input.user) > 0
    is_string(input.resource)
    count(input.resource) > 0
    is_string(input.action)
    count(input.action) > 0
}

# 获取用户角色（类型安全）
user_roles[role] {
    valid_permission_check
    some role in data.role_assignments[input.user]
}

# 获取角色权限
role_permissions[perm] {
    some role in user_roles
    some perm in data.role_permissions[role]
}

# 检查权限
has_permission {
    some perm in role_permissions
    perm.resource == input.resource
    input.action in perm.actions
}

# 主决策
allow {
    valid_permission_check
    has_permission
}

# 测试
test_admin_can_write {
    allow with input as {
        "user": "alice",
        "resource": "/api/users",
        "action": "write"
    } with data.role_assignments as {
        "alice": ["admin"]
    } with data.role_permissions as {
        "admin": [
            {
                "resource": "/api/users",
                "actions": {"read", "write", "delete"}
            }
        ]
    }
}
```

### 9.2 数据验证策略

**类型安全的数据验证**:

```rego
package validation

# 验证用户数据
validate_user(user) = errors {
    errors := array.concat(
        check_required_fields(user),
        array.concat(
            check_field_types(user),
            check_field_constraints(user)
        )
    )
}

# 检查必需字段
check_required_fields(user) := errors {
    required := {"id", "name", "email", "age"}
    provided := {k | user[k]}
    missing := required - provided
    
    errors := [sprintf("缺少必需字段: %s", [f]) | some f in missing]
}

# 检查字段类型
check_field_types(user) := errors {
    type_checks := [
        {"field": "id", "check": is_string(user.id)},
        {"field": "name", "check": is_string(user.name)},
        {"field": "email", "check": is_string(user.email)},
        {"field": "age", "check": is_number(user.age)},
    ]
    
    errors := [
        sprintf("字段 %s 类型错误", [check.field])
        | some check in type_checks
        not check.check
    ]
}

# 检查字段约束
check_field_constraints(user) := errors {
    constraint_checks := [
        {
            "name": "id_not_empty",
            "check": count(user.id) > 0
        },
        {
            "name": "valid_email",
            "check": regex.match(`^[^@]+@[^@]+\.[^@]+$`, user.email)
        },
        {
            "name": "age_range",
            "check": user.age >= 0 and user.age < 150
        },
    ]
    
    errors := [
        sprintf("约束检查失败: %s", [check.name])
        | some check in constraint_checks
        not check.check
    ]
}

# 测试
test_valid_user {
    errors := validate_user({
        "id": "usr123",
        "name": "Alice",
        "email": "alice@example.com",
        "age": 30
    })
    count(errors) == 0
}

test_invalid_user_missing_field {
    errors := validate_user({
        "id": "usr123",
        "name": "Alice"
        # 缺少 email 和 age
    })
    count(errors) > 0
}
```

### 9.3 API授权策略

**类型安全的API网关授权**:

```rego
package api.authz

import future.keywords.if
import future.keywords.in

# 类型: HTTPRequest = {
#   method: string,
#   path: array<string>,
#   headers: object<string, string>,
#   user: string
# }

# 验证请求格式
valid_request if {
    is_string(input.method)
    is_array(input.path)
    is_object(input.headers)
    is_string(input.user)
}

# 提取JWT token（类型安全）
token := t if {
    auth_header := input.headers.Authorization
    is_string(auth_header)
    startswith(auth_header, "Bearer ")
    t := substring(auth_header, 7, -1)
}

# 解码并验证token
decoded_token := payload if {
    token
    [_, payload, _] := io.jwt.decode(token)
    is_object(payload)
}

# 检查token有效性
valid_token if {
    decoded_token
    is_number(decoded_token.exp)
    decoded_token.exp > time.now_ns() / 1000000000
}

# 路径匹配（类型安全）
path_matches(pattern, path) if {
    is_array(pattern)
    is_array(path)
    count(pattern) == count(path)
    every i, segment in pattern {
        segment == "*" or segment == path[i]
    }
}

# 主决策
allow if {
    valid_request
    valid_token
    has_permission
}

has_permission if {
    some rule in data.api_rules
    rule.method == input.method
    path_matches(rule.path, input.path)
    input.user in rule.allowed_users
}

# 测试
test_allow_with_valid_token {
    allow with input as {
        "method": "GET",
        "path": ["api", "users", "123"],
        "headers": {
            "Authorization": "Bearer eyJ..."
        },
        "user": "alice"
    } with data.api_rules as [
        {
            "method": "GET",
            "path": ["api", "users", "*"],
            "allowed_users": ["alice", "bob"]
        }
    ] with time.now_ns as 1000000000000
}
```

---

## 10. 最佳实践

### 10.1 设计原则

**SOLID for Rego**:

1. **Single Responsibility** - 每个规则只做一件事

   ```rego
   # Good
   is_admin(user) { user in data.admins }
   can_write(resource) { input.action == "write" }
   
   allow {
       is_admin(input.user)
       can_write(input.resource)
   }
   ```

2. **Open/Closed** - 易于扩展，难以修改

   ```rego
   # 定义扩展点
   permission_check {
       basic_permission_check
   }
   
   permission_check {
       advanced_permission_check
   }
   ```

3. **Type Safety** - 始终验证类型

   ```rego
   # 总是包含类型检查
   process(x) {
       is_expected_type(x)
       # 业务逻辑...
   }
   ```

### 10.2 代码组织

**模块化结构**:

```text
policies/
├── lib/
│   ├── types.rego          # 类型定义和验证
│   ├── guards.rego         # 类型卫士
│   └── utils.rego          # 工具函数
├── authz/
│   ├── rbac.rego          # RBAC逻辑
│   ├── abac.rego          # ABAC逻辑
│   └── authz_test.rego
├── validation/
│   ├── input.rego         # 输入验证
│   └── validation_test.rego
└── main.rego              # 主策略
```

**示例：types.rego**:

```rego
package lib.types

# 类型定义
User := {
    "id": String,
    "name": String,
    "email": Email,
    "age": PositiveInt,
    "roles": SetString
}

# 类型验证函数
is_valid_user(user) {
    is_string(user.id)
    is_string(user.name)
    is_valid_email(user.email)
    is_positive_int(user.age)
    is_set_string(user.roles)
}

is_valid_email(email) {
    is_string(email)
    regex.match(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`, email)
}

is_positive_int(x) {
    is_number(x)
    x > 0
    x == round(x)
}

is_set_string(s) {
    is_set(s)
    every item in s { is_string(item) }
}
```

### 10.3 持续改进

**静态分析集成**:

```yaml
# .github/workflows/opa-check.yml
name: OPA Policy Check

on: [push, pull_request]

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup OPA
        run: |
          curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64
          chmod +x opa
          sudo mv opa /usr/local/bin/
      
      - name: Setup Regal
        run: go install github.com/styrainc/regal@latest
      
      - name: Check Policies
        run: |
          opa check --strict policies/
          regal lint policies/
      
      - name: Run Tests
        run: opa test policies/ -v
```

**代码审查清单**:

- [ ] 所有函数都有类型注释
- [ ] 输入都经过类型验证
- [ ] 没有假设输入总是存在
- [ ] 使用类型安全的辅助函数
- [ ] 有完整的测试覆盖（包括类型错误情况）
- [ ] 通过静态分析工具检查
- [ ] 文档说明了类型契约

---

## 附录

### A. 类型速查表

| 类型 | 检查函数 | 示例值 |
|------|---------|--------|
| null | - | `null` |
| boolean | `is_boolean(x)` | `true`, `false` |
| number | `is_number(x)` | `42`, `3.14` |
| string | `is_string(x)` | `"hello"` |
| array | `is_array(x)` | `[1, 2, 3]` |
| object | `is_object(x)` | `{"key": "value"}` |
| set | `is_set(x)` | `{1, 2, 3}` |

### B. 错误诊断指南

**常见错误信息及解决方案**:

| 错误信息 | 原因 | 解决方案 |
|---------|------|---------|
| `undefined ref` | 引用不存在的路径 | 检查数据路径，添加存在性检查 |
| `operands must be ..` | 类型不匹配 | 添加类型检查或转换 |
| `function ... undefined` | 函数不存在 | 检查拼写，导入正确的包 |
| `too many/few args` | 参数数量错误 | 检查函数签名 |

### C. 工具配置

**VS Code设置** (`.vscode/settings.json`):

```json
{
    "opa.checkOnSave": true,
    "opa.strictMode": true,
    "opa.bundleMode": false,
    "opa.roots": ["policies/"],
    "regal.enable": true,
    "regal.configPath": ".regal.yaml"
}
```

**Regal配置** (`.regal.yaml`):

```yaml
rules:
  bugs:
    undefined-function: {level: error}
    constant-condition: {level: warning}
  style:
    prefer-snake-case: {level: warning}
    line-length: {level: warning, max-line-length: 120}
  idiomatic:
    no-defined-entrypoint: {level: ignore}
  custom:
    type-annotations: {level: warning}
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日  
**维护者**: OPA技术文档项目

**相关阅读**:

- [类型系统形式化](../06-形式化证明/06.5-类型系统形式化.md) - 理论基础
- [Rego语言规范](../02-语言模型/02.1-Rego语言规范.md) - 语法参考
- [策略测试指南](../04-策略编写/04.4-策略测试.md) - 测试方法
- [性能优化指南](../05-最佳实践/05.6-性能优化指南.md) - 性能建议
