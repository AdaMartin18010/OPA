# 类型系统形式化

> **文档类型**: 形式化类型理论  
> **理论领域**: 类型系统、类型安全性、程序验证  
> **适用读者**: 编程语言研究者、类型系统设计者、高级开发者  
> **先修知识**: [一阶逻辑](06.3-命题逻辑与一阶逻辑基础.md)、[Rego类型系统](../02-语言模型/02.2-类型系统.md)  
> **最后更新**: 2025年10月21日  
> **文档状态**: ✅ Phase 1.1 - 类型理论

---

## 📐 类型系统理论框架

> **本文档目标**:
>
> - ✅ 形式化定义Rego的类型系统
> - ✅ 证明类型系统的健全性（Soundness）
> - ✅ 证明类型安全性（Type Safety）
> - ✅ 建立类型推导的数学基础
> - ✅ 为类型检查器提供理论保证
>
> **核心定理**:
>
> - **Progress**: 良类型的表达式要么是值，要么可以继续求值
> - **Preservation**: 求值保持类型
> - **Type Safety**: 良类型的程序不会"卡住"（stuck）
>
> **实际价值**:
>
> - 静态保证类型错误不会在运行时发生
> - 为类型检查器提供正确性依据
> - 支持类型推导和类型重构
> - 优化编译器生成代码

---

## 目录

- [类型系统形式化](#类型系统形式化)
  - [📐 类型系统理论框架](#-类型系统理论框架)
  - [目录](#目录)
  - [1. 类型系统基础](#1-类型系统基础)
    - [1.1 类型的定义](#11-类型的定义)
      - [1.1.1 类型语法](#111-类型语法)
      - [1.1.2 类型的性质](#112-类型的性质)
    - [1.2 类型环境](#12-类型环境)
    - [1.3 子类型关系](#13-子类型关系)
  - [2. 类型推导规则](#2-类型推导规则)
    - [2.1 基本值类型](#21-基本值类型)
    - [2.2 复合类型](#22-复合类型)
      - [2.2.1 数组类型](#221-数组类型)
      - [2.2.2 对象类型](#222-对象类型)
      - [2.2.3 集合类型](#223-集合类型)
    - [2.3 函数类型](#23-函数类型)
    - [2.4 规则类型](#24-规则类型)
  - [3. 类型系统的健全性](#3-类型系统的健全性)
    - [3.1 Progress定理](#31-progress定理)
    - [3.2 Preservation定理](#32-preservation定理)
    - [3.3 Type Safety定理](#33-type-safety定理)
  - [4. 类型推导算法](#4-类型推导算法)
    - [4.1 Algorithm W](#41-algorithm-w)
    - [4.2 约束生成与求解](#42-约束生成与求解)
    - [4.3 主类型定理](#43-主类型定理)
  - [5. 结构类型与鸭子类型](#5-结构类型与鸭子类型)
    - [5.1 结构等价性](#51-结构等价性)
    - [5.2 与名义类型的对比](#52-与名义类型的对比)
    - [5.3 Rego的结构类型语义](#53-rego的结构类型语义)
  - [6. 多态性](#6-多态性)
    - [6.1 参数多态](#61-参数多态)
    - [6.2 类型变量实例化](#62-类型变量实例化)
    - [6.3 Let-多态](#63-let-多态)
  - [7. 与Rego的映射](#7-与rego的映射)
    - [7.1 Rego类型到形式化类型](#71-rego类型到形式化类型)
    - [7.2 类型检查实现](#72-类型检查实现)
    - [7.3 类型错误处理](#73-类型错误处理)
  - [附录](#附录)
    - [A. 类型理论术语对照](#a-类型理论术语对照)
    - [B. 重要定理速查](#b-重要定理速查)
    - [C. 参考文献](#c-参考文献)

---

## 1. 类型系统基础

### 1.1 类型的定义

#### 1.1.1 类型语法

**定义 1.1** (类型 Type)

类型的归纳定义：

```haskell
τ ::= Bool                    -- 布尔类型
    | Number                  -- 数值类型
    | String                  -- 字符串类型
    | Null                    -- 空类型
    | Array(τ)                -- 数组类型
    | Object(τ₁, τ₂)          -- 对象类型 (键→值)
    | Set(τ)                  -- 集合类型
    | τ₁ → τ₂                 -- 函数类型
    | α                       -- 类型变量
    | ∀α. τ                   -- 全称量化类型
    | ⊥                       -- 底类型 (never)
    | ⊤                       -- 顶类型 (any)
```

**Rego类型对应**:

| Rego | 形式化类型 | 示例 |
|------|-----------|------|
| `boolean` | Bool | `true`, `false` |
| `number` | Number | `42`, `3.14` |
| `string` | String | `"admin"` |
| `null` | Null | `null` |
| `array` | Array(τ) | `[1, 2, 3]` : Array(Number) |
| `object` | Object(String, τ) | `{"a": 1}` : Object(String, Number) |
| `set` | Set(τ) | `{1, 2, 3}` : Set(Number) |

#### 1.1.2 类型的性质

**定义 1.2** (类型大小)

类型 τ 的大小 |τ| 定义为：

```text
|Bool| = |Number| = |String| = |Null| = 1
|Array(τ)| = 1 + |τ|
|Object(τ₁,τ₂)| = 1 + |τ₁| + |τ₂|
|Set(τ)| = 1 + |τ|
|τ₁ → τ₂| = 1 + |τ₁| + |τ₂|
|∀α. τ| = 1 + |τ|
```

**定义 1.3** (自由类型变量)

类型 τ 中的自由类型变量 FTV(τ)：

```text
FTV(Bool) = FTV(Number) = FTV(String) = FTV(Null) = ∅
FTV(Array(τ)) = FTV(τ)
FTV(Object(τ₁,τ₂)) = FTV(τ₁) ∪ FTV(τ₂)
FTV(Set(τ)) = FTV(τ)
FTV(τ₁ → τ₂) = FTV(τ₁) ∪ FTV(τ₂)
FTV(α) = {α}
FTV(∀α. τ) = FTV(τ) \ {α}
```

### 1.2 类型环境

**定义 1.4** (类型环境 Type Environment)

类型环境 Γ 是从变量到类型的有限映射：

```text
Γ ::= ∅                       -- 空环境
    | Γ, x : τ                -- 扩展环境
```

**操作**:

```text
dom(Γ): 环境的定义域（变量集合）
Γ(x): 查找变量x的类型
Γ[x ↦ τ]: 更新/添加绑定
```

**示例**:

```text
Γ = {
  input : Object(String, ⊤),
  user : Object(String, String),
  count : Number → Number
}

Γ(user) = Object(String, String)
Γ[admin : Bool] = Γ ∪ {admin : Bool}
```

### 1.3 子类型关系

**定义 1.5** (子类型关系 <:)

子类型关系 τ <: σ 表示 τ 是 σ 的子类型。

**公理**:

```text
(S-Refl)   τ <: τ

(S-Trans)  τ <: σ    σ <: ρ
           ─────────────────
               τ <: ρ

(S-Bot)    ⊥ <: τ

(S-Top)    τ <: ⊤
```

**结构规则**:

```text
(S-Array)  τ <: σ
           ──────────────
           Array(τ) <: Array(σ)

(S-Set)    τ <: σ
           ──────────────
           Set(τ) <: Set(σ)

(S-Object) τ₁ <: σ₁    τ₂ <: σ₂
           ─────────────────────
           Object(τ₁,τ₂) <: Object(σ₁,σ₂)

(S-Fun)    σ₁ <: τ₁    τ₂ <: σ₂
           ─────────────────────  -- 逆变+协变
           τ₁ → τ₂ <: σ₁ → σ₂
```

**示例**:

```text
Array(Number) <: Array(⊤)
Set(String) <: Set(⊤)
⊥ → ⊤ <: Number → Number  -- 函数是最宽泛的
```

---

## 2. 类型推导规则

### 2.1 基本值类型

**类型判断** 的形式：

```text
Γ ⊢ e : τ

读作：在类型环境 Γ 下，表达式 e 具有类型 τ
```

**基本规则**:

```text
(T-True)   
           ─────────────
           Γ ⊢ true : Bool

(T-False)  
           ─────────────
           Γ ⊢ false : Bool

(T-Num)    
           ─────────────
           Γ ⊢ n : Number

(T-Str)    
           ─────────────
           Γ ⊢ "s" : String

(T-Null)   
           ─────────────
           Γ ⊢ null : Null

(T-Var)    x : τ ∈ Γ
           ─────────────
           Γ ⊢ x : τ
```

**示例推导**:

```text
Γ = {x : Number}

────────────────  (T-Num)
Γ ⊢ 42 : Number

────────────────  (T-Var, x∈Γ)
Γ ⊢ x : Number
```

### 2.2 复合类型

#### 2.2.1 数组类型

```text
(T-Array)  Γ ⊢ e₁ : τ    Γ ⊢ e₂ : τ    ...    Γ ⊢ eₙ : τ
           ───────────────────────────────────────────────
           Γ ⊢ [e₁, e₂, ..., eₙ] : Array(τ)

(T-ArrayEmpty)
           ─────────────────────
           Γ ⊢ [] : Array(α)     -- 多态空数组
```

**示例**:

```text
Γ ⊢ 1 : Number    Γ ⊢ 2 : Number    Γ ⊢ 3 : Number
──────────────────────────────────────────────────── (T-Array)
Γ ⊢ [1, 2, 3] : Array(Number)
```

#### 2.2.2 对象类型

```text
(T-Object) Γ ⊢ k₁ : String  ...  Γ ⊢ kₙ : String
           Γ ⊢ v₁ : τ₁      ...  Γ ⊢ vₙ : τₙ
           τ = τ₁ ⊔ τ₂ ⊔ ... ⊔ τₙ           -- 最小上界
           ──────────────────────────────────────────
           Γ ⊢ {k₁: v₁, ..., kₙ: vₙ} : Object(String, τ)

(T-ObjectEmpty)
           ─────────────────────────
           Γ ⊢ {} : Object(String, α)
```

**示例**:

```text
Γ ⊢ "name" : String    Γ ⊢ "Alice" : String
Γ ⊢ "age" : String     Γ ⊢ 30 : Number
τ = String ⊔ Number = ⊤
──────────────────────────────────────────── (T-Object)
Γ ⊢ {"name": "Alice", "age": 30} : Object(String, ⊤)
```

#### 2.2.3 集合类型

```text
(T-Set)    Γ ⊢ e₁ : τ    Γ ⊢ e₂ : τ    ...    Γ ⊢ eₙ : τ
           ───────────────────────────────────────────────
           Γ ⊢ {e₁, e₂, ..., eₙ} : Set(τ)

(T-SetEmpty)
           ─────────────────
           Γ ⊢ {} : Set(α)   -- 区别于空对象需要上下文
```

### 2.3 函数类型

**内置函数类型**:

```text
(T-BuiltinFun)
           ────────────────────────────
           Γ ⊢ count : Array(α) → Number

           ────────────────────────────────────
           Γ ⊢ concat : String → String → String

           ────────────────────────────────
           Γ ⊢ contains : String → String → Bool
```

**函数应用**:

```text
(T-App)    Γ ⊢ f : τ₁ → τ₂    Γ ⊢ e : τ₁
           ──────────────────────────────
           Γ ⊢ f(e) : τ₂
```

**示例**:

```text
Γ ⊢ count : Array(α) → Number
Γ ⊢ [1, 2, 3] : Array(Number)
Number <: α  (实例化)
─────────────────────────────────── (T-App)
Γ ⊢ count([1, 2, 3]) : Number
```

### 2.4 规则类型

**Rego规则的类型**:

```text
(T-Rule)   Γ, x₁ : τ₁, ..., xₙ : τₙ ⊢ body : Bool
           Γ ⊢ head : τ
           ────────────────────────────────────────
           Γ ⊢ (head if body) : τ

(T-RuleDefault)
           Γ ⊢ v : τ
           ─────────────────────────
           Γ ⊢ (default name = v) : τ
```

**示例**:

```rego
# allow if input.admin == true
#
# 类型推导:
#   input : Object(String, ⊤)
#   input.admin : ⊤
#   true : Bool
#   input.admin == true : Bool  (需要隐式转换)
#   allow : Bool
```

---

## 3. 类型系统的健全性

### 3.1 Progress定理

**定理 3.1** (Progress)

如果 ∅ ⊢ e : τ（封闭良类型表达式），则：

1. e 是值（value），或者
2. 存在 e' 使得 e → e'（可以求值一步）

**证明** (对类型推导归纳):

**情况1: e = v** (值)

```text
v 包括: true, false, n, "s", null, [], {}, [v₁,...,vₙ], ...
直接满足条件1  ✓
```

**情况2: e = x** (变量)

```text
Γ = ∅ (封闭)
x : τ ∈ ∅  矛盾！
不可能是封闭表达式中的自由变量
```

**情况3: e = f(e₁)**:

```text
子情况3.1: e₁ 不是值
  由归纳假设: e₁ → e₁'
  因此: f(e₁) → f(e₁')  ✓  (满足条件2)

子情况3.2: e₁ = v (值)
  f 是内置函数
  存在 δ(f, v) = v'  (delta规则)
  因此: f(v) → v'  ✓  (满足条件2)
```

**情况4: e = e₁[e₂]** (索引)

```text
类似分析
```

**结论**: 所有情况都满足Progress  ✓

### 3.2 Preservation定理

**定理 3.2** (Preservation/Subject Reduction)

如果 Γ ⊢ e : τ 且 e → e'，则 Γ ⊢ e' : τ。

**引理 3.1** (Substitution Lemma)

如果 Γ, x : σ ⊢ e : τ 且 Γ ⊢ v : σ，则 Γ ⊢ e[x ↦ v] : τ。

**证明** (对 e 的结构归纳):

**情况1: e = x**:

```text
Γ, x:σ ⊢ x : σ     (T-Var)
Γ ⊢ v : σ          (前提)
e[x↦v] = v
因此: Γ ⊢ v : σ = τ  ✓
```

**情况2: e = y** (y ≠ x)

```text
Γ, x:σ ⊢ y : τ     (y:τ ∈ Γ)
e[x↦v] = y
因此: Γ ⊢ y : τ  ✓
```

**情况3: e = f(e₁)**:

```text
Γ, x:σ ⊢ f(e₁) : τ₂
  由(T-App): Γ, x:σ ⊢ f : τ₁→τ₂
            Γ, x:σ ⊢ e₁ : τ₁

归纳假设: Γ ⊢ e₁[x↦v] : τ₁

因此: f(e₁)[x↦v] = f(e₁[x↦v])
     Γ ⊢ f : τ₁→τ₂
     Γ ⊢ e₁[x↦v] : τ₁
     ────────────────────── (T-App)
     Γ ⊢ f(e₁[x↦v]) : τ₂  ✓
```

**定理3.2证明** (对求值规则归纳):

**规则: (E-App)**:

```text
f(v) → δ(f, v)

前提: Γ ⊢ f(v) : τ
  由(T-App): Γ ⊢ f : σ→τ
            Γ ⊢ v : σ

δ(f, v) 定义良好（内置函数类型正确）
因此: Γ ⊢ δ(f, v) : τ  ✓
```

**规则: (E-Context)**:

```text
e → e'  ⟹  C[e] → C[e']

前提: Γ ⊢ C[e] : τ
归纳假设: Γ ⊢ e' : σ

由类型规则: Γ ⊢ C[e'] : τ  ✓
```

**结论**: Preservation成立  ✓

### 3.3 Type Safety定理

**定理 3.3** (Type Safety)

良类型的封闭表达式不会卡住（stuck）。

**定义 3.1** (卡住 Stuck)

表达式 e 卡住，如果：

1. e 不是值
2. 不存在 e' 使得 e → e'

**证明**:

```text
设 ∅ ⊢ e : τ (良类型封闭表达式)
假设 e 卡住

由Progress: e 是值或可以求值
由假设: e 不是值且不能求值
矛盾！

因此: 良类型表达式不会卡住  ✓
```

**推论 3.1**:

```text
如果 ∅ ⊢ e : τ，则:
  要么 e 在有限步后求值到值 v
  要么 e 无限求值（发散）
  但不会因类型错误而卡住
```

---

## 4. 类型推导算法

### 4.1 Algorithm W

**Hindley-Milner类型推导**:

```python
def infer(env, expr):
    """Algorithm W: 类型推导"""
    match expr:
        case Var(x):
            if x not in env:
                raise TypeError(f"Unbound variable: {x}")
            return instantiate(env[x])
        
        case Num(n):
            return Number
        
        case Bool(b):
            return Bool
        
        case App(f, arg):
            tf = infer(env, f)
            targ = infer(env, arg)
            tret = fresh_var()
            unify(tf, Arrow(targ, tret))
            return tret
        
        case Lambda(x, body):
            tx = fresh_var()
            tbody = infer(env.extend(x, tx), body)
            return Arrow(tx, tbody)
        
        case Let(x, e1, e2):
            t1 = infer(env, e1)
            t1_gen = generalize(env, t1)
            return infer(env.extend(x, t1_gen), e2)
```

**类型变量统一**:

```python
def unify(t1, t2):
    """统一两个类型"""
    t1 = deref(t1)
    t2 = deref(t2)
    
    if t1 == t2:
        return
    
    if isinstance(t1, TypeVar):
        if occurs(t1, t2):
            raise TypeError("Infinite type")
        bind(t1, t2)
        return
    
    if isinstance(t2, TypeVar):
        unify(t2, t1)
        return
    
    if isinstance(t1, Arrow) and isinstance(t2, Arrow):
        unify(t1.arg, t2.arg)
        unify(t1.ret, t2.ret)
        return
    
    raise TypeError(f"Cannot unify {t1} with {t2}")
```

### 4.2 约束生成与求解

**两阶段类型检查**:

**阶段1: 约束生成**:

```text
C = ∅  (约束集合)

推导 Γ ⊢ e : τ 时生成约束:
  C = C ∪ {τ₁ = τ₂}
```

**阶段2: 约束求解**:

```text
solve(C):
  for (τ₁ = τ₂) in C:
    θ = unify(τ₁, τ₂)
    C = Cθ
  return θ
```

**示例**:

```rego
# count(input.users) > 10

# 约束生成:
C₁: input : α₁
C₂: input.users : α₂
C₃: count : Array(β) → Number
C₄: α₂ = Array(β)
C₅: count(input.users) : Number
C₆: 10 : Number
C₇: Number > Number : Bool

# 约束求解:
θ = {α₂ ↦ Array(β), α₁ ↦ Object(String, Array(β)), ...}
```

### 4.3 主类型定理

**定理 4.1** (Principal Type)

如果表达式 e 可类型化，则存在主类型（principal type）τ，使得：

1. Γ ⊢ e : τ
2. 对任何 Γ ⊢ e : σ，存在替换 θ 使得 σ = τθ

**证明**: Algorithm W 计算主类型  ✓

---

## 5. 结构类型与鸭子类型

### 5.1 结构等价性

**定义 5.1** (结构等价)

两个类型结构等价，记作 τ ≅ σ，如果它们的结构相同（忽略名称）。

**Rego采用结构类型**:

```rego
# 类型由结构决定，而非名称
user1 = {"name": "Alice", "age": 30}
user2 = {"name": "Bob", "age": 25}

# user1 和 user2 具有相同的结构类型:
# Object(String, String ⊔ Number)
```

### 5.2 与名义类型的对比

| 特性 | 结构类型 | 名义类型 |
|------|---------|---------|
| 等价性 | 结构相同即等价 | 需要显式声明继承 |
| 灵活性 | 高（鸭子类型） | 低（严格层次） |
| 安全性 | 较低（易混淆） | 较高（显式类型） |
| 适用场景 | 动态语言、JSON | 静态语言、OOP |

**Rego选择结构类型的原因**:

1. JSON数据自然是结构化的
2. 策略代码需要灵活处理不同数据源
3. 不需要预定义类型层次

### 5.3 Rego的结构类型语义

**兼容性判断**:

```text
Object(k₁, v₁) 兼容 Object(k₂, v₂) ⟺
  ∀key. (key ∈ dom(v₁) ⟹ 
         key ∈ dom(v₂) ∧ v₁(key) 兼容 v₂(key))
```

**示例**:

```rego
# 允许额外字段
input = {"name": "Alice", "age": 30, "email": "alice@example.com"}

# 只需要部分字段即可匹配
user = input
user.name == "Alice"  # ✓
```

---

## 6. 多态性

### 6.1 参数多态

**定义 6.1** (多态类型)

```text
∀α. τ  表示对所有类型 α，类型 τ 成立
```

**示例**:

```text
identity : ∀α. α → α
identity(x) = x

count : ∀α. Array(α) → Number
```

### 6.2 类型变量实例化

**规则**:

```text
(T-Inst)   Γ ⊢ e : ∀α. τ
           ────────────────
           Γ ⊢ e : τ[α ↦ σ]  (任意类型 σ)
```

**示例**:

```text
count : ∀α. Array(α) → Number

count : Array(Number) → Number  (α ↦ Number)
count : Array(String) → Number  (α ↦ String)
```

### 6.3 Let-多态

**规则**:

```text
(T-Let)    Γ ⊢ e₁ : τ₁
           α = FTV(τ₁) \ FTV(Γ)
           Γ, x : ∀α. τ₁ ⊢ e₂ : τ₂
           ─────────────────────────
           Γ ⊢ let x = e₁ in e₂ : τ₂
```

**Rego不支持显式let，但规则绑定类似**:

```rego
# 规则绑定是多态的
nums = [1, 2, 3]    # ∀α. Array(α), 实例化为 Array(Number)
```

---

## 7. 与Rego的映射

### 7.1 Rego类型到形式化类型

**映射表**:

| Rego运行时类型 | 形式化类型 | 类型判断 |
|---------------|-----------|---------|
| `boolean` | Bool | `Γ ⊢ true : Bool` |
| `number` | Number | `Γ ⊢ 42 : Number` |
| `string` | String | `Γ ⊢ "a" : String` |
| `null` | Null | `Γ ⊢ null : Null` |
| `array` | Array(τ) | `Γ ⊢ [e₁,...,eₙ] : Array(τ)` |
| `object` | Object(String, τ) | `Γ ⊢ {k:v,...} : Object(String,τ)` |
| `set` | Set(τ) | `Γ ⊢ {e₁,...,eₙ} : Set(τ)` |

### 7.2 类型检查实现

**伪代码**:

```go
func TypeCheck(expr Expr, env TypeEnv) (Type, error) {
    switch e := expr.(type) {
    case *BoolLit:
        return BoolType, nil
    
    case *NumLit:
        return NumberType, nil
    
    case *StrLit:
        return StringType, nil
    
    case *ArrayLit:
        elemTypes := []Type{}
        for _, elem := range e.Elements {
            t, err := TypeCheck(elem, env)
            if err != nil {
                return nil, err
            }
            elemTypes = append(elemTypes, t)
        }
        unified := UnifyAll(elemTypes)
        return ArrayType{Elem: unified}, nil
    
    case *FuncCall:
        fType, err := TypeCheck(e.Func, env)
        if err != nil {
            return nil, err
        }
        argType, err := TypeCheck(e.Arg, env)
        if err != nil {
            return nil, err
        }
        
        arrow, ok := fType.(*ArrowType)
        if !ok {
            return nil, TypeError("Not a function")
        }
        
        if !Compatible(argType, arrow.Arg) {
            return nil, TypeError("Type mismatch")
        }
        
        return arrow.Ret, nil
    
    // ... 其他情况
    }
}
```

### 7.3 类型错误处理

**常见类型错误**:

```rego
# 错误1: 类型不匹配
x = "hello"
y = x + 10  # 错误: String + Number

# 错误2: 字段不存在
user = {"name": "Alice"}
age = user.age  # 警告/错误: 字段不存在

# 错误3: 数组越界
arr = [1, 2, 3]
x = arr[10]  # 运行时错误（静态检查难以发现）

# 错误4: 类型不一致
arr = [1, "two", 3]  # 类型: Array(Number ⊔ String)
sum = count(arr)     # ✓ 但可能不是期望的
```

**类型错误消息**:

```text
TypeError: 
  Expression: x + 10
  Expected: Number
  Got: String
  Location: line 2, column 5
  
Suggestion: 
  Use to_number(x) to convert String to Number
```

---

## 附录

### A. 类型理论术语对照

| 英文 | 中文 | 说明 |
|------|------|------|
| Soundness | 健全性 | 类型系统不接受错误程序 |
| Completeness | 完备性 | 类型系统接受所有正确程序 |
| Progress | 进展性 | 良类型表达式可继续求值 |
| Preservation | 保持性 | 求值保持类型 |
| Principal Type | 主类型 | 最一般的类型 |
| Subtyping | 子类型 | 类型层次关系 |

### B. 重要定理速查

1. **Progress**: 良类型表达式不会卡住
2. **Preservation**: 求值保持类型
3. **Type Safety**: Progress + Preservation
4. **Principal Type**: 存在最一般类型
5. **Substitution Lemma**: 替换保持类型

### C. 参考文献

1. **Pierce, B.C.** "Types and Programming Languages" (2002)
   - 类型系统理论圣经
2. **Cardelli, L.** "Type Systems" (1996)
   - 类型系统综述
3. **Milner, R.** "A Theory of Type Polymorphism in Programming" (1978)
   - Hindley-Milner类型系统
4. **Wright, A.K., Felleisen, M.** "A Syntactic Approach to Type Soundness" (1994)
   - Progress + Preservation证明技术
5. **Rego语言规范** - <https://www.openpolicyagent.org/docs/latest/policy-language/>

---

**文档版本**: v1.0  
**最后更新**: 2025年10月21日  
**维护者**: OPA技术文档项目  
**反馈**: 欢迎通过GitHub Issues提供建议

**下一步阅读**:

- [部分求值理论](06.6-部分求值理论.md) - 特化与优化的理论基础
- [Rego类型系统](../02-语言模型/02.2-类型系统.md) - 实用类型系统指南
- [类型系统实现](../03-实现架构/03.3-编译器设计.md) - 类型检查器实现
