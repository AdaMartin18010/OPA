# 求值算法正确性证明

> **文档类型**: 形式化证明  
> **理论领域**: 算法正确性、程序验证  
> **适用读者**: 研究人员、编译器开发者、理论学者  
> **先修知识**: [命题逻辑与一阶逻辑](06.3-命题逻辑与一阶逻辑基础.md)、[Datalog理论](06.1-Datalog理论基础.md)  
> **最后更新**: 2025年10月21日  
> **文档状态**: ✅ Phase 1.1 - 算法正确性

---

## 📐 证明框架说明

> **本文档目标**:
>
> - ✅ 证明OPA/Rego求值算法的正确性
> - ✅ 形式化定义求值语义
> - ✅ 证明SLD-Resolution的可靠性和完备性
> - ✅ 分析统一算法的正确性
> - ✅ 研究终止性和复杂度
>
> **理论保证**:
>
> - 求值结果与逻辑语义一致
> - 算法不会产生错误结果
> - 所有正确答案都能被找到
> - 算法在有限步内终止（特定条件下）
>
> **实际价值**:
>
> - 信任OPA的决策结果
> - 理解求值行为
> - 优化求值性能
> - 扩展求值能力

---

## 目录

- [求值算法正确性证明](#求值算法正确性证明)
  - [📐 证明框架说明](#-证明框架说明)
  - [目录](#目录)
  - [1. 求值语义形式化](#1-求值语义形式化)
    - [1.1 操作语义](#11-操作语义)
      - [1.1.1 求值状态](#111-求值状态)
      - [1.1.2 求值规则](#112-求值规则)
      - [1.1.3 完整求值序列](#113-完整求值序列)
    - [1.2 指称语义](#12-指称语义)
      - [1.2.1 最小模型语义](#121-最小模型语义)
      - [1.2.2 指称定义](#122-指称定义)
    - [1.3 语义等价性](#13-语义等价性)
  - [2. SLD-Resolution正确性](#2-sld-resolution正确性)
    - [2.1 可靠性证明](#21-可靠性证明)
    - [2.2 完备性证明](#22-完备性证明)
    - [2.3 答案替换正确性](#23-答案替换正确性)
  - [3. 统一算法正确性](#3-统一算法正确性)
    - [3.1 Robinson算法](#31-robinson算法)
    - [3.2 MGU性质证明](#32-mgu性质证明)
    - [3.3 Occur-Check必要性](#33-occur-check必要性)
    - [3.4 复杂度分析](#34-复杂度分析)
  - [4. 回溯机制完备性](#4-回溯机制完备性)
    - [4.1 搜索空间定义](#41-搜索空间定义)
    - [4.2 完备性证明](#42-完备性证明)
    - [4.3 公平性分析](#43-公平性分析)
  - [5. 终止性分析](#5-终止性分析)
    - [5.1 终止条件](#51-终止条件)
    - [5.2 非终止情况](#52-非终止情况)
    - [5.3 终止性检测](#53-终止性检测)
  - [6. 复杂度理论](#6-复杂度理论)
    - [6.1 时间复杂度](#61-时间复杂度)
    - [6.2 空间复杂度](#62-空间复杂度)
    - [6.3 数据复杂度与程序复杂度](#63-数据复杂度与程序复杂度)
  - [7. OPA求值器验证](#7-opa求值器验证)
    - [7.1 Top-Down求值器](#71-top-down求值器)
    - [7.2 与SLD-Resolution对应关系](#72-与sld-resolution对应关系)
    - [7.3 实现正确性](#73-实现正确性)
  - [附录](#附录)
    - [A. 证明技术总结](#a-证明技术总结)
    - [B. 重要定理速查](#b-重要定理速查)
    - [C. 参考文献](#c-参考文献)

---

## 1. 求值语义形式化

### 1.1 操作语义

#### 1.1.1 求值状态

**定义 1.1** (求值状态)

求值状态是一个三元组：

```text
State = (G, θ, S)

其中:
- G: 当前目标（原子列表） G = [A₁, A₂, ..., Aₙ]
- θ: 当前替换（答案累积）
- S: 选择点栈（回溯信息）
```

**初始状态**:

```text
State₀ = ([Q], ε, [])

Q: 查询目标
ε: 空替换
[]: 空栈
```

**成功状态**:

```text
([], θ, S)  -- 目标为空，θ是答案
```

**失败状态**:

```text
(⊥, _, _)  -- 无法继续
```

#### 1.1.2 求值规则

**规则1: 统一成功**:

```text
前提:
  当前状态: ([A|G], θ, S)
  选择规则: H ← B₁,...,Bₘ  (重命名变量)
  MGU: σ = mgu(A, H)
  
后继状态:
  ([B₁,...,Bₘ|G]σ, θσ, S)
```

**规则2: 统一失败（回溯）**:

```text
前提:
  当前状态: ([A|G], θ, S)
  无规则可统一
  栈非空: S = [s|S']
  
后继状态:
  从栈顶s恢复状态
```

**规则3: 成功**:

```text
前提:
  当前状态: ([], θ, S)
  
输出: θ (答案替换)
选择: 继续（回溯找下一个答案）或停止
```

**规则4: 彻底失败**:

```text
前提:
  当前状态: ([A|G], θ, [])
  无规则可统一
  栈为空
  
后继状态: 失败 ⊥
```

#### 1.1.3 完整求值序列

**定义 1.2** (求值序列)

从初始状态到最终状态的序列：

```text
State₀ ⟶ State₁ ⟶ ... ⟶ Stateₙ

其中 Stateᵢ ⟶ Stateᵢ₊₁ 通过求值规则推导
```

**示例**:

```text
程序:
  P₁: p(a)
  P₂: p(X) ← q(X)
  P₃: q(b)

查询: ← p(X)

求值序列:

S₀ = ([p(X)], ε, [])

S₁ = ([], {X↦a}, [选择点₂])         -- 使用P₁
     输出答案1: X=a
     回溯...

S₂ = ([q(X)], ε, [])                 -- 使用P₂

S₃ = ([], {X↦b}, [])                 -- 使用P₃
     输出答案2: X=b
     
结束: 两个答案 {X↦a} 和 {X↦b}
```

### 1.2 指称语义

#### 1.2.1 最小模型语义

**定义 1.3** (立即后果算子 T_P)

给定程序 P，定义算子 T_P : 2^B → 2^B：

```text
T_P(I) = { Hθ | (H ← B₁,...,Bₙ) ∈ P,
                θ 是替换,
                B₁θ,...,Bₙθ ∈ I }
```

其中 B 是Herbrand基（所有可能的基原子）。

**性质**:

```text
1. 单调性: I ⊆ J ⟹ T_P(I) ⊆ T_P(J)
2. 连续性: T_P(⋃ᵢ Iᵢ) = ⋃ᵢ T_P(Iᵢ)
```

**定理 1.1** (不动点定理)

T_P 的最小不动点是P的最小Herbrand模型：

```text
M_P = lfp(T_P) = ⋃ₙ T_P^n(∅)

其中 T_P^0(∅) = ∅
     T_P^(n+1)(∅) = T_P(T_P^n(∅))
```

**证明**:

```text
(1) T_P单调 ⟹ 序列单调递增:
    ∅ ⊆ T_P(∅) ⊆ T_P²(∅) ⊆ ...

(2) 存在k使得 T_P^k(∅) = T_P^(k+1)(∅)
    (Herbrand基有限 ⟹ 必达不动点)

(3) M = T_P^k(∅) 是最小模型:
    - M 是模型: T_P(M) = M
    - M 最小: 对任何模型N, M ⊆ N
      证明: 对n归纳
        n=0: ∅ ⊆ N  ✓
        n+1: T_P^(n+1)(∅) ⊆ T_P(N) ⊆ N
             (归纳假设 + T_P单调 + N是模型)
```

#### 1.2.2 指称定义

**定义 1.4** (查询的指称)

```text
⟦Q⟧_P = { θ | M_P ⊨ Qθ }

即: Q 的所有答案替换集合
```

### 1.3 语义等价性

**定理 1.2** (操作语义与指称语义等价)

```text
求值产生答案θ ⟺ M_P ⊨ Qθ
```

即：操作语义计算的答案集合 = 指称语义定义的答案集合

---

## 2. SLD-Resolution正确性

### 2.1 可靠性证明

**定理 2.1** (SLD-Resolution可靠性)

如果存在从目标 G 到空目标 □ 的SLD推导，且计算的答案替换是 θ，则：

```text
M_P ⊨ Gθ
```

**证明**（对推导长度n归纳）:

**基础情况** (n=0):

```text
G = □ (空目标)
θ = ε (空替换)
M_P ⊨ □  -- 平凡真  ✓
```

**归纳情况** (n=k+1):

```text
推导:
  G₀ = ← A₁, A₂, ..., Aₘ
  使用规则 H ← B₁,...,Bₙ
  MGU: σ = mgu(A₁, H)
  G₁ = ← (B₁,...,Bₙ, A₂,...,Aₘ)σ
  ...继续推导k步...
  Gₖ = □
  计算的答案: θ = σθ'

归纳假设: M_P ⊨ G₁θ'
要证明: M_P ⊨ G₀θ

证明:
  (1) M_P ⊨ G₁θ' 
      ⟹ M_P ⊨ (B₁,...,Bₙ, A₂,...,Aₘ)σθ'
  
  (2) (H ← B₁,...,Bₙ) ∈ P 且 M_P是最小模型
      M_P ⊨ (B₁,...,Bₙ)σθ'
      ⟹ M_P ⊨ Hσθ'
  
  (3) σ = mgu(A₁, H)
      ⟹ A₁σ = Hσ
      ⟹ M_P ⊨ A₁σθ'
  
  (4) 综合(1)(3):
      M_P ⊨ (A₁, A₂,...,Aₘ)σθ'
      即 M_P ⊨ G₀θ  ✓
```

### 2.2 完备性证明

**定理 2.2** (SLD-Resolution完备性)

如果 M_P ⊨ Qθ，则存在从 ← Q 到 □ 的SLD推导，计算出答案替换 σ，使得 θ 是 σ 的实例。

**证明思路**:

```text
使用反证法和不动点构造：

(1) 假设 M_P ⊨ Qθ 但无SLD推导
(2) 考察 M_P = ⋃ₙ T_P^n(∅)
(3) 存在k使得 Qθ 首次出现在 T_P^k(∅)
(4) 根据 T_P 定义，必存在规则匹配
(5) 该匹配对应SLD步骤
(6) 递归应用于子目标
(7) 矛盾！
```

**形式化证明**（对 T_P^n 层级归纳）:

**基础** (n=0):

```text
T_P^0(∅) = ∅
不存在 Qθ ∈ ∅，定理平凡成立
```

**归纳** (n=k+1):

```text
假设: 对所有在 T_P^k(∅) 中的原子，定理成立
要证: 对 T_P^(k+1)(∅) 中的原子，定理成立

设 A ∈ T_P^(k+1)(∅)，则存在规则:
  H ← B₁,...,Bₘ ∈ P
  替换 σ
  B₁σ,...,Bₘσ ∈ T_P^k(∅)
  A = Hσ

若 M_P ⊨ Aθ = Hσθ:
  
  (1) ← A 的SLD推导:
      选择规则 H ← B₁,...,Bₘ (重命名)
      计算 τ = mgu(A, H)
      目标变为 ← (B₁,...,Bₘ)τ
  
  (2) 由归纳假设:
      每个 Bᵢτ 都有SLD推导
  
  (3) 组合推导得到 ← A 到 □ 的完整推导  ✓
```

### 2.3 答案替换正确性

**引理 2.1** (答案替换组合)

如果:

- 从 ← A 推导出答案 θ₁
- 从 ← Aθ₁ 推导出答案 θ₂

则从 ← A 推导出答案 θ₁θ₂。

**定理 2.3** (答案的最一般性)

SLD-Resolution计算的答案替换是最一般的（模变量重命名）。

---

## 3. 统一算法正确性

### 3.1 Robinson算法

**算法定义**:

```python
def unify(s, t, theta={}):
    """Robinson统一算法"""
    # 应用当前替换
    s = apply(s, theta)
    t = apply(t, theta)
    
    # 情况1: 相同
    if s == t:
        return theta
    
    # 情况2: s是变量
    if is_var(s):
        if occurs(s, t):      # Occur-check
            return None
        return extend(theta, s, t)
    
    # 情况3: t是变量
    if is_var(t):
        return unify(t, s, theta)
    
    # 情况4: 复合项
    if s.func != t.func or len(s.args) != len(t.args):
        return None
    
    # 递归统一参数
    for s_i, t_i in zip(s.args, t.args):
        theta = unify(s_i, t_i, theta)
        if theta is None:
            return None
    
    return theta
```

### 3.2 MGU性质证明

**定理 3.1** (MGU存在性与唯一性)

如果项 s 和 t 可统一，则存在唯一的（模变量重命名）MGU θ。

**证明**（对项结构归纳）:

**基础情况**:

```text
(1) s = t: MGU = ε (空替换)

(2) s = x (变量), t 任意:
    - 若 x ∈ vars(t): 不可统一
    - 否则: MGU = {x ↦ t}
```

**归纳情况**:

```text
s = f(s₁,...,sₙ), t = g(t₁,...,tₘ)

(1) 若 f ≠ g 或 n ≠ m: 不可统一

(2) 若 f = g 且 n = m:
    归纳假设: 每对 (sᵢ,tᵢ) 有MGU θᵢ
    
    构造 θ = θ₁θ₂...θₙ (组合)
    
    证明 θ 是MGU:
    a) θ 是统一子:
       sθ = f(s₁θ,...,sₙθ)
          = f(t₁θ,...,tₙθ)     (每个 sᵢθ=tᵢθ)
          = tθ  ✓
    
    b) θ 最一般:
       设 σ 是任意统一子
       则对每个i: sᵢσ = tᵢσ
       由归纳假设: σ = θᵢρᵢ (某个ρᵢ)
       ⟹ σ = θρ (某个ρ)  ✓
```

**定理 3.2** (MGU唯一性)

模变量重命名，MGU唯一。

**证明**:

```text
设 θ₁, θ₂ 都是s和t的MGU

则:
  θ₁ = θ₂ρ₁  (某个ρ₁)
  θ₂ = θ₁ρ₂  (某个ρ₂)

因此:
  θ₁ = θ₁ρ₂ρ₁

这意味着 θ₁ 和 θ₁ρ₂ρ₁ 只相差变量重命名  ✓
```

### 3.3 Occur-Check必要性

**定理 3.3** (Occur-Check必要性)

如果省略occur-check，统一算法可能产生循环结构。

**反例**:

```text
s = x
t = f(x)

不做occur-check:
  返回 θ = {x ↦ f(x)}

应用替换:
  xθ = f(x)
  xθθ = f(xθ) = f(f(x))
  xθθθ = f(f(f(x)))
  ...无限展开！

违反项的有限性！
```

**定理 3.4** (Occur-Check充分性)

如果 x ∉ vars(t)，则 {x ↦ t} 是良构替换。

### 3.4 复杂度分析

**定理 3.5** (统一算法复杂度)

Robinson统一算法的时间复杂度:

```text
- 最坏情况: O(n²)  (n = max(|s|, |t|))
- 平均情况: O(n log n)

其中 |t| 表示项t的大小（节点数）
```

**优化算法**:

```text
Paterson-Wegman算法: O(n log n)
近线性算法: O(n α(n))  (α是Ackermann逆)
```

---

## 4. 回溯机制完备性

### 4.1 搜索空间定义

**定义 4.1** (SLD搜索树)

给定程序P和查询Q，SLD搜索树T定义为：

```text
- 根节点: ← Q
- 子节点: 通过SLD步骤生成
- 叶节点: □ (成功) 或 fail (失败)
- 边标签: 使用的规则和MGU
```

**示例**:

```text
程序:
  p(a)
  p(b)
  q(X) ← p(X)

查询: ← q(Y)

搜索树:
                    ← q(Y)
                   /       \
      (规则3)     /         \  (无其他规则)
                /           \
            ← p(Y)           fail
           /      \
(规则1)   /        \  (规则2)
         /          \
      Y=a □        Y=b □

答案: Y=a, Y=b
```

### 4.2 完备性证明

**定理 4.1** (回溯完备性)

深度优先搜索策略（带回溯）能找到SLD树中的所有成功叶节点。

**证明**:

```text
DFS遍历保证:
1. 访问所有节点（深度优先 + 回溯）
2. 不遗漏任何分支
3. 找到所有 □ 叶节点

形式化:
设 Leaves(T) = SLD树T的所有成功叶
设 DFS(T) = DFS找到的成功叶集合

要证: DFS(T) = Leaves(T)

证明（对树结构归纳）:

基础: T = 单节点
  若节点 = □: DFS(T) = {□} = Leaves(T)  ✓
  若节点 = fail: DFS(T) = ∅ = Leaves(T)  ✓

归纳: T = 根 + 子树 T₁,...,Tₙ
  DFS(T) = DFS(T₁) ∪ ... ∪ DFS(Tₙ)
         = Leaves(T₁) ∪ ... ∪ Leaves(Tₙ)  (归纳假设)
         = Leaves(T)  ✓
```

### 4.3 公平性分析

**定义 4.2** (公平性)

搜索策略是公平的，如果每个可达节点最终都会被访问。

**定理 4.2** (DFS + 回溯不公平)

深度优先搜索在无限分支时不公平。

**反例**:

```text
程序:
  p(0)
  p(s(X)) ← p(X)    -- 无限生成

查询: ← p(X)

搜索树:
  ← p(X)
  ├─ X=0 □        -- 从不到达！
  └─ ← p(X')
     ├─ X'=0, X=s(0) □
     └─ ← p(X'')
        └─ ...无限深入

DFS永远在右分支，左分支的答案X=0永远不会返回
```

**解决方案**:

- 迭代加深搜索（Iterative Deepening）
- 宽度优先搜索（BFS）
- 有界深度搜索

---

## 5. 终止性分析

### 5.1 终止条件

**定义 5.1** (终止)

程序P和查询Q的求值终止，如果SLD推导在有限步后停止。

**定理 5.1** (Datalog终止性)

纯Datalog程序（无函数符号）总是终止。

**证明**:

```text
Herbrand基 H_P 有限 (无函数符号)

SLD推导中:
- 每步生成的原子 ∈ H_P
- 重复原子会被检测（或被剪枝）
- 最多 |H_P| 步后必终止  ✓

时间复杂度: O(|P| · |H_P|^k)
  k = 最大规则体长度
```

### 5.2 非终止情况

**示例1: 左递归**:

```prolog
p(X) ← p(Y), q(Y, X)  -- 危险！
q(1, 2)

查询: ← p(X)

推导:
  ← p(X)
  ← p(Y₁), q(Y₁, X)
  ← p(Y₂), q(Y₂, Y₁), q(Y₁, X)
  ...无限展开
```

**示例2: 无限数据结构**:

```prolog
infinite(s(X)) ← infinite(X)

查询: ← infinite(Y)

推导:
  ← infinite(Y)
  ← infinite(X₁)          Y = s(X₁)
  ← infinite(X₂)          X₁ = s(X₂)
  ...永不终止
```

### 5.3 终止性检测

**定理 5.2** (终止性不可判定)

一般逻辑程序的终止性是不可判定的。

**证明**: 归约到停机问题。

**实用方法**:

1. **静态分析**:
   - 检测左递归
   - 分析规则依赖图
   - 查找无基础情况的递归

2. **运行时限制**:
   - 最大推导深度
   - 超时机制
   - 资源限制

3. **OPA策略**:

   ```rego
   # 设置最大深度
   max_depth = 1000
   ```

---

## 6. 复杂度理论

### 6.1 时间复杂度

**定理 6.1** (Datalog查询复杂度)

Datalog查询求值的时间复杂度：

```text
数据复杂度: O(|D|^k)  
  k = 规则体中最大变量数
  D = 数据库大小

程序复杂度: EXPTIME-complete

组合复杂度: EXPTIME
```

**证明概要**:

```text
(1) 数据复杂度 O(|D|^k):
    - 每个规则最多 k 个变量
    - 每个变量有 |D| 个可能值
    - 穷举所有组合: |D|^k
    - 规则数量固定: O(|D|^k)

(2) 程序复杂度 EXPTIME:
    - 考虑 |P| (程序大小)
    - 最坏情况需要指数时间
```

**实例**:

```text
规则: ancestor(X, Y) ← parent(X, Z), ancestor(Z, Y)

数据: n 个 parent 事实

时间: O(n³)  (三个变量 X, Z, Y)
```

### 6.2 空间复杂度

**定理 6.2** (空间复杂度)

```text
Datalog求值空间复杂度: O(|D|^k)

存储:
- 中间结果
- 推导的新事实
- 回溯栈
```

### 6.3 数据复杂度与程序复杂度

**定义 6.1**:

```text
数据复杂度: 固定程序P，度量关于数据D的复杂度
程序复杂度: 固定数据D，度量关于程序P的复杂度
组合复杂度: 同时考虑P和D
```

**分类**:

| 程序类型 | 数据复杂度 | 程序复杂度 |
|---------|-----------|-----------|
| 非递归Datalog | PTIME | PTIME |
| 递归Datalog | PTIME | EXPTIME |
| 一般逻辑程序 | PTIME | Undecidable |

---

## 7. OPA求值器验证

### 7.1 Top-Down求值器

**OPA求值器伪代码**:

```go
func Eval(query Query, program Program) []Subst {
    stack := []Goal{query}
    answers := []Subst{}
    
    for len(stack) > 0 {
        goal := stack.pop()
        
        if goal.isEmpty() {
            // 成功：记录答案
            answers.append(goal.subst)
            continue  // 回溯找下一个
        }
        
        atom := goal.selectAtom()
        
        // 尝试所有匹配规则
        for rule := range program.rules {
            if theta := unify(atom, rule.head); theta != nil {
                newGoal := goal.extend(rule.body).apply(theta)
                stack.push(newGoal)
            }
        }
    }
    
    return answers
}
```

### 7.2 与SLD-Resolution对应关系

**对应表**:

| OPA概念 | SLD概念 | 说明 |
|---------|---------|------|
| `Eval()` | SLD推导 | 顶层求值 |
| `Goal` | 目标 ← A₁,...,Aₙ | 待证明的原子列表 |
| `Subst` | 替换 θ | 变量绑定 |
| `unify()` | mgu() | 统一算法 |
| `stack.push()` | 选择点 | 回溯栈 |
| `stack.pop()` | 回溯 | 恢复状态 |

**正确性声明**:

```text
Eval(Q, P) 返回的答案集合 = SLD-Resolution计算的答案集合
```

### 7.3 实现正确性

**定理 7.1** (OPA求值器正确性)

OPA的Top-Down求值器实现了SLD-Resolution语义。

**证明概要**:

```text
(1) Eval的每次迭代对应一个SLD步骤
(2) 统一算法实现正确（前述证明）
(3) 回溯机制完备（DFS遍历搜索树）
(4) 答案累积正确（替换组合）

因此: Eval实现 = SLD-Resolution  ✓
```

**测试验证**:

```rego
# 测试用例
test_eval_correctness {
    # 程序
    data.rules = [
        {"head": "p(a)", "body": []},
        {"head": "p(X)", "body": ["q(X)"]},
        {"head": "q(b)", "body": []}
    ]
    
    # 查询
    query = "p(X)"
    
    # 期望答案
    expected = [{"X": "a"}, {"X": "b"}]
    
    # 验证
    eval(query) == expected
}
```

---

## 附录

### A. 证明技术总结

1. **结构归纳**: 对项、公式、推导的结构归纳
2. **数学归纳**: 对推导长度、迭代次数归纳
3. **不动点理论**: 最小模型的构造性定义
4. **归约**: 证明复杂度和不可判定性

### B. 重要定理速查

| 定理 | 内容 | 意义 |
|-----|------|------|
| SLD可靠性 | 推导的答案语义正确 | 信任结果 |
| SLD完备性 | 所有答案都能找到 | 不遗漏 |
| MGU唯一性 | 最一般统一子唯一 | 算法确定 |
| Datalog终止 | 无函数符号必终止 | 性能保证 |
| 复杂度 | O(\|D\|^k) 数据复杂度 | 性能预期 |

### C. 参考文献

1. **Lloyd, J.W.** "Foundations of Logic Programming" (1987)
   - SLD-Resolution理论的权威教材
2. **Apt, K.R.** "Logic Programming" (1990)
   - 操作语义和指称语义
3. **Robinson, J.A.** "A Machine-Oriented Logic Based on the Resolution Principle" (1965)
   - 统一算法原始论文
4. **Paterson, M.S., Wegman, M.N.** "Linear Unification" (1978)
   - 线性统一算法
5. **Ullman, J.D.** "Principles of Database and Knowledge-Base Systems" (1988)
   - Datalog复杂度理论

---

**文档版本**: v1.0  
**最后更新**: 2025年10月21日  
**维护者**: OPA技术文档项目  
**反馈**: 欢迎通过GitHub Issues提供建议

**相关阅读**:

- [命题逻辑与一阶逻辑基础](06.3-命题逻辑与一阶逻辑基础.md) - 理论基础
- [类型系统形式化](06.5-类型系统形式化.md) - 类型安全性证明
- [Top-Down求值器](../03-实现架构/03.4-Top-Down求值器.md) - 实现细节
