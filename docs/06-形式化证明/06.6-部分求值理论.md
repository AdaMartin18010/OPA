# 部分求值理论

> **文档类型**: 形式化优化理论  
> **理论领域**: 程序特化、编译器优化、性能理论  
> **适用读者**: 编译器开发者、优化专家、理论研究者  
> **先修知识**: [一阶逻辑](06.3-命题逻辑与一阶逻辑基础.md)、[求值算法](06.4-求值算法正确性证明.md)  
> **最后更新**: 2025年10月21日  
> **文档状态**: ✅ Phase 1.2 - 优化理论

---

## 📐 部分求值理论框架

> **本文档目标**:
>
> - ✅ 建立部分求值的数学基础
> - ✅ 证明特化程序的正确性
> - ✅ 分析Futamura投影理论
> - ✅ 研究绑定时间分析
> - ✅ 应用于OPA策略优化
>
> **核心概念**:
>
> - **部分求值**: 在编译时求值部分已知输入
> - **特化**: 生成针对特定输入的优化程序
> - **Futamura投影**: 解释器→编译器的理论基础
> - **绑定时间**: 区分静态/动态数据
>
> **实际价值**:
>
> - 策略预编译优化（Policy → WASM）
> - 运行时性能提升（消除冗余计算）
> - 数据驱动优化（固定input部分）
> - 自动程序特化

---

## 目录

- [部分求值理论](#部分求值理论)
  - [📐 部分求值理论框架](#-部分求值理论框架)
  - [目录](#目录)
  - [1. 部分求值基础](#1-部分求值基础)
    - [1.1 动机与示例](#11-动机与示例)
      - [1.1.1 问题背景](#111-问题背景)
      - [1.1.2 性能收益](#112-性能收益)
    - [1.2 形式化定义](#12-形式化定义)
    - [1.3 在线vs离线求值](#13-在线vs离线求值)
      - [1.3.1 在线部分求值](#131-在线部分求值)
      - [1.3.2 离线部分求值](#132-离线部分求值)
  - [2. 绑定时间分析](#2-绑定时间分析)
    - [2.1 BTA定义](#21-bta定义)
    - [2.2 绑定时间类型](#22-绑定时间类型)
    - [2.3 分析算法](#23-分析算法)
  - [3. 特化算法](#3-特化算法)
    - [3.1 符号执行](#31-符号执行)
    - [3.2 残余程序生成](#32-残余程序生成)
    - [3.3 展开与记忆化](#33-展开与记忆化)
  - [4. 正确性证明](#4-正确性证明)
    - [4.1 语义保持定理](#41-语义保持定理)
    - [4.2 终止性保证](#42-终止性保证)
    - [4.3 效率分析](#43-效率分析)
  - [5. Futamura投影](#5-futamura投影)
    - [5.1 第一Futamura投影](#51-第一futamura投影)
    - [5.2 第二Futamura投影](#52-第二futamura投影)
    - [5.3 第三Futamura投影](#53-第三futamura投影)
  - [6. OPA中的部分求值](#6-opa中的部分求值)
    - [6.1 策略预编译](#61-策略预编译)
    - [6.2 WASM编译](#62-wasm编译)
    - [6.3 性能提升实例](#63-性能提升实例)
  - [7. 高级主题](#7-高级主题)
    - [7.1 多层部分求值](#71-多层部分求值)
    - [7.2 增量特化](#72-增量特化)
    - [7.3 自适应优化](#73-自适应优化)
  - [附录](#附录)
    - [A. 术语对照](#a-术语对照)
    - [B. 核心定理速查](#b-核心定理速查)
    - [C. OPA应用总结](#c-opa应用总结)
    - [D. 参考文献](#d-参考文献)

---

## 1. 部分求值基础

### 1.1 动机与示例

#### 1.1.1 问题背景

**场景**: 程序P有两个输入S（静态）和D（动态）

```text
P(S, D) → Result
```

如果S在编译时已知，能否生成优化的程序P_S，使得：

```text
P_S(D) = P(S, D)  且 P_S(D) 更快
```

**示例1: 幂函数**

```python
# 原始程序
def power(base, exp):
    if exp == 0:
        return 1
    else:
        return base * power(base, exp - 1)

# 部分求值: exp = 3 (静态已知)
def power_3(base):
    return base * base * base  # 展开递归
```

**示例2: Rego策略**

```rego
# 原始策略
allow if {
    some role in input.user.roles
    role in data.admin_roles
}

# 部分求值: data.admin_roles = {"admin", "superuser"} (静态)
allow_specialized if {
    some role in input.user.roles
    role in {"admin", "superuser"}  # 内联data
}
```

#### 1.1.2 性能收益

| 优化类型 | 示例 | 收益 |
|---------|------|------|
| 常量折叠 | `2 + 3 → 5` | 消除运算 |
| 内联 | 替换函数调用 | 减少调用开销 |
| 展开循环 | 固定次数循环 | 消除分支 |
| 数据预计算 | 静态数据索引 | O(1)查找 |

### 1.2 形式化定义

**定义 1.1** (部分求值器)

部分求值器 `mix` 是一个程序：

```text
mix : Program × Input_static → Program

使得: ∀S, D. [[mix(P, S)]](D) = [[P]](S, D)
```

其中 [[·]] 表示程序的语义（结果）。

**性质**:

1. **正确性**: 特化程序语义等价于原程序
2. **效率**: `time([[mix(P, S)]](D)) < time([[P]](S, D))`
3. **终止**: mix(P, S) 总是终止

**定义 1.2** (自应用 Self-Application)

```text
mix(mix, (P, S)) = P_S
```

即：用部分求值器特化自己。

### 1.3 在线vs离线求值

#### 1.3.1 在线部分求值

**特点**:

- 运行时决策（求值vs残余化）
- 灵活，适应动态信息
- 较慢（解释开销）

**算法框架**:

```python
def online_pe(expr, env_static):
    """在线部分求值"""
    match expr:
        case Const(c):
            return c  # 静态：直接返回值
        
        case Var(x):
            if x in env_static:
                return env_static[x]  # 静态
            else:
                return Var(x)  # 动态：残余化
        
        case BinOp(op, e1, e2):
            v1 = online_pe(e1, env_static)
            v2 = online_pe(e2, env_static)
            
            if is_value(v1) and is_value(v2):
                return eval_op(op, v1, v2)  # 静态：求值
            else:
                return BinOp(op, v1, v2)  # 动态：残余化
```

#### 1.3.2 离线部分求值

**特点**:

- 编译时分析（Binding Time Analysis）
- 两阶段：BTA + 特化
- 更快（预知静态/动态划分）

**算法框架**:

```python
# 阶段1: BTA
def bta(expr):
    """绑定时间分析"""
    return annotate(expr, static_or_dynamic)

# 阶段2: 特化
def offline_pe(annotated_expr, env_static):
    """离线部分求值"""
    match annotated_expr:
        case Static(e):
            return eval(e, env_static)  # 直接求值
        
        case Dynamic(e):
            return residualize(e)  # 生成代码
```

**对比**:

| 维度 | 在线 | 离线 |
|------|------|------|
| 分析时间 | 运行时 | 编译时 |
| 灵活性 | 高 | 低 |
| 性能 | 较慢 | 快 |
| 复杂度 | 简单 | 复杂（BTA） |

---

## 2. 绑定时间分析

### 2.1 BTA定义

**定义 2.1** (绑定时间 Binding Time)

绑定时间指变量/表达式的值何时确定：

```text
BT ::= Static      -- 编译时已知
     | Dynamic     -- 运行时才知
```

**绑定时间环境**:

```text
Γ : Var → BT
```

### 2.2 绑定时间类型

**定义 2.2** (BT类型判断)

```text
Γ ⊢_BT e : bt

表示：在环境Γ下，表达式e的绑定时间是bt
```

**BTA规则**:

```text
(BT-Const)
           ────────────────
           Γ ⊢_BT c : Static

(BT-Var)   Γ(x) = bt
           ────────────────
           Γ ⊢_BT x : bt

(BT-Op)    Γ ⊢_BT e₁ : bt₁    Γ ⊢_BT e₂ : bt₂
           ───────────────────────────────────
           Γ ⊢_BT e₁ ⊕ e₂ : bt₁ ⊔ bt₂

其中: Static ⊔ Static = Static
     Static ⊔ Dynamic = Dynamic
     Dynamic ⊔ _ = Dynamic
```

**示例**:

```rego
# Γ = {input: Dynamic, data: Static}

x = data.max_value          # Static
y = input.count             # Dynamic
z = x + y                   # Dynamic (Static ⊔ Dynamic)

if z > data.threshold {     # Dynamic (条件依赖z)
    allow = true
}
```

### 2.3 分析算法

**Algorithm: BTA**

```python
def bta(expr, bt_env):
    """绑定时间分析"""
    match expr:
        case Const(c):
            return Static
        
        case Var(x):
            return bt_env.get(x, Dynamic)
        
        case BinOp(op, e1, e2):
            bt1 = bta(e1, bt_env)
            bt2 = bta(e2, bt_env)
            return join_bt(bt1, bt2)
        
        case If(cond, then_br, else_br):
            bt_cond = bta(cond, bt_env)
            bt_then = bta(then_br, bt_env)
            bt_else = bta(else_br, bt_env)
            
            # 条件动态 → 分支动态
            if bt_cond == Dynamic:
                return Dynamic
            else:
                return join_bt(bt_then, bt_else)
        
        case Call(f, args):
            bt_f = bta(f, bt_env)
            bt_args = [bta(arg, bt_env) for arg in args]
            
            # 保守估计：任何动态参数 → 结果动态
            if any(bt == Dynamic for bt in [bt_f] + bt_args):
                return Dynamic
            return Static

def join_bt(bt1, bt2):
    """绑定时间合并（最小上界）"""
    if bt1 == Dynamic or bt2 == Dynamic:
        return Dynamic
    return Static
```

**定理 2.1** (BTA安全性)

如果 Γ ⊢_BT e : Static，则 e 在环境 Γ 下可完全求值。

**证明**: 对BTA推导归纳  ✓

---

## 3. 特化算法

### 3.1 符号执行

**定义 3.1** (符号值)

符号值混合了具体值和符号变量：

```text
SVal ::= Const(c)              -- 具体值
       | Sym(x)                -- 符号变量
       | SOp(op, sv₁, sv₂)     -- 符号运算
```

**符号环境**:

```text
SEnv : Var → SVal
```

**符号求值**:

```python
def symbolic_eval(expr, senv):
    """符号执行"""
    match expr:
        case Const(c):
            return Const(c)
        
        case Var(x):
            return senv.get(x, Sym(x))
        
        case BinOp(op, e1, e2):
            sv1 = symbolic_eval(e1, senv)
            sv2 = symbolic_eval(e2, senv)
            
            # 尝试常量折叠
            if isinstance(sv1, Const) and isinstance(sv2, Const):
                return Const(eval_op(op, sv1.val, sv2.val))
            
            # 代数简化
            if op == '+' and sv2 == Const(0):
                return sv1  # x + 0 = x
            if op == '*' and sv2 == Const(1):
                return sv1  # x * 1 = x
            if op == '*' and sv2 == Const(0):
                return Const(0)  # x * 0 = 0
            
            # 残余化
            return SOp(op, sv1, sv2)
```

### 3.2 残余程序生成

**定义 3.2** (残余化 Residualization)

残余化是将符号值转换回语法的过程：

```python
def residualize(sval):
    """生成残余代码"""
    match sval:
        case Const(c):
            return Const(c)
        
        case Sym(x):
            return Var(x)
        
        case SOp(op, sv1, sv2):
            e1 = residualize(sv1)
            e2 = residualize(sv2)
            return BinOp(op, e1, e2)
```

**完整特化算法**:

```python
def specialize(program, static_input):
    """程序特化"""
    # 1. 构造符号环境
    senv = {}
    for (var, val) in static_input.items():
        senv[var] = Const(val)
    
    # 2. 符号执行
    sval = symbolic_eval(program, senv)
    
    # 3. 残余化
    specialized_program = residualize(sval)
    
    return specialized_program
```

### 3.3 展开与记忆化

**问题**: 递归函数的特化可能不终止

**示例**:

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

# 特化 fib 对静态n → 无限展开！
```

**解决方案1: 展开深度限制**

```python
def specialize_with_limit(func, static_args, depth=0, max_depth=10):
    if depth > max_depth:
        return residualize_call(func, static_args)
    
    # 展开一层
    body = inline(func, static_args)
    return specialize_with_limit(body, ..., depth+1, max_depth)
```

**解决方案2: 记忆化（Memoization）**

```python
memo = {}

def specialize_memo(func, static_args):
    key = (func, static_args)
    if key in memo:
        return memo[key]  # 避免重复特化
    
    # 标记为处理中（检测循环）
    memo[key] = InProgress
    
    result = specialize_body(func, static_args)
    memo[key] = result
    return result
```

**定理 3.1** (记忆化终止性)

如果静态参数空间有限，则带记忆化的特化算法终止。

---

## 4. 正确性证明

### 4.1 语义保持定理

**定理 4.1** (特化正确性)

设 P_S = specialize(P, S)，则：

```text
∀D. [[P_S]](D) = [[P]](S, D)
```

**证明** (对程序结构归纳):

**情况1: 常量**

```text
P = c
P_S = specialize(c, S) = c
[[P_S]](D) = [[c]](D) = c
[[P]](S, D) = [[c]](S, D) = c
因此 [[P_S]](D) = [[P]](S, D)  ✓
```

**情况2: 变量**

```text
P = x

子情况2.1: x ∈ dom(S)
  P_S = S(x)  (替换为静态值)
  [[P_S]](D) = S(x)
  [[P]](S, D) = S(x)  ✓

子情况2.2: x ∉ dom(S)
  P_S = x  (动态变量)
  [[P_S]](D) = D(x)
  [[P]](S, D) = D(x)  ✓
```

**情况3: 二元运算**

```text
P = e₁ ⊕ e₂
P_S = specialize(e₁, S) ⊕' specialize(e₂, S)

归纳假设:
  [[specialize(e₁, S)]](D) = [[e₁]](S, D)
  [[specialize(e₂, S)]](D) = [[e₂]](S, D)

[[P_S]](D) 
  = [[specialize(e₁,S) ⊕' specialize(e₂,S)]](D)
  = [[specialize(e₁,S)]](D) ⊕ [[specialize(e₂,S)]](D)
  = [[e₁]](S, D) ⊕ [[e₂]](S, D)    (归纳假设)
  = [[e₁ ⊕ e₂]](S, D)
  = [[P]](S, D)  ✓
```

**情况4: 条件语句**

```text
P = if e_cond then e_then else e_else

子情况4.1: e_cond 静态为真
  P_S = specialize(e_then, S)
  [[P_S]](D) = [[e_then]](S, D)   (归纳假设)
  [[P]](S, D) = [[e_then]](S, D)  (条件为真)  ✓

子情况4.2: e_cond 静态为假
  类似  ✓

子情况4.3: e_cond 动态
  P_S = if e_cond' then e_then' else e_else'
  (其中 e_* ' = specialize(e_*, S))
  
  [[P_S]](D) 
    = [[e_then']](D)  if [[e_cond']](D) = true
    = [[e_then]](S, D)  (归纳假设)
    = [[P]](S, D)  ✓
```

**结论**: 特化保持语义  ✓

### 4.2 终止性保证

**定理 4.2** (特化终止性)

如果:

1. 原程序 P 对所有输入终止
2. 使用有界展开或记忆化

则 specialize(P, S) 终止。

**证明**:

情况1（有界展开）: 最多展开k层，必然终止  ✓

情况2（记忆化）:

- 静态参数组合有限
- 每个组合最多特化一次
- 因此总步数有限  ✓

### 4.3 效率分析

**定理 4.3** (速度提升)

设 T(P, S, D) 为原程序运行时间，T(P_S, D) 为特化程序运行时间。

如果静态输入规模为 |S|，则：

```text
T(P_S, D) ≤ T(P, S, D) - O(f(|S|))
```

其中 f(|S|) 是静态计算的复杂度。

**实例分析**:

```text
原程序: lookup in hash table (O(1))
  if key in static_data:    # O(1) 每次
      return static_data[key]

特化程序:
  return precomputed_value  # O(1) 常数更小

加速比: 约 2-10x (消除哈希计算和查找)
```

---

## 5. Futamura投影

### 5.1 第一Futamura投影

**定理 5.1** (第一投影)

```text
mix(Interpreter, Program) = CompiledProgram
```

即：用部分求值器特化解释器 + 程序 = 编译的程序

**示例**:

```text
Interpreter: Rego解释器
Program: 具体策略
Result: 针对该策略的高效执行器
```

**形式化**:

```text
[[Interpreter]](Program, Data) = Result

设 Compiled = mix(Interpreter, Program)
则 [[Compiled]](Data) = [[Interpreter]](Program, Data)

且 speed([[Compiled]](Data)) > speed([[Interpreter]](Program, Data))
```

### 5.2 第二Futamura投影

**定理 5.2** (第二投影)

```text
mix(mix, Interpreter) = Compiler
```

即：用部分求值器特化自己 + 解释器 = 编译器

**含义**:

```text
Compiler(Program) = mix(Interpreter, Program)
```

自动生成编译器！

### 5.3 第三Futamura投影

**定理 5.3** (第三投影)

```text
mix(mix, mix) = CompilerGenerator
```

即：三次自应用 = 编译器生成器

**完整链条**:

```text
Level 0: Program
Level 1: Interpreter(Program, Data) → Result
Level 2: mix(Interpreter, Program) → CompiledProgram
Level 3: mix(mix, Interpreter) → Compiler
Level 4: mix(mix, mix) → CompilerGenerator
```

**实际意义**: 理论上优美，实践中复杂度过高

---

## 6. OPA中的部分求值

### 6.1 策略预编译

**OPA部分求值场景**:

```rego
# 原始策略
allow if {
    input.method == "GET"
    some role in input.user.roles
    role in data.allowed_roles
}

# 已知: data.allowed_roles = {"admin", "viewer"}

# 特化后:
allow_specialized if {
    input.method == "GET"
    some role in input.user.roles
    (role == "admin" || role == "viewer")  # 内联 + 优化
}
```

**效果**:

- ❌ 消除 `data` 访问
- ✅ 内联集合查找
- ✅ 优化为直接比较

### 6.2 WASM编译

**OPA → WASM流程**:

```text
1. Rego策略 (源码)
   ↓
2. AST (抽象语法树)
   ↓
3. Partial Evaluation (部分求值)
   - 内联 data
   - 常量折叠
   - 死代码消除
   ↓
4. IR (中间表示)
   ↓
5. WASM字节码
```

**部分求值优化**:

| 优化 | 示例 | 效果 |
|------|------|------|
| 数据内联 | `data.x` → `42` | 消除查找 |
| 常量传播 | `x = 2; y = x + 3` → `y = 5` | 减少运算 |
| 死代码消除 | `if false { ... }` → ∅ | 缩小代码 |
| 循环展开 | `for i in [1,2,3]` → 展开3次 | 消除迭代 |

### 6.3 性能提升实例

**基准测试**:

```rego
# 策略
package authz

default allow = false

allow if {
    input.user.id == data.admin_id
}

allow if {
    some role in input.user.roles
    role in data.admin_roles
}
```

**测试结果**:

| 模式 | QPS | 延迟 (P99) | 说明 |
|------|-----|-----------|------|
| 解释器 | 10K | 5ms | 每次查找 data |
| 部分求值 | 50K | 1ms | 内联 data |
| WASM编译 | 100K | 0.5ms | 完全预编译 |

**加速比**: 10x (部分求值)，5x (WASM)

---

## 7. 高级主题

### 7.1 多层部分求值

**定义**: 多次特化，逐步细化

```text
P₀  (原程序)
  ↓ specialize(P₀, S₁)
P₁  (第一层特化)
  ↓ specialize(P₁, S₂)
P₂  (第二层特化)
  ...
```

**应用**:

- 层次化数据：先内联全局配置，再内联用户数据
- 增量编译：先编译公共部分，再编译特定部分

### 7.2 增量特化

**问题**: 数据变化时，如何高效重新特化？

**解决**:

1. 记录依赖关系
2. 只重新特化受影响部分
3. 重用未变化部分的结果

**伪代码**:

```python
def incremental_specialize(program, old_data, new_data):
    diff = compute_diff(old_data, new_data)
    affected = find_affected_parts(program, diff)
    
    result = cached_result.copy()
    for part in affected:
        result[part] = specialize(part, new_data)
    
    return result
```

### 7.3 自适应优化

**定义**: 根据运行时profile动态调整特化策略

**策略**:

1. 初始使用解释器 + profiling
2. 识别热路径（hot path）
3. 对热路径进行部分求值
4. 混合执行（解释 + 编译）

**效果**: 平衡编译开销和运行性能

---

## 附录

### A. 术语对照

| 英文 | 中文 | 说明 |
|------|------|------|
| Partial Evaluation | 部分求值 | 编译时求值 |
| Specialization | 特化 | 生成优化程序 |
| Residualization | 残余化 | 生成残余代码 |
| Binding Time | 绑定时间 | 值确定的时间 |
| Futamura Projection | Futamura投影 | 解释器→编译器理论 |
| Symbolic Execution | 符号执行 | 混合具体/符号值 |

### B. 核心定理速查

1. **特化正确性**: `[[P_S]](D) = [[P]](S, D)`
2. **BTA安全性**: 静态标注可完全求值
3. **第一Futamura投影**: 特化解释器=编译
4. **终止性**: 有界展开/记忆化保证终止
5. **速度提升**: 消除静态计算开销

### C. OPA应用总结

| 技术 | OPA应用 | 效果 |
|------|---------|------|
| 数据内联 | 编译时内联 data | 10x加速 |
| WASM编译 | 策略→WASM | 100x加速 |
| 常量折叠 | 优化表达式 | 2-5x加速 |
| 死代码消除 | 移除无用规则 | 减小体积 |

### D. 参考文献

1. **Jones, N.D., Gomard, C.K., Sestoft, P.** "Partial Evaluation and Automatic Program Generation" (1993)
   - 部分求值经典教材
2. **Futamura, Y.** "Partial Evaluation of Computation Process" (1971)
   - Futamura投影原始论文
3. **Consel, C., Danvy, O.** "Tutorial Notes on Partial Evaluation" (1993)
   - 入门教程
4. **OPA Compiler** - <https://www.openpolicyagent.org/docs/latest/policy-performance/>
   - OPA编译器文档
5. **WASM Backend** - <https://www.openpolicyagent.org/docs/latest/wasm/>
   - OPA WASM编译

---

**文档版本**: v1.0  
**最后更新**: 2025年10月21日  
**维护者**: OPA技术文档项目  
**反馈**: 欢迎通过GitHub Issues提供建议

**下一步阅读**:

- [抽象解释理论](06.7-抽象解释理论.md) - 静态分析的数学基础
- [WASM编译规范](../01-技术规范/01.3-WASM编译规范.md) - OPA WASM编译实践
- [性能优化指南](../08-最佳实践/08.2-性能优化指南.md) - 实用优化技巧
