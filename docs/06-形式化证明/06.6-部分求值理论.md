# éƒ¨åˆ†æ±‚å€¼ç†è®º

> **æ–‡æ¡£ç±»å‹**: å½¢å¼åŒ–ä¼˜åŒ–ç†è®º  
> **ç†è®ºé¢†åŸŸ**: ç¨‹åºç‰¹åŒ–ã€ç¼–è¯‘å™¨ä¼˜åŒ–ã€æ€§èƒ½ç†è®º  
> **é€‚ç”¨è¯»è€…**: ç¼–è¯‘å™¨å¼€å‘è€…ã€ä¼˜åŒ–ä¸“å®¶ã€ç†è®ºç ”ç©¶è€…  
> **å…ˆä¿®çŸ¥è¯†**: [ä¸€é˜¶é€»è¾‘](06.3-å‘½é¢˜é€»è¾‘ä¸ä¸€é˜¶é€»è¾‘åŸºç¡€.md)ã€[æ±‚å€¼ç®—æ³•](06.4-æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜.md)  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ21æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 1.2 - ä¼˜åŒ–ç†è®º

---

## ğŸ“ éƒ¨åˆ†æ±‚å€¼ç†è®ºæ¡†æ¶

> **æœ¬æ–‡æ¡£ç›®æ ‡**:
>
> - âœ… å»ºç«‹éƒ¨åˆ†æ±‚å€¼çš„æ•°å­¦åŸºç¡€
> - âœ… è¯æ˜ç‰¹åŒ–ç¨‹åºçš„æ­£ç¡®æ€§
> - âœ… åˆ†æFutamuraæŠ•å½±ç†è®º
> - âœ… ç ”ç©¶ç»‘å®šæ—¶é—´åˆ†æ
> - âœ… åº”ç”¨äºOPAç­–ç•¥ä¼˜åŒ–
>
> **æ ¸å¿ƒæ¦‚å¿µ**:
>
> - **éƒ¨åˆ†æ±‚å€¼**: åœ¨ç¼–è¯‘æ—¶æ±‚å€¼éƒ¨åˆ†å·²çŸ¥è¾“å…¥
> - **ç‰¹åŒ–**: ç”Ÿæˆé’ˆå¯¹ç‰¹å®šè¾“å…¥çš„ä¼˜åŒ–ç¨‹åº
> - **FutamuraæŠ•å½±**: è§£é‡Šå™¨â†’ç¼–è¯‘å™¨çš„ç†è®ºåŸºç¡€
> - **ç»‘å®šæ—¶é—´**: åŒºåˆ†é™æ€/åŠ¨æ€æ•°æ®
>
> **å®é™…ä»·å€¼**:
>
> - ç­–ç•¥é¢„ç¼–è¯‘ä¼˜åŒ–ï¼ˆPolicy â†’ WASMï¼‰
> - è¿è¡Œæ—¶æ€§èƒ½æå‡ï¼ˆæ¶ˆé™¤å†—ä½™è®¡ç®—ï¼‰
> - æ•°æ®é©±åŠ¨ä¼˜åŒ–ï¼ˆå›ºå®šinputéƒ¨åˆ†ï¼‰
> - è‡ªåŠ¨ç¨‹åºç‰¹åŒ–

---

## ç›®å½•

- [éƒ¨åˆ†æ±‚å€¼ç†è®º](#éƒ¨åˆ†æ±‚å€¼ç†è®º)
  - [ğŸ“ éƒ¨åˆ†æ±‚å€¼ç†è®ºæ¡†æ¶](#-éƒ¨åˆ†æ±‚å€¼ç†è®ºæ¡†æ¶)
  - [ç›®å½•](#ç›®å½•)
  - [1. éƒ¨åˆ†æ±‚å€¼åŸºç¡€](#1-éƒ¨åˆ†æ±‚å€¼åŸºç¡€)
    - [1.1 åŠ¨æœºä¸ç¤ºä¾‹](#11-åŠ¨æœºä¸ç¤ºä¾‹)
      - [1.1.1 é—®é¢˜èƒŒæ™¯](#111-é—®é¢˜èƒŒæ™¯)
      - [1.1.2 æ€§èƒ½æ”¶ç›Š](#112-æ€§èƒ½æ”¶ç›Š)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 åœ¨çº¿vsç¦»çº¿æ±‚å€¼](#13-åœ¨çº¿vsç¦»çº¿æ±‚å€¼)
      - [1.3.1 åœ¨çº¿éƒ¨åˆ†æ±‚å€¼](#131-åœ¨çº¿éƒ¨åˆ†æ±‚å€¼)
      - [1.3.2 ç¦»çº¿éƒ¨åˆ†æ±‚å€¼](#132-ç¦»çº¿éƒ¨åˆ†æ±‚å€¼)
  - [2. ç»‘å®šæ—¶é—´åˆ†æ](#2-ç»‘å®šæ—¶é—´åˆ†æ)
    - [2.1 BTAå®šä¹‰](#21-btaå®šä¹‰)
    - [2.2 ç»‘å®šæ—¶é—´ç±»å‹](#22-ç»‘å®šæ—¶é—´ç±»å‹)
    - [2.3 åˆ†æç®—æ³•](#23-åˆ†æç®—æ³•)
  - [3. ç‰¹åŒ–ç®—æ³•](#3-ç‰¹åŒ–ç®—æ³•)
    - [3.1 ç¬¦å·æ‰§è¡Œ](#31-ç¬¦å·æ‰§è¡Œ)
    - [3.2 æ®‹ä½™ç¨‹åºç”Ÿæˆ](#32-æ®‹ä½™ç¨‹åºç”Ÿæˆ)
    - [3.3 å±•å¼€ä¸è®°å¿†åŒ–](#33-å±•å¼€ä¸è®°å¿†åŒ–)
  - [4. æ­£ç¡®æ€§è¯æ˜](#4-æ­£ç¡®æ€§è¯æ˜)
    - [4.1 è¯­ä¹‰ä¿æŒå®šç†](#41-è¯­ä¹‰ä¿æŒå®šç†)
    - [4.2 ç»ˆæ­¢æ€§ä¿è¯](#42-ç»ˆæ­¢æ€§ä¿è¯)
    - [4.3 æ•ˆç‡åˆ†æ](#43-æ•ˆç‡åˆ†æ)
  - [5. FutamuraæŠ•å½±](#5-futamuraæŠ•å½±)
    - [5.1 ç¬¬ä¸€FutamuraæŠ•å½±](#51-ç¬¬ä¸€futamuraæŠ•å½±)
    - [5.2 ç¬¬äºŒFutamuraæŠ•å½±](#52-ç¬¬äºŒfutamuraæŠ•å½±)
    - [5.3 ç¬¬ä¸‰FutamuraæŠ•å½±](#53-ç¬¬ä¸‰futamuraæŠ•å½±)
  - [6. OPAä¸­çš„éƒ¨åˆ†æ±‚å€¼](#6-opaä¸­çš„éƒ¨åˆ†æ±‚å€¼)
    - [6.1 ç­–ç•¥é¢„ç¼–è¯‘](#61-ç­–ç•¥é¢„ç¼–è¯‘)
    - [6.2 WASMç¼–è¯‘](#62-wasmç¼–è¯‘)
    - [6.3 æ€§èƒ½æå‡å®ä¾‹](#63-æ€§èƒ½æå‡å®ä¾‹)
  - [7. é«˜çº§ä¸»é¢˜](#7-é«˜çº§ä¸»é¢˜)
    - [7.1 å¤šå±‚éƒ¨åˆ†æ±‚å€¼](#71-å¤šå±‚éƒ¨åˆ†æ±‚å€¼)
    - [7.2 å¢é‡ç‰¹åŒ–](#72-å¢é‡ç‰¹åŒ–)
    - [7.3 è‡ªé€‚åº”ä¼˜åŒ–](#73-è‡ªé€‚åº”ä¼˜åŒ–)
  - [é™„å½•](#é™„å½•)
    - [A. æœ¯è¯­å¯¹ç…§](#a-æœ¯è¯­å¯¹ç…§)
    - [B. æ ¸å¿ƒå®šç†é€ŸæŸ¥](#b-æ ¸å¿ƒå®šç†é€ŸæŸ¥)
    - [C. OPAåº”ç”¨æ€»ç»“](#c-opaåº”ç”¨æ€»ç»“)
    - [D. å‚è€ƒæ–‡çŒ®](#d-å‚è€ƒæ–‡çŒ®)

---

## 1. éƒ¨åˆ†æ±‚å€¼åŸºç¡€

### 1.1 åŠ¨æœºä¸ç¤ºä¾‹

#### 1.1.1 é—®é¢˜èƒŒæ™¯

**åœºæ™¯**: ç¨‹åºPæœ‰ä¸¤ä¸ªè¾“å…¥Sï¼ˆé™æ€ï¼‰å’ŒDï¼ˆåŠ¨æ€ï¼‰

```text
P(S, D) â†’ Result
```

å¦‚æœSåœ¨ç¼–è¯‘æ—¶å·²çŸ¥ï¼Œèƒ½å¦ç”Ÿæˆä¼˜åŒ–çš„ç¨‹åºP_Sï¼Œä½¿å¾—ï¼š

```text
P_S(D) = P(S, D)  ä¸” P_S(D) æ›´å¿«
```

**ç¤ºä¾‹1: å¹‚å‡½æ•°**

```python
# åŸå§‹ç¨‹åº
def power(base, exp):
    if exp == 0:
        return 1
    else:
        return base * power(base, exp - 1)

# éƒ¨åˆ†æ±‚å€¼: exp = 3 (é™æ€å·²çŸ¥)
def power_3(base):
    return base * base * base  # å±•å¼€é€’å½’
```

**ç¤ºä¾‹2: Regoç­–ç•¥**

```rego
# åŸå§‹ç­–ç•¥
allow if {
    some role in input.user.roles
    role in data.admin_roles
}

# éƒ¨åˆ†æ±‚å€¼: data.admin_roles = {"admin", "superuser"} (é™æ€)
allow_specialized if {
    some role in input.user.roles
    role in {"admin", "superuser"}  # å†…è”data
}
```

#### 1.1.2 æ€§èƒ½æ”¶ç›Š

| ä¼˜åŒ–ç±»å‹ | ç¤ºä¾‹ | æ”¶ç›Š |
|---------|------|------|
| å¸¸é‡æŠ˜å  | `2 + 3 â†’ 5` | æ¶ˆé™¤è¿ç®— |
| å†…è” | æ›¿æ¢å‡½æ•°è°ƒç”¨ | å‡å°‘è°ƒç”¨å¼€é”€ |
| å±•å¼€å¾ªç¯ | å›ºå®šæ¬¡æ•°å¾ªç¯ | æ¶ˆé™¤åˆ†æ”¯ |
| æ•°æ®é¢„è®¡ç®— | é™æ€æ•°æ®ç´¢å¼• | O(1)æŸ¥æ‰¾ |

### 1.2 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (éƒ¨åˆ†æ±‚å€¼å™¨)

éƒ¨åˆ†æ±‚å€¼å™¨ `mix` æ˜¯ä¸€ä¸ªç¨‹åºï¼š

```text
mix : Program Ã— Input_static â†’ Program

ä½¿å¾—: âˆ€S, D. [[mix(P, S)]](D) = [[P]](S, D)
```

å…¶ä¸­ [[Â·]] è¡¨ç¤ºç¨‹åºçš„è¯­ä¹‰ï¼ˆç»“æœï¼‰ã€‚

**æ€§è´¨**:

1. **æ­£ç¡®æ€§**: ç‰¹åŒ–ç¨‹åºè¯­ä¹‰ç­‰ä»·äºåŸç¨‹åº
2. **æ•ˆç‡**: `time([[mix(P, S)]](D)) < time([[P]](S, D))`
3. **ç»ˆæ­¢**: mix(P, S) æ€»æ˜¯ç»ˆæ­¢

**å®šä¹‰ 1.2** (è‡ªåº”ç”¨ Self-Application)

```text
mix(mix, (P, S)) = P_S
```

å³ï¼šç”¨éƒ¨åˆ†æ±‚å€¼å™¨ç‰¹åŒ–è‡ªå·±ã€‚

### 1.3 åœ¨çº¿vsç¦»çº¿æ±‚å€¼

#### 1.3.1 åœ¨çº¿éƒ¨åˆ†æ±‚å€¼

**ç‰¹ç‚¹**:

- è¿è¡Œæ—¶å†³ç­–ï¼ˆæ±‚å€¼vsæ®‹ä½™åŒ–ï¼‰
- çµæ´»ï¼Œé€‚åº”åŠ¨æ€ä¿¡æ¯
- è¾ƒæ…¢ï¼ˆè§£é‡Šå¼€é”€ï¼‰

**ç®—æ³•æ¡†æ¶**:

```python
def online_pe(expr, env_static):
    """åœ¨çº¿éƒ¨åˆ†æ±‚å€¼"""
    match expr:
        case Const(c):
            return c  # é™æ€ï¼šç›´æ¥è¿”å›å€¼
        
        case Var(x):
            if x in env_static:
                return env_static[x]  # é™æ€
            else:
                return Var(x)  # åŠ¨æ€ï¼šæ®‹ä½™åŒ–
        
        case BinOp(op, e1, e2):
            v1 = online_pe(e1, env_static)
            v2 = online_pe(e2, env_static)
            
            if is_value(v1) and is_value(v2):
                return eval_op(op, v1, v2)  # é™æ€ï¼šæ±‚å€¼
            else:
                return BinOp(op, v1, v2)  # åŠ¨æ€ï¼šæ®‹ä½™åŒ–
```

#### 1.3.2 ç¦»çº¿éƒ¨åˆ†æ±‚å€¼

**ç‰¹ç‚¹**:

- ç¼–è¯‘æ—¶åˆ†æï¼ˆBinding Time Analysisï¼‰
- ä¸¤é˜¶æ®µï¼šBTA + ç‰¹åŒ–
- æ›´å¿«ï¼ˆé¢„çŸ¥é™æ€/åŠ¨æ€åˆ’åˆ†ï¼‰

**ç®—æ³•æ¡†æ¶**:

```python
# é˜¶æ®µ1: BTA
def bta(expr):
    """ç»‘å®šæ—¶é—´åˆ†æ"""
    return annotate(expr, static_or_dynamic)

# é˜¶æ®µ2: ç‰¹åŒ–
def offline_pe(annotated_expr, env_static):
    """ç¦»çº¿éƒ¨åˆ†æ±‚å€¼"""
    match annotated_expr:
        case Static(e):
            return eval(e, env_static)  # ç›´æ¥æ±‚å€¼
        
        case Dynamic(e):
            return residualize(e)  # ç”Ÿæˆä»£ç 
```

**å¯¹æ¯”**:

| ç»´åº¦ | åœ¨çº¿ | ç¦»çº¿ |
|------|------|------|
| åˆ†ææ—¶é—´ | è¿è¡Œæ—¶ | ç¼–è¯‘æ—¶ |
| çµæ´»æ€§ | é«˜ | ä½ |
| æ€§èƒ½ | è¾ƒæ…¢ | å¿« |
| å¤æ‚åº¦ | ç®€å• | å¤æ‚ï¼ˆBTAï¼‰ |

---

## 2. ç»‘å®šæ—¶é—´åˆ†æ

### 2.1 BTAå®šä¹‰

**å®šä¹‰ 2.1** (ç»‘å®šæ—¶é—´ Binding Time)

ç»‘å®šæ—¶é—´æŒ‡å˜é‡/è¡¨è¾¾å¼çš„å€¼ä½•æ—¶ç¡®å®šï¼š

```text
BT ::= Static      -- ç¼–è¯‘æ—¶å·²çŸ¥
     | Dynamic     -- è¿è¡Œæ—¶æ‰çŸ¥
```

**ç»‘å®šæ—¶é—´ç¯å¢ƒ**:

```text
Î“ : Var â†’ BT
```

### 2.2 ç»‘å®šæ—¶é—´ç±»å‹

**å®šä¹‰ 2.2** (BTç±»å‹åˆ¤æ–­)

```text
Î“ âŠ¢_BT e : bt

è¡¨ç¤ºï¼šåœ¨ç¯å¢ƒÎ“ä¸‹ï¼Œè¡¨è¾¾å¼eçš„ç»‘å®šæ—¶é—´æ˜¯bt
```

**BTAè§„åˆ™**:

```text
(BT-Const)
           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           Î“ âŠ¢_BT c : Static

(BT-Var)   Î“(x) = bt
           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           Î“ âŠ¢_BT x : bt

(BT-Op)    Î“ âŠ¢_BT eâ‚ : btâ‚    Î“ âŠ¢_BT eâ‚‚ : btâ‚‚
           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           Î“ âŠ¢_BT eâ‚ âŠ• eâ‚‚ : btâ‚ âŠ” btâ‚‚

å…¶ä¸­: Static âŠ” Static = Static
     Static âŠ” Dynamic = Dynamic
     Dynamic âŠ” _ = Dynamic
```

**ç¤ºä¾‹**:

```rego
# Î“ = {input: Dynamic, data: Static}

x = data.max_value          # Static
y = input.count             # Dynamic
z = x + y                   # Dynamic (Static âŠ” Dynamic)

if z > data.threshold {     # Dynamic (æ¡ä»¶ä¾èµ–z)
    allow = true
}
```

### 2.3 åˆ†æç®—æ³•

**Algorithm: BTA**

```python
def bta(expr, bt_env):
    """ç»‘å®šæ—¶é—´åˆ†æ"""
    match expr:
        case Const(c):
            return Static
        
        case Var(x):
            return bt_env.get(x, Dynamic)
        
        case BinOp(op, e1, e2):
            bt1 = bta(e1, bt_env)
            bt2 = bta(e2, bt_env)
            return join_bt(bt1, bt2)
        
        case If(cond, then_br, else_br):
            bt_cond = bta(cond, bt_env)
            bt_then = bta(then_br, bt_env)
            bt_else = bta(else_br, bt_env)
            
            # æ¡ä»¶åŠ¨æ€ â†’ åˆ†æ”¯åŠ¨æ€
            if bt_cond == Dynamic:
                return Dynamic
            else:
                return join_bt(bt_then, bt_else)
        
        case Call(f, args):
            bt_f = bta(f, bt_env)
            bt_args = [bta(arg, bt_env) for arg in args]
            
            # ä¿å®ˆä¼°è®¡ï¼šä»»ä½•åŠ¨æ€å‚æ•° â†’ ç»“æœåŠ¨æ€
            if any(bt == Dynamic for bt in [bt_f] + bt_args):
                return Dynamic
            return Static

def join_bt(bt1, bt2):
    """ç»‘å®šæ—¶é—´åˆå¹¶ï¼ˆæœ€å°ä¸Šç•Œï¼‰"""
    if bt1 == Dynamic or bt2 == Dynamic:
        return Dynamic
    return Static
```

**å®šç† 2.1** (BTAå®‰å…¨æ€§)

å¦‚æœ Î“ âŠ¢_BT e : Staticï¼Œåˆ™ e åœ¨ç¯å¢ƒ Î“ ä¸‹å¯å®Œå…¨æ±‚å€¼ã€‚

**è¯æ˜**: å¯¹BTAæ¨å¯¼å½’çº³  âœ“

---

## 3. ç‰¹åŒ–ç®—æ³•

### 3.1 ç¬¦å·æ‰§è¡Œ

**å®šä¹‰ 3.1** (ç¬¦å·å€¼)

ç¬¦å·å€¼æ··åˆäº†å…·ä½“å€¼å’Œç¬¦å·å˜é‡ï¼š

```text
SVal ::= Const(c)              -- å…·ä½“å€¼
       | Sym(x)                -- ç¬¦å·å˜é‡
       | SOp(op, svâ‚, svâ‚‚)     -- ç¬¦å·è¿ç®—
```

**ç¬¦å·ç¯å¢ƒ**:

```text
SEnv : Var â†’ SVal
```

**ç¬¦å·æ±‚å€¼**:

```python
def symbolic_eval(expr, senv):
    """ç¬¦å·æ‰§è¡Œ"""
    match expr:
        case Const(c):
            return Const(c)
        
        case Var(x):
            return senv.get(x, Sym(x))
        
        case BinOp(op, e1, e2):
            sv1 = symbolic_eval(e1, senv)
            sv2 = symbolic_eval(e2, senv)
            
            # å°è¯•å¸¸é‡æŠ˜å 
            if isinstance(sv1, Const) and isinstance(sv2, Const):
                return Const(eval_op(op, sv1.val, sv2.val))
            
            # ä»£æ•°ç®€åŒ–
            if op == '+' and sv2 == Const(0):
                return sv1  # x + 0 = x
            if op == '*' and sv2 == Const(1):
                return sv1  # x * 1 = x
            if op == '*' and sv2 == Const(0):
                return Const(0)  # x * 0 = 0
            
            # æ®‹ä½™åŒ–
            return SOp(op, sv1, sv2)
```

### 3.2 æ®‹ä½™ç¨‹åºç”Ÿæˆ

**å®šä¹‰ 3.2** (æ®‹ä½™åŒ– Residualization)

æ®‹ä½™åŒ–æ˜¯å°†ç¬¦å·å€¼è½¬æ¢å›è¯­æ³•çš„è¿‡ç¨‹ï¼š

```python
def residualize(sval):
    """ç”Ÿæˆæ®‹ä½™ä»£ç """
    match sval:
        case Const(c):
            return Const(c)
        
        case Sym(x):
            return Var(x)
        
        case SOp(op, sv1, sv2):
            e1 = residualize(sv1)
            e2 = residualize(sv2)
            return BinOp(op, e1, e2)
```

**å®Œæ•´ç‰¹åŒ–ç®—æ³•**:

```python
def specialize(program, static_input):
    """ç¨‹åºç‰¹åŒ–"""
    # 1. æ„é€ ç¬¦å·ç¯å¢ƒ
    senv = {}
    for (var, val) in static_input.items():
        senv[var] = Const(val)
    
    # 2. ç¬¦å·æ‰§è¡Œ
    sval = symbolic_eval(program, senv)
    
    # 3. æ®‹ä½™åŒ–
    specialized_program = residualize(sval)
    
    return specialized_program
```

### 3.3 å±•å¼€ä¸è®°å¿†åŒ–

**é—®é¢˜**: é€’å½’å‡½æ•°çš„ç‰¹åŒ–å¯èƒ½ä¸ç»ˆæ­¢

**ç¤ºä¾‹**:

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

# ç‰¹åŒ– fib å¯¹é™æ€n â†’ æ— é™å±•å¼€ï¼
```

**è§£å†³æ–¹æ¡ˆ1: å±•å¼€æ·±åº¦é™åˆ¶**

```python
def specialize_with_limit(func, static_args, depth=0, max_depth=10):
    if depth > max_depth:
        return residualize_call(func, static_args)
    
    # å±•å¼€ä¸€å±‚
    body = inline(func, static_args)
    return specialize_with_limit(body, ..., depth+1, max_depth)
```

**è§£å†³æ–¹æ¡ˆ2: è®°å¿†åŒ–ï¼ˆMemoizationï¼‰**

```python
memo = {}

def specialize_memo(func, static_args):
    key = (func, static_args)
    if key in memo:
        return memo[key]  # é¿å…é‡å¤ç‰¹åŒ–
    
    # æ ‡è®°ä¸ºå¤„ç†ä¸­ï¼ˆæ£€æµ‹å¾ªç¯ï¼‰
    memo[key] = InProgress
    
    result = specialize_body(func, static_args)
    memo[key] = result
    return result
```

**å®šç† 3.1** (è®°å¿†åŒ–ç»ˆæ­¢æ€§)

å¦‚æœé™æ€å‚æ•°ç©ºé—´æœ‰é™ï¼Œåˆ™å¸¦è®°å¿†åŒ–çš„ç‰¹åŒ–ç®—æ³•ç»ˆæ­¢ã€‚

---

## 4. æ­£ç¡®æ€§è¯æ˜

### 4.1 è¯­ä¹‰ä¿æŒå®šç†

**å®šç† 4.1** (ç‰¹åŒ–æ­£ç¡®æ€§)

è®¾ P_S = specialize(P, S)ï¼Œåˆ™ï¼š

```text
âˆ€D. [[P_S]](D) = [[P]](S, D)
```

**è¯æ˜** (å¯¹ç¨‹åºç»“æ„å½’çº³):

**æƒ…å†µ1: å¸¸é‡**

```text
P = c
P_S = specialize(c, S) = c
[[P_S]](D) = [[c]](D) = c
[[P]](S, D) = [[c]](S, D) = c
å› æ­¤ [[P_S]](D) = [[P]](S, D)  âœ“
```

**æƒ…å†µ2: å˜é‡**

```text
P = x

å­æƒ…å†µ2.1: x âˆˆ dom(S)
  P_S = S(x)  (æ›¿æ¢ä¸ºé™æ€å€¼)
  [[P_S]](D) = S(x)
  [[P]](S, D) = S(x)  âœ“

å­æƒ…å†µ2.2: x âˆ‰ dom(S)
  P_S = x  (åŠ¨æ€å˜é‡)
  [[P_S]](D) = D(x)
  [[P]](S, D) = D(x)  âœ“
```

**æƒ…å†µ3: äºŒå…ƒè¿ç®—**

```text
P = eâ‚ âŠ• eâ‚‚
P_S = specialize(eâ‚, S) âŠ•' specialize(eâ‚‚, S)

å½’çº³å‡è®¾:
  [[specialize(eâ‚, S)]](D) = [[eâ‚]](S, D)
  [[specialize(eâ‚‚, S)]](D) = [[eâ‚‚]](S, D)

[[P_S]](D) 
  = [[specialize(eâ‚,S) âŠ•' specialize(eâ‚‚,S)]](D)
  = [[specialize(eâ‚,S)]](D) âŠ• [[specialize(eâ‚‚,S)]](D)
  = [[eâ‚]](S, D) âŠ• [[eâ‚‚]](S, D)    (å½’çº³å‡è®¾)
  = [[eâ‚ âŠ• eâ‚‚]](S, D)
  = [[P]](S, D)  âœ“
```

**æƒ…å†µ4: æ¡ä»¶è¯­å¥**

```text
P = if e_cond then e_then else e_else

å­æƒ…å†µ4.1: e_cond é™æ€ä¸ºçœŸ
  P_S = specialize(e_then, S)
  [[P_S]](D) = [[e_then]](S, D)   (å½’çº³å‡è®¾)
  [[P]](S, D) = [[e_then]](S, D)  (æ¡ä»¶ä¸ºçœŸ)  âœ“

å­æƒ…å†µ4.2: e_cond é™æ€ä¸ºå‡
  ç±»ä¼¼  âœ“

å­æƒ…å†µ4.3: e_cond åŠ¨æ€
  P_S = if e_cond' then e_then' else e_else'
  (å…¶ä¸­ e_* ' = specialize(e_*, S))
  
  [[P_S]](D) 
    = [[e_then']](D)  if [[e_cond']](D) = true
    = [[e_then]](S, D)  (å½’çº³å‡è®¾)
    = [[P]](S, D)  âœ“
```

**ç»“è®º**: ç‰¹åŒ–ä¿æŒè¯­ä¹‰  âœ“

### 4.2 ç»ˆæ­¢æ€§ä¿è¯

**å®šç† 4.2** (ç‰¹åŒ–ç»ˆæ­¢æ€§)

å¦‚æœ:

1. åŸç¨‹åº P å¯¹æ‰€æœ‰è¾“å…¥ç»ˆæ­¢
2. ä½¿ç”¨æœ‰ç•Œå±•å¼€æˆ–è®°å¿†åŒ–

åˆ™ specialize(P, S) ç»ˆæ­¢ã€‚

**è¯æ˜**:

æƒ…å†µ1ï¼ˆæœ‰ç•Œå±•å¼€ï¼‰: æœ€å¤šå±•å¼€kå±‚ï¼Œå¿…ç„¶ç»ˆæ­¢  âœ“

æƒ…å†µ2ï¼ˆè®°å¿†åŒ–ï¼‰:

- é™æ€å‚æ•°ç»„åˆæœ‰é™
- æ¯ä¸ªç»„åˆæœ€å¤šç‰¹åŒ–ä¸€æ¬¡
- å› æ­¤æ€»æ­¥æ•°æœ‰é™  âœ“

### 4.3 æ•ˆç‡åˆ†æ

**å®šç† 4.3** (é€Ÿåº¦æå‡)

è®¾ T(P, S, D) ä¸ºåŸç¨‹åºè¿è¡Œæ—¶é—´ï¼ŒT(P_S, D) ä¸ºç‰¹åŒ–ç¨‹åºè¿è¡Œæ—¶é—´ã€‚

å¦‚æœé™æ€è¾“å…¥è§„æ¨¡ä¸º |S|ï¼Œåˆ™ï¼š

```text
T(P_S, D) â‰¤ T(P, S, D) - O(f(|S|))
```

å…¶ä¸­ f(|S|) æ˜¯é™æ€è®¡ç®—çš„å¤æ‚åº¦ã€‚

**å®ä¾‹åˆ†æ**:

```text
åŸç¨‹åº: lookup in hash table (O(1))
  if key in static_data:    # O(1) æ¯æ¬¡
      return static_data[key]

ç‰¹åŒ–ç¨‹åº:
  return precomputed_value  # O(1) å¸¸æ•°æ›´å°

åŠ é€Ÿæ¯”: çº¦ 2-10x (æ¶ˆé™¤å“ˆå¸Œè®¡ç®—å’ŒæŸ¥æ‰¾)
```

---

## 5. FutamuraæŠ•å½±

### 5.1 ç¬¬ä¸€FutamuraæŠ•å½±

**å®šç† 5.1** (ç¬¬ä¸€æŠ•å½±)

```text
mix(Interpreter, Program) = CompiledProgram
```

å³ï¼šç”¨éƒ¨åˆ†æ±‚å€¼å™¨ç‰¹åŒ–è§£é‡Šå™¨ + ç¨‹åº = ç¼–è¯‘çš„ç¨‹åº

**ç¤ºä¾‹**:

```text
Interpreter: Regoè§£é‡Šå™¨
Program: å…·ä½“ç­–ç•¥
Result: é’ˆå¯¹è¯¥ç­–ç•¥çš„é«˜æ•ˆæ‰§è¡Œå™¨
```

**å½¢å¼åŒ–**:

```text
[[Interpreter]](Program, Data) = Result

è®¾ Compiled = mix(Interpreter, Program)
åˆ™ [[Compiled]](Data) = [[Interpreter]](Program, Data)

ä¸” speed([[Compiled]](Data)) > speed([[Interpreter]](Program, Data))
```

### 5.2 ç¬¬äºŒFutamuraæŠ•å½±

**å®šç† 5.2** (ç¬¬äºŒæŠ•å½±)

```text
mix(mix, Interpreter) = Compiler
```

å³ï¼šç”¨éƒ¨åˆ†æ±‚å€¼å™¨ç‰¹åŒ–è‡ªå·± + è§£é‡Šå™¨ = ç¼–è¯‘å™¨

**å«ä¹‰**:

```text
Compiler(Program) = mix(Interpreter, Program)
```

è‡ªåŠ¨ç”Ÿæˆç¼–è¯‘å™¨ï¼

### 5.3 ç¬¬ä¸‰FutamuraæŠ•å½±

**å®šç† 5.3** (ç¬¬ä¸‰æŠ•å½±)

```text
mix(mix, mix) = CompilerGenerator
```

å³ï¼šä¸‰æ¬¡è‡ªåº”ç”¨ = ç¼–è¯‘å™¨ç”Ÿæˆå™¨

**å®Œæ•´é“¾æ¡**:

```text
Level 0: Program
Level 1: Interpreter(Program, Data) â†’ Result
Level 2: mix(Interpreter, Program) â†’ CompiledProgram
Level 3: mix(mix, Interpreter) â†’ Compiler
Level 4: mix(mix, mix) â†’ CompilerGenerator
```

**å®é™…æ„ä¹‰**: ç†è®ºä¸Šä¼˜ç¾ï¼Œå®è·µä¸­å¤æ‚åº¦è¿‡é«˜

---

## 6. OPAä¸­çš„éƒ¨åˆ†æ±‚å€¼

### 6.1 ç­–ç•¥é¢„ç¼–è¯‘

**OPAéƒ¨åˆ†æ±‚å€¼åœºæ™¯**:

```rego
# åŸå§‹ç­–ç•¥
allow if {
    input.method == "GET"
    some role in input.user.roles
    role in data.allowed_roles
}

# å·²çŸ¥: data.allowed_roles = {"admin", "viewer"}

# ç‰¹åŒ–å:
allow_specialized if {
    input.method == "GET"
    some role in input.user.roles
    (role == "admin" || role == "viewer")  # å†…è” + ä¼˜åŒ–
}
```

**æ•ˆæœ**:

- âŒ æ¶ˆé™¤ `data` è®¿é—®
- âœ… å†…è”é›†åˆæŸ¥æ‰¾
- âœ… ä¼˜åŒ–ä¸ºç›´æ¥æ¯”è¾ƒ

### 6.2 WASMç¼–è¯‘

**OPA â†’ WASMæµç¨‹**:

```text
1. Regoç­–ç•¥ (æºç )
   â†“
2. AST (æŠ½è±¡è¯­æ³•æ ‘)
   â†“
3. Partial Evaluation (éƒ¨åˆ†æ±‚å€¼)
   - å†…è” data
   - å¸¸é‡æŠ˜å 
   - æ­»ä»£ç æ¶ˆé™¤
   â†“
4. IR (ä¸­é—´è¡¨ç¤º)
   â†“
5. WASMå­—èŠ‚ç 
```

**éƒ¨åˆ†æ±‚å€¼ä¼˜åŒ–**:

| ä¼˜åŒ– | ç¤ºä¾‹ | æ•ˆæœ |
|------|------|------|
| æ•°æ®å†…è” | `data.x` â†’ `42` | æ¶ˆé™¤æŸ¥æ‰¾ |
| å¸¸é‡ä¼ æ’­ | `x = 2; y = x + 3` â†’ `y = 5` | å‡å°‘è¿ç®— |
| æ­»ä»£ç æ¶ˆé™¤ | `if false { ... }` â†’ âˆ… | ç¼©å°ä»£ç  |
| å¾ªç¯å±•å¼€ | `for i in [1,2,3]` â†’ å±•å¼€3æ¬¡ | æ¶ˆé™¤è¿­ä»£ |

### 6.3 æ€§èƒ½æå‡å®ä¾‹

**åŸºå‡†æµ‹è¯•**:

```rego
# ç­–ç•¥
package authz

default allow = false

allow if {
    input.user.id == data.admin_id
}

allow if {
    some role in input.user.roles
    role in data.admin_roles
}
```

**æµ‹è¯•ç»“æœ**:

| æ¨¡å¼ | QPS | å»¶è¿Ÿ (P99) | è¯´æ˜ |
|------|-----|-----------|------|
| è§£é‡Šå™¨ | 10K | 5ms | æ¯æ¬¡æŸ¥æ‰¾ data |
| éƒ¨åˆ†æ±‚å€¼ | 50K | 1ms | å†…è” data |
| WASMç¼–è¯‘ | 100K | 0.5ms | å®Œå…¨é¢„ç¼–è¯‘ |

**åŠ é€Ÿæ¯”**: 10x (éƒ¨åˆ†æ±‚å€¼)ï¼Œ5x (WASM)

---

## 7. é«˜çº§ä¸»é¢˜

### 7.1 å¤šå±‚éƒ¨åˆ†æ±‚å€¼

**å®šä¹‰**: å¤šæ¬¡ç‰¹åŒ–ï¼Œé€æ­¥ç»†åŒ–

```text
Pâ‚€  (åŸç¨‹åº)
  â†“ specialize(Pâ‚€, Sâ‚)
Pâ‚  (ç¬¬ä¸€å±‚ç‰¹åŒ–)
  â†“ specialize(Pâ‚, Sâ‚‚)
Pâ‚‚  (ç¬¬äºŒå±‚ç‰¹åŒ–)
  ...
```

**åº”ç”¨**:

- å±‚æ¬¡åŒ–æ•°æ®ï¼šå…ˆå†…è”å…¨å±€é…ç½®ï¼Œå†å†…è”ç”¨æˆ·æ•°æ®
- å¢é‡ç¼–è¯‘ï¼šå…ˆç¼–è¯‘å…¬å…±éƒ¨åˆ†ï¼Œå†ç¼–è¯‘ç‰¹å®šéƒ¨åˆ†

### 7.2 å¢é‡ç‰¹åŒ–

**é—®é¢˜**: æ•°æ®å˜åŒ–æ—¶ï¼Œå¦‚ä½•é«˜æ•ˆé‡æ–°ç‰¹åŒ–ï¼Ÿ

**è§£å†³**:

1. è®°å½•ä¾èµ–å…³ç³»
2. åªé‡æ–°ç‰¹åŒ–å—å½±å“éƒ¨åˆ†
3. é‡ç”¨æœªå˜åŒ–éƒ¨åˆ†çš„ç»“æœ

**ä¼ªä»£ç **:

```python
def incremental_specialize(program, old_data, new_data):
    diff = compute_diff(old_data, new_data)
    affected = find_affected_parts(program, diff)
    
    result = cached_result.copy()
    for part in affected:
        result[part] = specialize(part, new_data)
    
    return result
```

### 7.3 è‡ªé€‚åº”ä¼˜åŒ–

**å®šä¹‰**: æ ¹æ®è¿è¡Œæ—¶profileåŠ¨æ€è°ƒæ•´ç‰¹åŒ–ç­–ç•¥

**ç­–ç•¥**:

1. åˆå§‹ä½¿ç”¨è§£é‡Šå™¨ + profiling
2. è¯†åˆ«çƒ­è·¯å¾„ï¼ˆhot pathï¼‰
3. å¯¹çƒ­è·¯å¾„è¿›è¡Œéƒ¨åˆ†æ±‚å€¼
4. æ··åˆæ‰§è¡Œï¼ˆè§£é‡Š + ç¼–è¯‘ï¼‰

**æ•ˆæœ**: å¹³è¡¡ç¼–è¯‘å¼€é”€å’Œè¿è¡Œæ€§èƒ½

---

## é™„å½•

### A. æœ¯è¯­å¯¹ç…§

| è‹±æ–‡ | ä¸­æ–‡ | è¯´æ˜ |
|------|------|------|
| Partial Evaluation | éƒ¨åˆ†æ±‚å€¼ | ç¼–è¯‘æ—¶æ±‚å€¼ |
| Specialization | ç‰¹åŒ– | ç”Ÿæˆä¼˜åŒ–ç¨‹åº |
| Residualization | æ®‹ä½™åŒ– | ç”Ÿæˆæ®‹ä½™ä»£ç  |
| Binding Time | ç»‘å®šæ—¶é—´ | å€¼ç¡®å®šçš„æ—¶é—´ |
| Futamura Projection | FutamuraæŠ•å½± | è§£é‡Šå™¨â†’ç¼–è¯‘å™¨ç†è®º |
| Symbolic Execution | ç¬¦å·æ‰§è¡Œ | æ··åˆå…·ä½“/ç¬¦å·å€¼ |

### B. æ ¸å¿ƒå®šç†é€ŸæŸ¥

1. **ç‰¹åŒ–æ­£ç¡®æ€§**: `[[P_S]](D) = [[P]](S, D)`
2. **BTAå®‰å…¨æ€§**: é™æ€æ ‡æ³¨å¯å®Œå…¨æ±‚å€¼
3. **ç¬¬ä¸€FutamuraæŠ•å½±**: ç‰¹åŒ–è§£é‡Šå™¨=ç¼–è¯‘
4. **ç»ˆæ­¢æ€§**: æœ‰ç•Œå±•å¼€/è®°å¿†åŒ–ä¿è¯ç»ˆæ­¢
5. **é€Ÿåº¦æå‡**: æ¶ˆé™¤é™æ€è®¡ç®—å¼€é”€

### C. OPAåº”ç”¨æ€»ç»“

| æŠ€æœ¯ | OPAåº”ç”¨ | æ•ˆæœ |
|------|---------|------|
| æ•°æ®å†…è” | ç¼–è¯‘æ—¶å†…è” data | 10xåŠ é€Ÿ |
| WASMç¼–è¯‘ | ç­–ç•¥â†’WASM | 100xåŠ é€Ÿ |
| å¸¸é‡æŠ˜å  | ä¼˜åŒ–è¡¨è¾¾å¼ | 2-5xåŠ é€Ÿ |
| æ­»ä»£ç æ¶ˆé™¤ | ç§»é™¤æ— ç”¨è§„åˆ™ | å‡å°ä½“ç§¯ |

### D. å‚è€ƒæ–‡çŒ®

1. **Jones, N.D., Gomard, C.K., Sestoft, P.** "Partial Evaluation and Automatic Program Generation" (1993)
   - éƒ¨åˆ†æ±‚å€¼ç»å…¸æ•™æ
2. **Futamura, Y.** "Partial Evaluation of Computation Process" (1971)
   - FutamuraæŠ•å½±åŸå§‹è®ºæ–‡
3. **Consel, C., Danvy, O.** "Tutorial Notes on Partial Evaluation" (1993)
   - å…¥é—¨æ•™ç¨‹
4. **OPA Compiler** - <https://www.openpolicyagent.org/docs/latest/policy-performance/>
   - OPAç¼–è¯‘å™¨æ–‡æ¡£
5. **WASM Backend** - <https://www.openpolicyagent.org/docs/latest/wasm/>
   - OPA WASMç¼–è¯‘

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ21æ—¥  
**ç»´æŠ¤è€…**: OPAæŠ€æœ¯æ–‡æ¡£é¡¹ç›®  
**åé¦ˆ**: æ¬¢è¿é€šè¿‡GitHub Issuesæä¾›å»ºè®®

**ä¸‹ä¸€æ­¥é˜…è¯»**:

- [æŠ½è±¡è§£é‡Šç†è®º](06.7-æŠ½è±¡è§£é‡Šç†è®º.md) - é™æ€åˆ†æçš„æ•°å­¦åŸºç¡€
- [WASMç¼–è¯‘è§„èŒƒ](../01-æŠ€æœ¯è§„èŒƒ/01.3-WASMç¼–è¯‘è§„èŒƒ.md) - OPA WASMç¼–è¯‘å®è·µ
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../08-æœ€ä½³å®è·µ/08.2-æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md) - å®ç”¨ä¼˜åŒ–æŠ€å·§
