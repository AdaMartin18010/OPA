# Rego 形式化语义（Formal Semantics of Rego）

> **更新日期**: 2025年10月20日  
> **状态**: 基于Rego v1.0规范  
> **理论基础**: Datalog + 集合论 + λ演算

---

## 目录

- [Rego 形式化语义（Formal Semantics of Rego）](#rego-形式化语义formal-semantics-of-rego)
  - [目录](#目录)
  - [1. 语法域定义](#1-语法域定义)
    - [1.1 基本域（Basic Domains）](#11-基本域basic-domains)
    - [1.2 值域（Value Domain）](#12-值域value-domain)
    - [1.3 项（Terms）](#13-项terms)
    - [1.4 表达式（Expressions）](#14-表达式expressions)
    - [1.5 规则（Rules）](#15-规则rules)
  - [2. 抽象语法树（AST）](#2-抽象语法树ast)
    - [2.1 AST节点定义](#21-ast节点定义)
    - [2.2 AST转换规则](#22-ast转换规则)
  - [3. 类型系统](#3-类型系统)
    - [3.1 类型定义](#31-类型定义)
    - [3.2 类型推导规则](#32-类型推导规则)
    - [3.3 类型安全定理](#33-类型安全定理)
  - [4. 操作语义（Operational Semantics）](#4-操作语义operational-semantics)
    - [4.1 小步语义（Small-Step）](#41-小步语义small-step)
    - [4.2 统一（Unification）](#42-统一unification)
    - [4.3 赋值（Assignment）](#43-赋值assignment)
    - [4.4 比较（Comparison）](#44-比较comparison)
    - [4.5 连接（Conjunction）](#45-连接conjunction)
    - [4.6 否定（Negation）](#46-否定negation)
  - [5. 求值模型（Evaluation Model）](#5-求值模型evaluation-model)
    - [5.1 自顶向下求值](#51-自顶向下求值)
    - [5.2 规则求值](#52-规则求值)
    - [5.3 推导式求值](#53-推导式求值)
  - [6. 正确性定理](#6-正确性定理)
    - [6.1 确定性定理](#61-确定性定理)
    - [6.2 完备性定理](#62-完备性定理)
    - [6.3 可靠性定理](#63-可靠性定理)
  - [7. 复杂度分析](#7-复杂度分析)
    - [7.1 查询复杂度](#71-查询复杂度)
    - [7.2 统一复杂度](#72-统一复杂度)
    - [7.3 索引优化](#73-索引优化)
    - [7.4 部分求值优化](#74-部分求值优化)
  - [附录 A: 形式化符号表](#附录-a-形式化符号表)
  - [附录 B: 示例推导](#附录-b-示例推导)
    - [示例：规则求值推导](#示例规则求值推导)
  - [附录 C: 参考文献](#附录-c-参考文献)

---

## 1. 语法域定义

### 1.1 基本域（Basic Domains）

```text
标识符  x, y, z ∈ Var                    (变量空间)
常量    c ∈ Const = Bool ∪ Num ∪ Str    (常量空间)
路径    p ∈ Path = Var · (Str | Var)*    (引用路径)
```

### 1.2 值域（Value Domain）

```haskell
-- 值的归纳定义
data Value = 
    | VBool   Bool              -- 布尔值
    | VNum    Number            -- 数值（IEEE 754）
    | VStr    String            -- 字符串（UTF-8）
    | VNull                     -- 空值
    | VArray  [Value]           -- 数组
    | VObject (Map String Value) -- 对象
    | VSet    (Set Value)       -- 集合
```

**形式化定义**:

```text
V ::= true | false                  (布尔)
    | n ∈ ℝ                         (数值)
    | s ∈ Σ*                        (字符串，Σ=字符集)
    | null                          (空)
    | [V₁, V₂, ..., Vₙ]            (数组)
    | {k₁: V₁, ..., kₙ: Vₙ}       (对象, kᵢ ∈ Str)
    | {V₁, V₂, ..., Vₙ}            (集合)
```

### 1.3 项（Terms）

```text
t ∈ Term ::= 
    | x                             (变量)
    | V                             (值)
    | t.k                           (对象访问)
    | t[i]                          (数组/对象索引)
    | [t | body]                    (数组推导)
    | {t | body}                    (集合推导)
    | {k: v | body}                 (对象推导)
    | f(t₁, ..., tₙ)                (函数调用)
```

### 1.4 表达式（Expressions）

```text
e ∈ Expr ::=
    | t₁ = t₂                       (统一)
    | t₁ := t₂                      (赋值)
    | t₁ == t₂                      (相等比较)
    | t₁ != t₂                      (不等比较)
    | t₁ < t₂                       (小于)
    | t₁ > t₂                       (大于)
    | e₁; e₂                        (连接，AND)
    | some x in t                   (存在量化)
    | every x in t { body }         (全称量化)
    | not e                         (否定)
```

### 1.5 规则（Rules）

```text
r ∈ Rule ::= 
    head :- body                    (蕴涵式)
    
head ∈ Head ::= 
    | p                             (完全规则)
    | p[k]                          (部分规则-对象)
    | p[k] := v                     (部分规则-赋值)
    
body ∈ Body ::= 
    | e₁, e₂, ..., eₙ               (表达式序列，逗号=AND)
    | { e₁ | e₂ | ... | eₙ }        (选择，管道=OR)
```

---

## 2. 抽象语法树（AST）

### 2.1 AST节点定义

```typescript
// TypeScript风格的类型定义

type AST = Module

interface Module {
    package: Package
    imports: Import[]
    rules: Rule[]
}

interface Rule {
    head: Head
    body: Body
    location: Location
}

interface Head {
    name: Ref
    key?: Term
    value?: Term
}

interface Body {
    expressions: Expr[]
}

type Expr = 
    | BinaryExpr
    | UnaryExpr
    | TermExpr
    | ComprehensionExpr

interface BinaryExpr {
    operator: '=' | ':=' | '==' | '!=' | '<' | '>' | '+' | '-' | '*' | '/'
    left: Term
    right: Term
}

interface Ref {
    path: Term[]  // 如 data.users[i].roles
}
```

### 2.2 AST转换规则

**源码 → AST**:

```rego
# 源码
allow if {
    input.method == "GET"
    input.user.role == "admin"
}
```

**对应AST**（简化表示）:

```json
{
  "type": "Rule",
  "head": {
    "name": {"path": ["allow"]},
    "value": true
  },
  "body": [
    {
      "type": "BinaryExpr",
      "operator": "==",
      "left": {"ref": ["input", "method"]},
      "right": {"value": "GET"}
    },
    {
      "type": "BinaryExpr",
      "operator": "==",
      "left": {"ref": ["input", "user", "role"]},
      "right": {"value": "admin"}
    }
  ]
}
```

---

## 3. 类型系统

### 3.1 类型定义

```text
τ ∈ Type ::=
    | Boolean                       (布尔类型)
    | Number                        (数值类型)
    | String                        (字符串类型)
    | Null                          (空类型)
    | Array<τ>                      (数组类型)
    | Object<String, τ>             (对象类型)
    | Set<τ>                        (集合类型)
    | τ₁ | τ₂                       (联合类型)
    | Any                           (任意类型)
```

### 3.2 类型推导规则

**变量类型**:

```text
Γ(x) = τ
─────────── (T-Var)
Γ ⊢ x : τ
```

**字面量类型**:

```text
────────────────── (T-Bool)
Γ ⊢ true : Boolean


────────────── (T-Num)
Γ ⊢ 42 : Number


────────────────── (T-Str)
Γ ⊢ "abc" : String
```

**数组类型**:

```text
Γ ⊢ t₁ : τ    Γ ⊢ t₂ : τ    ...    Γ ⊢ tₙ : τ
──────────────────────────────────────────── (T-Array)
        Γ ⊢ [t₁, t₂, ..., tₙ] : Array<τ>
```

**对象类型**:

```text
Γ ⊢ v₁ : τ₁    Γ ⊢ v₂ : τ₂    ...    Γ ⊢ vₙ : τₙ
─────────────────────────────────────────────────────── (T-Object)
    Γ ⊢ {k₁: v₁, k₂: v₂, ..., kₙ: vₙ} : Object<String, τ₁|τ₂|...|τₙ>
```

**函数类型**:

```text
Γ ⊢ t₁ : τ₁    ...    Γ ⊢ tₙ : τₙ    f : (τ₁, ..., τₙ) → τ
──────────────────────────────────────────────────────────── (T-Call)
                Γ ⊢ f(t₁, ..., tₙ) : τ
```

### 3.3 类型安全定理

**定理 3.1 (Progress)**: 如果 `⊢ e : τ` 且 `e` 不是值，则存在 `e'` 使得 `e → e'`。

**定理 3.2 (Preservation)**: 如果 `Γ ⊢ e : τ` 且 `e → e'`，则 `Γ ⊢ e' : τ`。

**证明**: 对表达式结构归纳（见附录A）。

---

## 4. 操作语义（Operational Semantics）

### 4.1 小步语义（Small-Step）

**求值配置**:

```text
⟨e, σ⟩ → ⟨e', σ'⟩
```

- `e`: 当前表达式
- `σ`: 环境（Var → Value）
- `e'`: 后继表达式
- `σ'`: 更新后的环境

### 4.2 统一（Unification）

**规则 (E-Unify-Var)**:

```text
σ(x) = ⊥    unify(v₁, v₂) = v
──────────────────────────────────
⟨x = v, σ⟩ → ⟨true, σ[x ↦ v]⟩
```

**规则 (E-Unify-Val)**:

```text
v₁ == v₂
─────────────────────
⟨v₁ = v₂, σ⟩ → ⟨true, σ⟩
```

**规则 (E-Unify-Array)**:

```text
|arr₁| = |arr₂| = n
∀i ∈ [1..n]: ⟨arr₁[i] = arr₂[i], σᵢ⟩ → ⟨true, σᵢ₊₁⟩
────────────────────────────────────────────────────
⟨[arr₁] = [arr₂], σ₁⟩ → ⟨true, σₙ₊₁⟩
```

### 4.3 赋值（Assignment）

**规则 (E-Assign)**:

```text
⟨t, σ⟩ ⇓ v
──────────────────────────
⟨x := t, σ⟩ → ⟨true, σ[x ↦ v]⟩
```

**注意**: `:=` 是**局部赋值**，不影响全局数据。

### 4.4 比较（Comparison）

**规则 (E-Eq)**:

```text
⟨t₁, σ⟩ ⇓ v₁    ⟨t₂, σ⟩ ⇓ v₂    v₁ ≡ v₂
────────────────────────────────────────
⟨t₁ == t₂, σ⟩ → ⟨true, σ⟩
```

**值相等定义** (`≡`):

```text
v ≡ v                                               (自反)
true ≡ true,  false ≡ false                         (布尔)
n₁ ≡ n₂  ⟺  |n₁ - n₂| < ε                          (数值，ε=精度)
s₁ ≡ s₂  ⟺  s₁ == s₂ (字符串相等)                  (字符串)
[v₁, ..., vₙ] ≡ [w₁, ..., wₙ]  ⟺  ∀i: vᵢ ≡ wᵢ      (数组)
{k: v} ≡ {k: w}  ⟺  v ≡ w                           (对象)
```

### 4.5 连接（Conjunction）

**规则 (E-And)**:

```text
⟨e₁, σ⟩ → ⟨true, σ'⟩    ⟨e₂, σ'⟩ → ⟨true, σ''⟩
──────────────────────────────────────────────
⟨e₁; e₂, σ⟩ → ⟨true, σ''⟩
```

**短路规则**:

```text
⟨e₁, σ⟩ → ⟨false, σ'⟩
─────────────────────
⟨e₁; e₂, σ⟩ → ⟨false, σ'⟩
```

### 4.6 否定（Negation）

**规则 (E-Not)**:

```text
⟨e, σ⟩ → ⟨false, _⟩
───────────────────
⟨not e, σ⟩ → ⟨true, σ⟩
```

**重要**: `not` 不改变环境（闭世界假设）。

---

## 5. 求值模型（Evaluation Model）

### 5.1 自顶向下求值

**查询求值函数**:

```text
eval : Query × Env × Data → Set⟨Binding⟩

eval(q, σ, D) = {θ | σ ⊢ q ⇓ θ ∧ consistent(θ, D)}
```

**算法流程**:

```python
def eval_query(query, env, data):
    if isinstance(query, Term):
        return eval_term(query, env, data)
    
    elif isinstance(query, Equality):  # t1 = t2
        v1 = eval_term(query.left, env, data)
        v2 = eval_term(query.right, env, data)
        bindings = unify(v1, v2)
        return {env.extend(b) for b in bindings}
    
    elif isinstance(query, Conjunction):  # e1; e2
        results = set()
        for env1 in eval_query(query.left, env, data):
            for env2 in eval_query(query.right, env1, data):
                results.add(env2)
        return results
    
    elif isinstance(query, Disjunction):  # e1 | e2
        results1 = eval_query(query.left, env, data)
        results2 = eval_query(query.right, env, data)
        return results1.union(results2)
    
    elif isinstance(query, Negation):  # not e
        if eval_query(query.body, env, data):
            return set()  # 失败
        else:
            return {env}  # 成功（但不扩展绑定）
```

### 5.2 规则求值

**规则调用**:

```text
eval_rule : Rule × Env × Data → Set⟨Value⟩

eval_rule(head :- body, σ, D) = 
    {σ'(head) | σ' ∈ eval(body, σ, D)}
```

**完全规则**:

```rego
allow := true :- body
```

→ 返回单个值（`true` 或 `undefined`）

**部分规则**:

```rego
users[name] := user :- body
```

→ 返回对象（多个键值对）

### 5.3 推导式求值

**数组推导**:

```text
eval([t | body], σ, D) = 
    [σ'(t) | σ' ∈ eval(body, σ, D)]
```

**集合推导**:

```text
eval({t | body}, σ, D) = 
    {σ'(t) | σ' ∈ eval(body, σ, D)}
```

**示例**:

```rego
# 提取所有管理员名字
admin_names := [u.name | u := data.users[_]; u.role == "admin"]
```

**语义**:

```text
eval(admin_names, ∅, D) = 
    [u.name | u ∈ D.users ∧ u.role = "admin"]
```

---

## 6. 正确性定理

### 6.1 确定性定理

**定理 6.1 (Determinism)**: 对于任意查询 `q`、环境 `σ` 和数据 `D`，求值结果 `eval(q, σ, D)` 是确定的。

**证明**:
通过对查询结构归纳：

1. **基础情况**: 项求值由值域直接确定。
2. **归纳假设**: 假设子查询求值确定。
3. **归纳步骤**:
   - 统一算法的确定性（Robinson 1965）
   - 集合运算的确定性（集合论公理）

**QED** ∎

### 6.2 完备性定理

**定理 6.2 (Completeness)**: 如果存在满足查询 `q` 的绑定 `θ`，则 `θ ∈ eval(q, σ, D)`。

**形式化**:

```text
(∃θ: models(θ, q, D)) ⟹ θ ∈ eval(q, σ, D)
```

**证明**: 见 [Ullman 1988] 关于Datalog完备性证明。

### 6.3 可靠性定理

**定理 6.3 (Soundness)**: 如果 `θ ∈ eval(q, σ, D)`，则 `θ` 满足查询 `q`。

**形式化**:

```text
θ ∈ eval(q, σ, D) ⟹ models(θ, q, D)
```

**证明**: 通过操作语义的保型性（Type Preservation）。

---

## 7. 复杂度分析

### 7.1 查询复杂度

**时间复杂度**:

```text
T(query) = O(|Data| × |Rules| × B^d)
```

- `|Data|`: 数据大小
- `|Rules|`: 规则数量
- `B`: 分支因子
- `d`: 查询深度

**空间复杂度**:

```text
S(query) = O(|Vars| × |Bindings|)
```

### 7.2 统一复杂度

**Robinson统一算法**:

```text
unify(t₁, t₂) = O(min(|t₁|, |t₂|))
```

### 7.3 索引优化

**哈希索引**:

```text
index_lookup : O(1)          # 常数时间
index_build  : O(n log n)    # 建立索引
```

**Trie索引**:

```text
trie_lookup : O(k)           # k=键长度
trie_build  : O(n × k)
```

### 7.4 部分求值优化

**定理 7.1**: 部分求值可将查询复杂度降低到 `O(|Input|)`（数据项提前计算）。

---

## 附录 A: 形式化符号表

| 符号 | 含义 | 领域 |
|------|------|------|
| `Γ` | 类型环境 | 类型系统 |
| `σ` | 值环境（变量绑定） | 求值 |
| `θ` | 替换/统一子 | 统一 |
| `⊢` | 推导关系 | 类型/证明 |
| `⇓` | 大步求值 | 语义 |
| `→` | 小步求值 | 语义 |
| `≡` | 值相等 | 等价 |
| `⊥` | 未定义/失败 | 底类型 |
| `⊤` | 真/成功 | 顶类型 |

---

## 附录 B: 示例推导

### 示例：规则求值推导

**策略**:

```rego
package example

allow if {
    input.method == "GET"
    input.user.role == "admin"
}
```

**输入**:

```json
{
    "method": "GET",
    "user": {"role": "admin"}
}
```

**推导过程**:

```text
σ₀ = {input ↦ {"method": "GET", "user": {"role": "admin"}}}

步骤1: 求值 input.method == "GET"
    ⟨input.method, σ₀⟩ ⇓ "GET"
    ⟨"GET" == "GET", σ₀⟩ → ⟨true, σ₀⟩

步骤2: 求值 input.user.role == "admin"
    ⟨input.user.role, σ₀⟩ ⇓ "admin"
    ⟨"admin" == "admin", σ₀⟩ → ⟨true, σ₀⟩

步骤3: 连接（AND）
    ⟨(步骤1) ; (步骤2), σ₀⟩ → ⟨true, σ₀⟩

步骤4: 规则头
    ⟨allow, σ₀⟩ ⇓ true

结论: allow = true
```

---

## 附录 C: 参考文献

1. **Abiteboul, S., et al.** (1995). *Foundations of Databases*. Addison-Wesley.
2. **Ullman, J. D.** (1988). *Principles of Database and Knowledge-Base Systems*. Computer Science Press.
3. **Robinson, J. A.** (1965). "A Machine-Oriented Logic Based on the Resolution Principle". *JACM*.
4. **Plotkin, G. D.** (2004). "A Structural Approach to Operational Semantics". *JLAP*.
5. **OPA Documentation** (2025). "Policy Language Reference". <https://www.openpolicyagent.org/>

---

**下一篇**: [06.3-求值正确性证明](./06.3-求值正确性证明.md)  
**相关**: [02.2-语义模型](../02-语言模型/02.2-语义模型.md)
