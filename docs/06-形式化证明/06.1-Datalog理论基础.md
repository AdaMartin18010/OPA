# Datalog理论基础（Datalog Theoretical Foundations）

> **更新日期**: 2025年10月21日  
> **理论基础**: 逻辑编程、数据库理论  
> **应用**: Rego语言语义、查询优化  
> **参考**: Classic Datalog论文集

---

## 1. Datalog概述

### 1.1 基本定义

**Datalog = 数据库 + 逻辑**

```text
Datalog特点:
├── 声明式语言
├── 基于Horn子句
├── 无副作用
├── 保证终止
└── 可判定性
```

**语法组成**：

```text
Fact (事实):
  parent(tom, bob).
  parent(bob, ann).

Rule (规则):
  ancestor(X, Y) :- parent(X, Y).
  ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).

Query (查询):
  ?- ancestor(tom, ann).
```

### 1.2 Rego vs Datalog

**对比**：

| 特性 | Datalog | Rego |
|------|---------|------|
| **语法** | Prolog风格 | JSON友好 |
| **数据** | 关系 | JSON文档 |
| **否定** | 分层否定 | 安全否定 |
| **聚合** | 有限支持 | 丰富的内置函数 |
| **类型** | 无类型 | 动态类型 |

**Rego继承自Datalog**：

```text
1. 递归规则
2. 统一求值
3. 非确定性搜索
4. 最小不动点语义
```

---

## 2. 形式化语法

### 2.1 术语（Terms）

```text
术语 t ::= c           (常量: 1, "hello", true)
         | X           (变量: 大写字母开头)
         | f(t₁,...,tₙ) (复合项)

示例:
  常量: 42, "alice", null
  变量: X, User, Result
  复合: person("alice", 30)
```

### 2.2 原子（Atoms）

```text
原子 A ::= p(t₁,...,tₙ)

其中:
  p: 谓词符号
  tᵢ: 术语

示例:
  parent(tom, bob)
  employee(X, "engineering", 100000)
```

### 2.3 子句（Clauses）

**Horn子句**：

```text
子句 C ::= H :- B₁, ..., Bₙ

其中:
  H: 头部（head）- 单个原子
  Bᵢ: 体部（body）- 原子序列

语义: H ← B₁ ∧ ... ∧ Bₙ
```

**示例**：

```datalog
% 事实（无体部的子句）
parent(tom, bob).

% 规则
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).

% 查询
?- ancestor(tom, Z).
```

---

## 3. 语义理论

### 3.1 Herbrand语义

**Herbrand宇宙**：

```text
给定程序P，Herbrand宇宙U_P包含：
  - P中所有常量
  - 所有由P中函数符号构造的项

示例:
P = { p(a). p(f(X)) :- p(X). }

U_P = {a, f(a), f(f(a)), ...}
```

**Herbrand基**：

```text
H_P = P中所有谓词符号在U_P上的所有可能实例

示例:
P = { parent(tom, bob). ancestor(X,Y) :- parent(X,Y). }

H_P = {
  parent(tom, bob),
  parent(tom, tom),
  ancestor(tom, bob),
  ancestor(bob, tom),
  ...
}
```

### 3.2 最小模型

**模型定义**：

```text
模型 M ⊆ H_P 满足：
  对所有规则 H :- B₁, ..., Bₙ
  如果 B₁, ..., Bₙ ∈ M，则 H ∈ M

最小模型 = 最小的满足所有规则的Herbrand解释
```

**示例**：

```datalog
p(a).
p(b).
q(X) :- p(X).

最小模型 M = {p(a), p(b), q(a), q(b)}
```

### 3.3 不动点语义

**T_P算子**：

```text
T_P: 2^H_P → 2^H_P

T_P(I) = {H | H :- B₁,...,Bₙ ∈ ground(P), B₁,...,Bₙ ∈ I}

性质:
  1. 单调性: I ⊆ J ⇒ T_P(I) ⊆ T_P(J)
  2. 连续性
  3. 有最小不动点 lfp(T_P)
```

**定理**：

```text
M是P的最小模型 ⟺ M = lfp(T_P)
```

**计算示例**：

```datalog
p(a).
q(X) :- p(X).

迭代:
I₀ = ∅
I₁ = T_P(I₀) = {p(a)}
I₂ = T_P(I₁) = {p(a), q(a)}
I₃ = T_P(I₂) = {p(a), q(a)}  // 不动点

lfp(T_P) = {p(a), q(a)}
```

---

## 4. 否定语义

### 4.1 分层否定（Stratified Negation）

**分层定义**：

```text
程序P是分层的，如果可以分层为P₁, ..., Pₙ，使得：
  - Pᵢ中规则只依赖Pⱼ (j ≤ i)的正原子
  - Pᵢ中规则只否定Pⱼ (j < i)的原子

示例:
P₁: p(a). p(b).
P₂: q(X) :- p(X), not r(X).
P₃: r(X) :- p(X), q(X).
```

**语义**：

```text
逐层计算:
1. 计算M₁ = lfp(T_P₁)
2. 计算M₂ = lfp(T_P₂^{not M₁})
3. ...

最终模型 M = ⋃ Mᵢ
```

### 4.2 完美模型语义（Perfect Model Semantics）

**定义**：

```text
对分层程序P:
  完美模型 = 逐层构建的唯一最小模型

性质:
  1. 唯一性
  2. 直观性
  3. 可计算性
```

---

## 5. 递归

### 5.1 线性递归

```datalog
% 祖先关系
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
```

**计算**：

```text
数据: parent(a,b), parent(b,c), parent(c,d)

迭代:
I₀ = {parent(a,b), parent(b,c), parent(c,d)}
I₁ = I₀ ∪ {ancestor(a,b), ancestor(b,c), ancestor(c,d)}
I₂ = I₁ ∪ {ancestor(a,c), ancestor(b,d)}
I₃ = I₂ ∪ {ancestor(a,d)}
I₄ = I₃  // 不动点
```

### 5.2 互递归

```datalog
even(0).
even(X) :- X > 0, Y = X - 1, odd(Y).

odd(X) :- X > 0, Y = X - 1, even(Y).
```

---

## 6. 复杂度分析

### 6.1 数据复杂度

**定义**：

```text
数据复杂度 = 固定程序P，变化数据库D时的复杂度

定理: Datalog的数据复杂度是P（多项式）
```

**证明思路**：

```text
1. 程序大小固定 → 常量
2. Herbrand基大小 ≤ |D|^k (k是最大元数)
3. 不动点迭代 ≤ |H_P|次
4. 总复杂度: O(|D|^k)，多项式
```

### 6.2 组合复杂度

**定义**：

```text
组合复杂度 = 同时考虑P和D的大小

定理: Datalog的组合复杂度是EXPTIME完全的
```

---

## 7. Rego中的Datalog

### 7.1 对应关系

**Datalog**：

```datalog
% 规则
allow(User) :-
    user(User),
    role(User, Role),
    permission(Role, "admin").

% 查询
?- allow("alice").
```

**Rego**：

```rego
# 规则
allow if {
    some User
    data.users[User]
    role := data.roles[User]
    data.permissions[role] == "admin"
}

# 查询
data.authz.allow
```

### 7.2 扩展特性

**Rego超越Datalog**：

```text
1. JSON数据模型
   └── vs 关系模型

2. 丰富的内置函数
   └── 字符串、数组、加密等

3. 推导
   └── [x | condition]

4. 赋值
   └── x := expr

5. 比较运算符
   └── ==, !=, <, >, <=, >=
```

---

## 8. 查询优化

### 8.1 Magic Sets转换

**目标**：避免计算不相关的事实

**示例**：

```datalog
% 原始程序
reachable(X, Y) :- edge(X, Y).
reachable(X, Z) :- reachable(X, Y), edge(Y, Z).

% 查询: ?- reachable(a, Z).

% Magic Sets转换
magic_reachable(a).
magic_reachable(Y) :- magic_reachable(X), edge(X, Y).

reachable(X, Y) :- magic_reachable(X), edge(X, Y).
reachable(X, Z) :- magic_reachable(X), reachable(X, Y), edge(Y, Z).
```

**效果**：

```text
原始: 计算所有可达性
优化: 只计算从a出发的可达性
```

### 8.2 半朴素求值（Semi-Naive Evaluation）

**思想**：只处理新派生的事实

**算法**：

```text
Δ₀ = EDB
for i = 1, 2, ... do
    Δᵢ = T_P(I_{i-1}) - I_{i-1}  // 只计算新事实
    I_i = I_{i-1} ∪ Δᵢ
    if Δᵢ = ∅ then return Iᵢ
```

**优势**：

```text
朴素求值: 每轮重新计算所有事实
半朴素: 每轮只计算新事实

性能提升: 通常2-10x
```

---

## 9. 实践应用

### 9.1 图查询

**传递闭包**：

```datalog
% 边
edge(a, b).
edge(b, c).
edge(c, d).

% 可达性
path(X, Y) :- edge(X, Y).
path(X, Z) :- path(X, Y), edge(Y, Z).

% 查询: 从a可达哪些节点？
?- path(a, Z).
% 结果: Z ∈ {b, c, d}
```

**Rego实现**：

```rego
package graph

edges := {
    "a": ["b"],
    "b": ["c"],
    "c": ["d"]
}

reachable[node] if {
    start := "a"
    walk_graph(start, node)
}

walk_graph(current, dest) if {
    dest in edges[current]
}

walk_graph(current, dest) if {
    next in edges[current]
    walk_graph(next, dest)
}
```

### 9.2 关系代数

**SQL到Datalog**：

```sql
-- SQL
SELECT u.name
FROM users u, roles r
WHERE u.role_id = r.id
  AND r.name = 'admin'
```

**Datalog**：

```datalog
result(Name) :-
    users(Name, RoleId),
    roles(RoleId, "admin").
```

---

## 10. 理论意义

### 10.1 为什么研究Datalog？

```text
1. 理论优雅
   └── 简洁的语法和语义

2. 可判定性
   └── 保证查询终止

3. 优化理论成熟
   └── 数十年研究积累

4. 实践应用广泛
   └── 数据库、静态分析、策略语言
```

### 10.2 对Rego的影响

```text
1. 语义基础
   └── Rego的形式化语义基于Datalog

2. 查询策略
   └── Top-Down求值借鉴Prolog/Datalog

3. 优化技术
   └── 索引、Magic Sets等

4. 安全性保证
   └── 分层否定确保终止性
```

---

**相关文档**：

- [Rego形式化语义](./06.2-Rego形式化语义.md)
- [Top-Down求值器](../03-实现架构/03.4-Top-Down求值器.md)

**参考文献**：

- Abiteboul, S., Hull, R., Vianu, V. (1995). *Foundations of Databases*
- Ullman, J. D. (1989). *Principles of Database and Knowledge-Base Systems*
- Ceri, S., Gottlob, G., Tanca, L. (1989). *What You Always Wanted to Know About Datalog (And Never Dared to Ask)*

