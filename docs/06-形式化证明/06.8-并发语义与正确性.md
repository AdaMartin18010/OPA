# 并发语义与正确性

> **文档类型**: 形式化并发理论  
> **理论领域**: 并发语义、同步机制、正确性证明  
> **适用读者**: 并发系统专家、分布式系统开发者、理论研究者  
> **先修知识**: [一阶逻辑](06.3-命题逻辑与一阶逻辑基础.md)、[求值算法](06.4-求值算法正确性证明.md)  
> **最后更新**: 2025年10月21日  
> **文档状态**: ✅ Phase 1.2 - 并发理论

---

## 📐 并发理论框架

> **本文档目标**:
>
> - ✅ 形式化并发求值模型
> - ✅ 分析数据竞争和同步
> - ✅ 证明线程安全性
> - ✅ 研究分布式一致性
> - ✅ 应用于OPA并发场景
>
> **核心概念**:
>
> - **并发模型**: 交错语义、真并发语义
> - **同步机制**: 锁、消息传递、STM
> - **数据竞争**: 同时访问共享数据
> - **线程安全**: 并发执行的正确性
> - **一致性**: 分布式系统的状态协调
>
> **实际价值**:
>
> - OPA Server的并发请求处理
> - 分布式策略决策一致性
> - 缓存一致性协议
> - 无锁数据结构设计
> - 性能与正确性权衡

---

## 目录

- [并发语义与正确性](#并发语义与正确性)
  - [📐 并发理论框架](#-并发理论框架)
  - [目录](#目录)
  - [1. 并发模型](#1-并发模型)
    - [1.1 交错语义](#11-交错语义)
      - [1.1.1 定义](#111-定义)
      - [1.1.2 交错语义规则](#112-交错语义规则)
    - [1.2 真并发语义](#12-真并发语义)
      - [1.2.1 偏序语义](#121-偏序语义)
      - [1.2.2 Petri网](#122-petri网)
    - [1.3 内存模型](#13-内存模型)
      - [1.3.1 顺序一致性 (SC)](#131-顺序一致性-sc)
      - [1.3.2 Total Store Order (TSO)](#132-total-store-order-tso)
      - [1.3.3 Release/Acquire语义](#133-releaseacquire语义)
  - [2. 数据竞争分析](#2-数据竞争分析)
    - [2.1 竞争条件定义](#21-竞争条件定义)
    - [2.2 Happens-Before关系](#22-happens-before关系)
    - [2.3 竞争检测](#23-竞争检测)
      - [2.3.1 Lockset算法](#231-lockset算法)
      - [2.3.2 Happens-Before算法](#232-happens-before算法)
  - [3. 同步机制](#3-同步机制)
    - [3.1 互斥锁](#31-互斥锁)
      - [3.1.1 语义](#311-语义)
      - [3.1.2 正确性](#312-正确性)
    - [3.2 读写锁](#32-读写锁)
      - [3.2.1 语义](#321-语义)
      - [3.2.2 性能](#322-性能)
    - [3.3 消息传递](#33-消息传递)
      - [3.3.1 Channel语义](#331-channel语义)
    - [3.4 软件事务内存](#34-软件事务内存)
      - [3.4.1 概念](#341-概念)
      - [3.4.2 实现](#342-实现)
  - [4. 线程安全性证明](#4-线程安全性证明)
    - [4.1 不变量](#41-不变量)
    - [4.2 串行化](#42-串行化)
    - [4.3 线性一致性](#43-线性一致性)
  - [5. 分布式一致性](#5-分布式一致性)
    - [5.1 CAP定理](#51-cap定理)
    - [5.2 一致性模型](#52-一致性模型)
      - [5.2.1 强一致性](#521-强一致性)
      - [5.2.2 最终一致性](#522-最终一致性)
      - [5.2.3 因果一致性](#523-因果一致性)
    - [5.3 共识算法](#53-共识算法)
      - [5.3.1 Raft](#531-raft)
      - [5.3.2 Paxos](#532-paxos)
  - [6. OPA并发场景](#6-opa并发场景)
    - [6.1 并发查询处理](#61-并发查询处理)
    - [6.2 数据加载与更新](#62-数据加载与更新)
    - [6.3 缓存一致性](#63-缓存一致性)
    - [6.4 分布式决策](#64-分布式决策)
  - [7. 性能与正确性](#7-性能与正确性)
    - [7.1 无锁数据结构](#71-无锁数据结构)
    - [7.2 锁粒度选择](#72-锁粒度选择)
    - [7.3 NUMA优化](#73-numa优化)
  - [附录](#附录)
    - [A. 术语对照](#a-术语对照)
    - [B. 核心定理速查](#b-核心定理速查)
    - [C. OPA并发总结](#c-opa并发总结)
    - [D. 参考文献](#d-参考文献)

---

## 1. 并发模型

### 1.1 交错语义

#### 1.1.1 定义

**交错语义** (Interleaving Semantics):

```text
并发执行 = 所有可能的串行执行顺序的集合
```

**形式化**:

```text
设两个线程 T₁, T₂
  T₁: a; b
  T₂: c; d

可能的交错:
  a; b; c; d
  a; c; b; d
  a; c; d; b
  c; a; b; d
  c; a; d; b
  c; d; a; b
```

#### 1.1.2 交错语义规则

**操作语义**:

```text
────────────────────  (Step-Left)
(S₁ || S₂, σ) → (S₁' || S₂, σ')
  if (S₁, σ) → (S₁', σ')

────────────────────  (Step-Right)
(S₁ || S₂, σ) → (S₁ || S₂', σ')
  if (S₂, σ) → (S₂', σ')
```

**示例**:

```go
// Go代码
var x int = 0

// 线程1
go func() {
    x = 1  // (1)
    y = x  // (2)
}()

// 线程2
go func() {
    x = 2  // (3)
}()

// 可能的执行顺序
// (1) (2) (3): y = 1, x = 2
// (1) (3) (2): y = 2, x = 2
// (3) (1) (2): y = 1, x = 1
```

### 1.2 真并发语义

#### 1.2.1 偏序语义

**定义**: 用偏序关系表示因果关系

```text
Event = {e₁, e₂, ...}  (事件集合)
≺ : Event × Event      (因果先序关系)

性质:
1. 非自反: e ⊀ e
2. 反对称: e₁ ≺ e₂ ∧ e₂ ≺ e₁ ⟹ e₁ = e₂
3. 传递: e₁ ≺ e₂ ∧ e₂ ≺ e₃ ⟹ e₁ ≺ e₃
```

**并发关系**:

```text
e₁ || e₂  ⟺  e₁ ⊀ e₂ ∧ e₂ ⊀ e₁
```

**示例**:

```text
线程1: a → b
线程2: c → d

偏序:
  a ≺ b
  c ≺ d
  a || c, a || d, b || c, b || d
```

#### 1.2.2 Petri网

**定义**: (P, T, F)

- P: 位置集（状态）
- T: 变迁集（动作）
- F: 流关系（边）

**触发规则**:

```text
变迁 t 可触发 ⟺ ∀p ∈ •t. M(p) ≥ F(p,t)
```

### 1.3 内存模型

#### 1.3.1 顺序一致性 (SC)

**定义** (Lamport 1979):

```text
程序执行的结果等同于所有处理器的操作
以某种顺序交错执行，且每个处理器的
操作按程序顺序出现。
```

**形式化**:

```text
∀线程 T. T中操作保持程序顺序
∃全局顺序 ≺_global. 所有操作的总序
```

#### 1.3.2 Total Store Order (TSO)

**特点**: 写操作先进入Store Buffer

```text
CPU1       CPU2
 |          |
 ↓          ↓
StoreBuffer StoreBuffer
 |          |
 └────┬─────┘
      ↓
   Memory
```

**影响**: Store-Load可以重排序

#### 1.3.3 Release/Acquire语义

**Release**: 写操作对其他线程可见
**Acquire**: 读操作看到最新写入

```go
// Go atomic操作
atomic.StoreInt32(&flag, 1)  // Release
value := atomic.LoadInt32(&flag)  // Acquire
```

---

## 2. 数据竞争分析

### 2.1 竞争条件定义

**定义 2.1** (数据竞争 Data Race)

两个操作存在数据竞争，如果：

1. 访问同一内存位置
2. 至少一个是写操作
3. 并发执行（无happens-before关系）

**形式化**:

```text
Race(e₁, e₂) ⟺
  loc(e₁) = loc(e₂) ∧
  (write(e₁) ∨ write(e₂)) ∧
  ¬(e₁ ≺ e₂) ∧ ¬(e₂ ≺ e₁)
```

**示例**:

```go
var x int = 0

// 线程1
x = 1  // 写

// 线程2
y = x  // 读

// 竞争！(x被并发读写)
```

### 2.2 Happens-Before关系

**定义 2.2** (Happens-Before ≺_hb)

事件e₁ happens-before e₂，记作 e₁ ≺_hb e₂，如果：

1. **程序顺序**: 同一线程中e₁在e₂之前
2. **同步顺序**: e₁是release，e₂是对应的acquire
3. **传递性**: e₁ ≺_hb e₂ ∧ e₂ ≺_hb e₃ ⟹ e₁ ≺_hb e₃

**规则**:

```text
(HB-PO)   same_thread(e₁, e₂) ∧ before(e₁, e₂)
          ────────────────────────────────────
                    e₁ ≺_hb e₂

(HB-Sync) release(e₁, m) ∧ acquire(e₂, m)
          ────────────────────────────────
                    e₁ ≺_hb e₂

(HB-Trans) e₁ ≺_hb e₂    e₂ ≺_hb e₃
           ──────────────────────────
                 e₁ ≺_hb e₃
```

**定理 2.1** (无竞争保证)

如果程序无数据竞争，则其行为等价于某个顺序一致执行。

### 2.3 竞争检测

#### 2.3.1 Lockset算法

**思想**: 跟踪保护每个变量的锁集合

```python
def lockset_check():
    for each variable v:
        locks[v] = all_locks  # 初始：所有锁
    
    for each access to v in thread t:
        locks[v] = locks[v] ∩ held_locks[t]
        
        if locks[v] == ∅:
            report_race(v)
```

**示例**:

```go
var mu sync.Mutex
var x int

// 线程1
mu.Lock()
x = 1
mu.Unlock()

// 线程2
x = 2  // 竞争！(无锁保护)
```

#### 2.3.2 Happens-Before算法

**Vector Clock算法**:

```python
VectorClock = [c₁, c₂, ..., cₙ]  # n个线程

def increment_clock(thread_id):
    VC[thread_id][thread_id] += 1

def send_message(thread_i, thread_j):
    VC[thread_j] = max(VC[thread_i], VC[thread_j])
    VC[thread_j][thread_j] += 1

def happens_before(VC₁, VC₂):
    return all(VC₁[i] <= VC₂[i] for i in range(n))
```

---

## 3. 同步机制

### 3.1 互斥锁

#### 3.1.1 语义

**操作**:

```text
Lock(m):   获取锁m（阻塞直到成功）
Unlock(m): 释放锁m
```

**不变量**:

```text
∀时刻t. |{线程 | 持有锁m}| ≤ 1
```

**临界区**:

```go
mu.Lock()
// 临界区：只有一个线程执行
x = x + 1
mu.Unlock()
```

#### 3.1.2 正确性

**定理 3.1** (互斥性)

如果所有对共享变量的访问都由同一个锁保护，则无数据竞争。

**证明**:

```text
设两个访问 e₁, e₂ 都访问变量 v

如果 e₁ 和 e₂ 都持有锁 m:
  e₁: Lock(m) ... access v ... Unlock(m)
  e₂: Lock(m) ... access v ... Unlock(m)

则要么 Unlock_e₁ ≺_hb Lock_e₂ (e₁先)
     或 Unlock_e₂ ≺_hb Lock_e₁ (e₂先)

因此 e₁ ≺_hb e₂ 或 e₂ ≺_hb e₁

即：无并发，无竞争  ✓
```

### 3.2 读写锁

#### 3.2.1 语义

**操作**:

```text
RLock(rw):  获取读锁（允许多个读者）
RUnlock(rw): 释放读锁
Lock(rw):   获取写锁（独占）
Unlock(rw):  释放写锁
```

**不变量**:

```text
∀时刻t. 
  (|readers| > 0 ∧ |writers| = 0) ∨
  (|readers| = 0 ∧ |writers| ≤ 1)
```

#### 3.2.2 性能

**适用场景**: 读多写少

```go
var rwmu sync.RWMutex
var cache map[string]interface{}

// 读操作（并发）
func Get(key string) interface{} {
    rwmu.RLock()
    defer rwmu.RUnlock()
    return cache[key]
}

// 写操作（独占）
func Set(key string, val interface{}) {
    rwmu.Lock()
    defer rwmu.Unlock()
    cache[key] = val
}
```

### 3.3 消息传递

#### 3.3.1 Channel语义

**操作**:

```text
ch := make(chan T)  // 创建channel
ch <- v             // 发送（阻塞）
v := <-ch           // 接收（阻塞）
```

**Happens-Before规则**:

```text
send(ch, v) ≺_hb receive(ch, v)
```

**示例**:

```go
ch := make(chan int)

go func() {
    x = 1       // (1)
    ch <- 42    // (2) send
}()

<-ch            // (3) receive
y = x           // (4)

// (1) ≺_hb (2) ≺_hb (3) ≺_hb (4)
// 因此 y == 1 保证
```

### 3.4 软件事务内存

#### 3.4.1 概念

**STM**: 将内存操作组织为事务

```text
atomic {
    // 事务体
    // 要么全部成功，要么全部回滚
}
```

**性质**:

- 原子性（Atomicity）
- 一致性（Consistency）
- 隔离性（Isolation）

#### 3.4.2 实现

**乐观并发控制**:

```python
def stm_transaction(txn_body):
    read_set = {}
    write_set = {}
    
    # 执行阶段
    result = txn_body(read_set, write_set)
    
    # 验证阶段
    if validate(read_set):
        # 提交
        apply(write_set)
        return result
    else:
        # 回滚重试
        return stm_transaction(txn_body)

def validate(read_set):
    for (var, version) in read_set:
        if global_version[var] != version:
            return False  # 冲突
    return True
```

---

## 4. 线程安全性证明

### 4.1 不变量

**定义 4.1** (并发不变量)

谓词 I(σ) 是并发不变量，如果：

```text
∀初始状态 σ₀. I(σ₀) ∧
∀转移 σ → σ'. I(σ) ⟹ I(σ')
```

**示例**:

```go
// 不变量: balance >= 0
type Account struct {
    mu      sync.Mutex
    balance int
}

func (a *Account) Withdraw(amount int) bool {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if a.balance >= amount {  // 检查不变量
        a.balance -= amount
        return true
    }
    return false
}
```

### 4.2 串行化

**定义 4.2** (串行化 Serializability)

并发执行等价于某个串行执行。

**冲突串行化**:

```text
两个操作冲突 ⟺ 
  访问同一对象 ∧ 至少一个是写

串行化 ⟺ 冲突图无环
```

**定理 4.1** (Two-Phase Locking保证串行化)

如果所有事务遵循2PL协议，则执行是串行化的。

**证明概要**:

```text
2PL = 增长阶段(只获取锁) + 收缩阶段(只释放锁)

冲突图:
  T_i → T_j 如果 T_i 先释放锁 L, T_j 后获取锁 L

2PL保证无环:
  假设环 T₁ → T₂ → ... → Tₙ → T₁
  则 T₁ 在 T₂ 之前释放某锁
     T₂ 在 T₃ 之前释放某锁
     ...
     Tₙ 在 T₁ 之前释放某锁
  
  矛盾！(时间不能成环)
  
因此无环，串行化  ✓
```

### 4.3 线性一致性

**定义 4.3** (Linearizability)

每个操作看起来在某个原子时刻瞬间完成。

**形式化**:

```text
∃线性化点 lin(op) ∈ [start(op), end(op)]
使得按 lin(op) 排序的执行等价于串行执行
```

**示例**:

```text
线程1: write(x, 1) [────────]
              线程2:     read(x) [──] → 1

线性化点: write在read之前
串行执行: write(x,1); read(x) → 1  ✓
```

---

## 5. 分布式一致性

### 5.1 CAP定理

**定理 5.1** (CAP定理 - Brewer 2000)

分布式系统最多同时满足以下三个中的两个：

- **Consistency**: 一致性（所有节点看到相同数据）
- **Availability**: 可用性（请求总能得到响应）
- **Partition tolerance**: 分区容错（网络分区时系统仍可用）

**证明概要**:

```text
假设网络分区将节点分为 G₁ 和 G₂

情况1: 选择 CP (一致性 + 分区容错)
  分区时，拒绝某些请求 → 不满足 A

情况2: 选择 AP (可用性 + 分区容错)
  分区时，两侧独立接受写入 → 不满足 C

情况3: 选择 CA (一致性 + 可用性)
  必须拒绝分区 → 不满足 P

因此最多选2个  ✓
```

### 5.2 一致性模型

#### 5.2.1 强一致性

**线性一致性** (Linearizability):

- 最强的一致性
- 等价于单机执行

#### 5.2.2 最终一致性

**定义**: 如果停止更新，最终所有副本收敛到相同值

**示例**: DNS, Cassandra

#### 5.2.3 因果一致性

**定义**: 因果相关的操作按顺序，无关操作可并发

```text
write(x, 1)  write(y, 2)
    ↓           ↓
read(x) → 1  read(y) → 2
    ↓
read(y) → ?  (可以是旧值或新值)
```

### 5.3 共识算法

#### 5.3.1 Raft

**关键概念**:

- Leader选举
- 日志复制
- 安全性保证

**不变量**:

- 选举安全性：每个任期最多一个Leader
- 日志匹配：相同索引和任期的日志条目相同
- Leader完整性：已提交的日志不会丢失

#### 5.3.2 Paxos

**阶段**:

1. Prepare: 提议者询问接受者
2. Promise: 接受者承诺
3. Accept: 提议者提交值
4. Learn: 学习者学习已选择的值

**定理**: Paxos保证安全性（不违背一致性）

---

## 6. OPA并发场景

### 6.1 并发查询处理

**场景**: OPA Server同时处理多个查询请求

```go
// OPA Server伪代码
func (s *Server) Query(ctx context.Context, query string) Result {
    // 只读数据访问（并发安全）
    data := s.store.Read()  // RLock
    
    // 独立求值（每个请求独立状态）
    eval := NewEvaluator(query, data)
    result := eval.Eval()
    
    return result
}
```

**线程安全性**:

- `store.Read()` 使用读锁（允许并发）
- 求值器状态独立（无共享）
- 结果返回前无副作用

### 6.2 数据加载与更新

**挑战**: 数据更新时如何保证查询一致性？

**解决方案**: Copy-On-Write

```go
type Store struct {
    mu   sync.RWMutex
    data *immutable.Map  // 不可变数据结构
}

func (s *Store) Update(newData Data) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 创建新版本（COW）
    s.data = s.data.Set(newData.Key, newData.Value)
}

func (s *Store) Read() *immutable.Map {
    s.mu.RLock()
    defer s.mu.RUnlock()
    return s.data  // 返回不可变快照
}
```

**优势**:

- 读操作无需拷贝（指针共享）
- 写操作不影响正在进行的读
- 最终一致性

### 6.3 缓存一致性

**问题**: 编译后的策略缓存如何失效？

**策略**: Write-Through + 版本号

```go
type Cache struct {
    mu       sync.Mutex
    entries  map[string]*CacheEntry
    version  int64
}

type CacheEntry struct {
    compiled *Policy
    version  int64
}

func (c *Cache) Get(key string, storeVer int64) *Policy {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    entry := c.entries[key]
    if entry != nil && entry.version == storeVer {
        return entry.compiled  // 缓存命中
    }
    return nil  // 缓存失效
}

func (c *Cache) Put(key string, policy *Policy, ver int64) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.entries[key] = &CacheEntry{
        compiled: policy,
        version:  ver,
    }
}
```

### 6.4 分布式决策

**场景**: 多个OPA实例做分布式授权决策

**挑战**:

- 数据同步延迟
- 部分失败
- 网络分区

**解决方案**:

1. **最终一致性** + 幂等决策
2. **Quorum读写**: 多数派一致
3. **分布式跟踪**: 关联决策链

**示例**: 分布式限流

```text
节点1: 允许100 QPS
节点2: 允许100 QPS
节点3: 允许100 QPS

问题: 总QPS可能超过300
解决: 共享计数器 + Raft共识
```

---

## 7. 性能与正确性

### 7.1 无锁数据结构

**CAS操作** (Compare-And-Swap):

```go
func CAS(addr *int64, old, new int64) bool {
    // 原子操作
    if *addr == old {
        *addr = new
        return true
    }
    return false
}
```

**无锁栈**:

```go
type LockFreeStack struct {
    head unsafe.Pointer  // *Node
}

func (s *LockFreeStack) Push(value interface{}) {
    node := &Node{value: value}
    for {
        old := atomic.LoadPointer(&s.head)
        node.next = (*Node)(old)
        if atomic.CompareAndSwapPointer(&s.head, old, unsafe.Pointer(node)) {
            return
        }
        // CAS失败，重试
    }
}
```

**优势**: 无锁竞争开销  
**劣势**: ABA问题、复杂度高

### 7.2 锁粒度选择

**权衡**:

| 锁粒度 | 并发度 | 开销 | 复杂度 |
|-------|-------|-----|-------|
| 全局锁 | 低 | 低 | 低 |
| 分段锁 | 中 | 中 | 中 |
| 细粒度锁 | 高 | 高 | 高 |
| 无锁 | 最高 | 低 | 最高 |

**最佳实践**:

1. 测量竞争程度
2. 从粗粒度开始
3. 根据profiling细化
4. 避免过早优化

### 7.3 NUMA优化

**NUMA架构** (Non-Uniform Memory Access):

```text
CPU0 ─┬─ LocalMem0
      │
CPU1 ─┼─ LocalMem1  (远程访问慢)
      │
CPU2 ─┼─ LocalMem2
      │
CPU3 ─┴─ LocalMem3
```

**优化策略**:

1. **本地化数据**: 线程访问本地内存
2. **减少跨节点通信**: 分区数据
3. **亲和性绑定**: 固定线程到CPU

```go
// 伪代码
func ProcessSharded(data []Chunk) {
    numCPU := runtime.NumCPU()
    
    for i, chunk := range data {
        cpuID := i % numCPU
        
        // 绑定到特定CPU
        runtime.LockOSThread()
        setAffinity(cpuID)
        
        process(chunk)  // 本地内存访问
    }
}
```

---

## 附录

### A. 术语对照

| 英文 | 中文 | 说明 |
|------|------|------|
| Concurrency | 并发 | 逻辑上同时 |
| Parallelism | 并行 | 物理上同时 |
| Data Race | 数据竞争 | 并发读写冲突 |
| Happens-Before | 先序关系 | 因果顺序 |
| Linearizability | 线性一致性 | 最强一致性 |
| Eventual Consistency | 最终一致性 | 延迟收敛 |

### B. 核心定理速查

1. **互斥性**: 锁保护消除竞争
2. **2PL串行化**: 两阶段锁保证串行化
3. **CAP定理**: 最多选2个（C/A/P）
4. **线性一致性**: 存在全局顺序
5. **无竞争保证**: 无竞争→顺序一致

### C. OPA并发总结

| 场景 | 机制 | 性能 | 一致性 |
|------|------|------|--------|
| 查询并发 | 读锁 | 高 | 快照一致 |
| 数据更新 | COW | 中 | 最终一致 |
| 缓存 | 版本号 | 高 | 可调 |
| 分布式 | Raft | 低 | 强一致 |

### D. 参考文献

1. **Lamport, L.** "How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs" (1979)
   - 顺序一致性定义
2. **Herlihy, M., Wing, J.** "Linearizability: A Correctness Condition for Concurrent Objects" (1990)
   - 线性一致性理论
3. **Brewer, E.** "CAP Twelve Years Later: How the Rules Have Changed" (2012)
   - CAP定理详解
4. **Ongaro, D., Ousterhout, J.** "In Search of an Understandable Consensus Algorithm" (2014)
   - Raft共识算法
5. **Go Memory Model** - <https://go.dev/ref/mem>
   - Go并发语义

---

**文档版本**: v1.0  
**最后更新**: 2025年10月21日  
**维护者**: OPA技术文档项目  
**反馈**: 欢迎通过GitHub Issues提供建议

**🎉 Phase 1形式化理论完整完成！🎉**:

**下一步阅读**:

- [索引与优化](../03-实现架构/03.5-索引与优化.md) - OPA性能优化实现
- [Top-Down求值器](../03-实现架构/03.4-Top-Down求值器.md) - 并发求值实现
- [性能优化指南](../08-最佳实践/08.2-性能优化指南.md) - 生产环境优化
