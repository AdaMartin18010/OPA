# 命题逻辑与一阶逻辑基础

> **文档类型**: 形式化理论基础  
> **理论领域**: 数理逻辑、形式化方法  
> **适用读者**: 研究人员、理论爱好者、高级开发者  
> **先修知识**: 离散数学、集合论基础  
> **最后更新**: 2025年10月21日  
> **文档状态**: ✅ Phase 1.1 - 理论基础

---

## 📐 理论基础说明

> **本文档目的**:
>
> - ✅ 建立Rego语言的逻辑理论基础
> - ✅ 为形式化语义提供数学工具
> - ✅ 连接逻辑编程理论与Rego实践
> - ✅ 理解Datalog和Rego的逻辑本质
>
> **理论价值**:
>
> - 形式化定义Rego语义
> - 证明算法正确性
> - 优化策略推理过程
> - 提供理论保证
>
> **与其他文档的关系**:
>
> - 基础: 本文档是所有形式化文档的理论基础
> - 应用: [Datalog理论](06.1-Datalog理论基础.md)、[Rego形式化语义](06.2-Rego形式化语义.md)
> - 实践: [求值算法正确性证明](06.4-求值算法正确性证明.md)

---

## 目录

- [命题逻辑与一阶逻辑基础](#命题逻辑与一阶逻辑基础)
  - [📐 理论基础说明](#-理论基础说明)
  - [目录](#目录)
  - [1. 命题逻辑（Propositional Logic）](#1-命题逻辑propositional-logic)
    - [1.1 命题与连接词](#11-命题与连接词)
      - [1.1.1 命题定义](#111-命题定义)
      - [1.1.2 逻辑连接词](#112-逻辑连接词)
    - [1.2 语法与语义](#12-语法与语义)
      - [1.2.1 语法（Syntax）](#121-语法syntax)
      - [1.2.2 语义（Semantics）](#122-语义semantics)
    - [1.3 逻辑等价与范式](#13-逻辑等价与范式)
      - [1.3.1 逻辑等价](#131-逻辑等价)
      - [1.3.2 范式](#132-范式)
    - [1.4 推理规则](#14-推理规则)
      - [1.4.1 自然演绎](#141-自然演绎)
      - [1.4.2 Resolution原理](#142-resolution原理)
  - [2. 一阶逻辑（First-Order Logic）](#2-一阶逻辑first-order-logic)
    - [2.1 语法结构](#21-语法结构)
      - [2.1.1 签名与项](#211-签名与项)
      - [2.1.2 公式](#212-公式)
    - [2.2 语义模型](#22-语义模型)
      - [2.2.1 解释结构](#221-解释结构)
      - [2.2.2 满足关系](#222-满足关系)
    - [2.3 替换与统一](#23-替换与统一)
      - [2.3.1 替换](#231-替换)
      - [2.3.2 统一](#232-统一)
    - [2.4 推理系统](#24-推理系统)
      - [2.4.1 自然演绎规则（一阶）](#241-自然演绎规则一阶)
      - [2.4.2 消解原理（Resolution）](#242-消解原理resolution)
  - [3. Horn子句与Datalog](#3-horn子句与datalog)
    - [3.1 Horn子句定义](#31-horn子句定义)
    - [3.2 SLD-Resolution](#32-sld-resolution)
    - [3.3 Datalog语义](#33-datalog语义)
  - [4. 与Rego的映射](#4-与rego的映射)
    - [4.1 Rego表达式的逻辑解释](#41-rego表达式的逻辑解释)
    - [4.2 规则作为Horn子句](#42-规则作为horn子句)
    - [4.3 求值作为推理](#43-求值作为推理)
  - [5. 定理与证明](#5-定理与证明)
    - [5.1 完备性定理](#51-完备性定理)
    - [5.2 紧致性定理](#52-紧致性定理)
    - [5.3 可靠性定理](#53-可靠性定理)
  - [附录](#附录)
    - [A. 数学符号表](#a-数学符号表)
    - [B. 重要定理速查](#b-重要定理速查)
    - [C. 参考文献](#c-参考文献)

---

## 1. 命题逻辑（Propositional Logic）

### 1.1 命题与连接词

#### 1.1.1 命题定义

**定义 1.1** (命题 Proposition)

命题是一个陈述句，具有确定的真值（真或假）。

**形式化**:

```haskell
-- 命题变量集合
Var = {p, q, r, s, ...}

-- 真值域
Bool = {⊤, ⊥}  -- ⊤表示真，⊥表示假

-- 命题赋值（解释）
τ : Var → Bool
```

**示例**:

```text
p: "OPA版本是0.68"          -- 命题（可验证真假）
q: "Rego支持递归"           -- 命题（真）
"让x大于5"                  -- 非命题（含自由变量）
```

#### 1.1.2 逻辑连接词

**定义 1.2** (逻辑连接词)

| 符号 | 名称 | 读作 | Rego对应 |
|------|------|------|----------|
| ¬ | 否定 | 非 | `not` |
| ∧ | 合取 | 与 | `;` 或换行 |
| ∨ | 析取 | 或 | `\|` |
| → | 蕴含 | 蕴含 | `:-` |
| ↔ | 双条件 | 当且仅当 | `=` |

**真值表**:

```text
┌─────┬─────┬──────┬──────┬──────┬──────┬──────┐
│  p  │  q  │  ¬p  │ p∧q  │ p∨q  │ p→q  │ p↔q  │
├─────┼─────┼──────┼──────┼──────┼──────┼──────┤
│  ⊤  │  ⊤  │  ⊥   │  ⊤   │  ⊤   │  ⊤   │  ⊤   │
│  ⊤  │  ⊥  │  ⊥   │  ⊥   │  ⊤   │  ⊥   │  ⊥   │
│  ⊥  │  ⊤  │  ⊤   │  ⊥   │  ⊤   │  ⊤   │  ⊥   │
│  ⊥  │  ⊥  │  ⊤   │  ⊥   │  ⊥   │  ⊤   │  ⊤   │
└─────┴─────┴──────┴──────┴──────┴──────┴──────┘
```

**重要性质**:

```text
(1) 蕴含定义:  p → q  ≡  ¬p ∨ q
(2) 双条件:    p ↔ q  ≡  (p → q) ∧ (q → p)
(3) 德摩根:    ¬(p ∧ q)  ≡  ¬p ∨ ¬q
(4)           ¬(p ∨ q)  ≡  ¬p ∧ ¬q
```

### 1.2 语法与语义

#### 1.2.1 语法（Syntax）

**定义 1.3** (命题公式)

命题公式的归纳定义：

```bnf
φ ::= ⊤                    (真)
    | ⊥                    (假)
    | p                    (命题变量, p ∈ Var)
    | ¬φ                   (否定)
    | φ₁ ∧ φ₂              (合取)
    | φ₁ ∨ φ₂              (析取)
    | φ₁ → φ₂              (蕴含)
    | φ₁ ↔ φ₂              (双条件)
```

**示例**:

```text
φ₁ = p ∧ q
φ₂ = (p → q) ∧ (q → r) → (p → r)  -- 传递性
φ₃ = (p ∨ ¬p)                      -- 排中律
```

#### 1.2.2 语义（Semantics）

**定义 1.4** (语义解释)

给定赋值 τ : Var → Bool，公式 φ 的真值 [[φ]]τ 递归定义为：

```text
[[⊤]]τ      = ⊤
[[⊥]]τ      = ⊥
[[p]]τ      = τ(p)
[[¬φ]]τ     = ⊤  当且仅当  [[φ]]τ = ⊥
[[φ₁∧φ₂]]τ  = ⊤  当且仅当  [[φ₁]]τ = ⊤ 且 [[φ₂]]τ = ⊤
[[φ₁∨φ₂]]τ  = ⊤  当且仅当  [[φ₁]]τ = ⊤ 或 [[φ₂]]τ = ⊤
[[φ₁→φ₂]]τ  = ⊤  当且仅当  [[φ₁]]τ = ⊥ 或 [[φ₂]]τ = ⊤
[[φ₁↔φ₂]]τ  = ⊤  当且仅当  [[φ₁]]τ = [[φ₂]]τ
```

**示例**:

```text
τ(p) = ⊤, τ(q) = ⊥

[[(p ∧ q) → p]]τ
  = [[p ∧ q]]τ = ⊥ 或 [[p]]τ = ⊤
  = ⊥ 或 ⊤
  = ⊤          ✓ 恒真

```

### 1.3 逻辑等价与范式

#### 1.3.1 逻辑等价

**定义 1.5** (逻辑等价)

两个公式 φ 和 ψ 逻辑等价，记作 φ ≡ ψ，当且仅当：

```text
∀τ. [[φ]]τ = [[ψ]]τ
```

**常用等价**:

```text
交换律:    φ ∧ ψ  ≡  ψ ∧ φ
          φ ∨ ψ  ≡  ψ ∨ φ

结合律:    (φ ∧ ψ) ∧ χ  ≡  φ ∧ (ψ ∧ χ)
          (φ ∨ ψ) ∨ χ  ≡  φ ∨ (ψ ∨ χ)

分配律:    φ ∧ (ψ ∨ χ)  ≡  (φ ∧ ψ) ∨ (φ ∧ χ)
          φ ∨ (ψ ∧ χ)  ≡  (φ ∨ ψ) ∧ (φ ∨ χ)

德摩根:    ¬(φ ∧ ψ)  ≡  ¬φ ∨ ¬ψ
          ¬(φ ∨ ψ)  ≡  ¬φ ∧ ¬ψ

双重否定:  ¬¬φ  ≡  φ
```

#### 1.3.2 范式

**定义 1.6** (合取范式 CNF)

公式 φ 是合取范式，如果它是子句的合取：

```text
φ = C₁ ∧ C₂ ∧ ... ∧ Cₙ

其中每个 Cᵢ 是文字的析取：
Cᵢ = l₁ ∨ l₂ ∨ ... ∨ lₘ

文字 l ::= p | ¬p
```

**定义 1.7** (析取范式 DNF)

公式 φ 是析取范式，如果它是项的析取：

```text
φ = T₁ ∨ T₂ ∨ ... ∨ Tₙ

其中每个 Tᵢ 是文字的合取：
Tᵢ = l₁ ∧ l₂ ∧ ... ∧ lₘ
```

**定理 1.1** (范式存在性)

每个命题公式都等价于一个CNF公式和一个DNF公式。

**证明概要**:

通过以下步骤转换：

1. 消除 → 和 ↔：使用 p→q ≡ ¬p∨q
2. 下推否定：使用德摩根律和双重否定
3. 分配律：展开为所需范式

**示例**:

```text
φ = (p → q) ∧ r

步骤1: (¬p ∨ q) ∧ r      -- 消除蕴含
已经是CNF: (¬p ∨ q) ∧ r

转换为DNF:
  (¬p ∨ q) ∧ r
≡ (¬p ∧ r) ∨ (q ∧ r)    -- 分配律
```

### 1.4 推理规则

#### 1.4.1 自然演绎

**公理**:

```text
(A1)  φ → (ψ → φ)
(A2)  (φ → (ψ → χ)) → ((φ → ψ) → (φ → χ))
(A3)  (¬φ → ¬ψ) → (ψ → φ)
```

**推理规则**:

```text
       φ    φ → ψ
(MP)  ─────────────  Modus Ponens (分离规则)
           ψ

            φ
(Gen)  ────────────  泛化
        ∀x. φ
```

#### 1.4.2 Resolution原理

**定义 1.8** (Resolution规则)

```text
    C ∨ p    D ∨ ¬p
    ─────────────────  Resolution
        C ∨ D
```

其中 C, D 是子句（文字的析取）。

**定理 1.2** (Resolution完备性)

如果公式集 S 不可满足，则存在从 S 导出空子句 □ 的Resolution推导。

**示例**:

```text
给定子句集:
C₁ = p ∨ q
C₂ = ¬p ∨ r
C₃ = ¬q
C₄ = ¬r

Resolution推导:
C₅ = q ∨ r      (C₁, C₂)
C₆ = r          (C₃, C₅)
□ = ⊥          (C₄, C₆)  ✓ 不可满足
```

---

## 2. 一阶逻辑（First-Order Logic）

### 2.1 语法结构

#### 2.1.1 签名与项

**定义 2.1** (签名 Signature)

一阶逻辑签名 Σ = (C, F, P) 包含：

```text
- C: 常量符号集   {c₁, c₂, ...}
- F: 函数符号集   {f₁/n₁, f₂/n₂, ...}  (带元数)
- P: 谓词符号集   {P₁/m₁, P₂/m₂, ...}  (带元数)
```

**定义 2.2** (项 Term)

项的归纳定义：

```bnf
t ::= x                    (变量, x ∈ Var)
    | c                    (常量, c ∈ C)
    | f(t₁, ..., tₙ)       (函数应用, f ∈ F)
```

**示例**（Rego上下文）:

```text
签名:
  常量: "admin", 42, null
  函数: concat/2, count/1, plus/2
  谓词: allow/0, has_permission/2

项:
  x                        -- 变量
  "admin"                  -- 常量
  count(input.users)       -- 函数应用
```

#### 2.1.2 公式

**定义 2.3** (原子公式)

```text
A ::= P(t₁, ..., tₙ)      (谓词应用)
    | t₁ = t₂              (等式)
```

**定义 2.4** (一阶公式)

```bnf
φ ::= A                    (原子公式)
    | ¬φ                   (否定)
    | φ₁ ∧ φ₂              (合取)
    | φ₁ ∨ φ₂              (析取)
    | φ₁ → φ₂              (蕴含)
    | ∀x. φ                (全称量化)
    | ∃x. φ                (存在量化)
```

**示例**:

```text
φ₁ = ∀x. user(x) → has_role(x, "user")
φ₂ = ∃x. admin(x) ∧ active(x)
φ₃ = ∀x∀y. (P(x) ∧ Q(x,y)) → R(y)
```

### 2.2 语义模型

#### 2.2.1 解释结构

**定义 2.5** (解释 Interpretation)

给定签名 Σ，一个解释 I = (D, ·ᴵ) 包含：

```text
- D: 论域（非空集合）
- ·ᴵ: 解释函数
  * cᴵ ∈ D                      (常量解释)
  * fᴵ : Dⁿ → D                 (函数解释)
  * Pᴵ ⊆ Dᵐ                     (谓词解释)
```

**定义 2.6** (变量赋值)

变量赋值 α : Var → D 将变量映射到论域元素。

**记号**: α[x ↦ d] 表示更新赋值：

```text
α[x ↦ d](y) = { d       if y = x
              { α(y)    otherwise
```

#### 2.2.2 满足关系

**定义 2.7** (满足 Satisfaction)

解释 I 和赋值 α 满足公式 φ，记作 I,α ⊨ φ：

```text
I,α ⊨ P(t₁,...,tₙ)  ⟺  (⟦t₁⟧ᴵ,α,...,⟦tₙ⟧ᴵ,α) ∈ Pᴵ
I,α ⊨ t₁ = t₂       ⟺  ⟦t₁⟧ᴵ,α = ⟦t₂⟧ᴵ,α
I,α ⊨ ¬φ            ⟺  I,α ⊭ φ
I,α ⊨ φ₁ ∧ φ₂       ⟺  I,α ⊨ φ₁ 且 I,α ⊨ φ₂
I,α ⊨ φ₁ ∨ φ₂       ⟺  I,α ⊨ φ₁ 或 I,α ⊨ φ₂
I,α ⊨ φ₁ → φ₂       ⟺  I,α ⊭ φ₁ 或 I,α ⊨ φ₂
I,α ⊨ ∀x. φ         ⟺  ∀d ∈ D. I,α[x↦d] ⊨ φ
I,α ⊨ ∃x. φ         ⟺  ∃d ∈ D. I,α[x↦d] ⊨ φ
```

**示例**:

```text
论域: D = {alice, bob, charlie}
解释:
  adminᴵ = {alice}
  userᴵ = {alice, bob, charlie}

公式: φ = ∀x. admin(x) → user(x)

验证: I ⊨ φ
  对 alice: admin(alice) = ⊤, user(alice) = ⊤  ✓
  对 bob:   admin(bob) = ⊥, 蕴含为真            ✓
  对 charlie: admin(charlie) = ⊥, 蕴含为真      ✓
  
结论: I ⊨ φ  ✓
```

### 2.3 替换与统一

#### 2.3.1 替换

**定义 2.8** (替换 Substitution)

替换 θ 是从变量到项的有限映射：

```text
θ = {x₁ ↦ t₁, x₂ ↦ t₂, ..., xₙ ↦ tₙ}
```

**定义 2.9** (替换应用)

项 t 应用替换 θ，记作 tθ：

```text
xθ        = θ(x)          if x ∈ dom(θ)
          = x             otherwise
cθ        = c
f(t₁,...,tₙ)θ = f(t₁θ,...,tₙθ)
```

**示例**:

```text
θ = {x ↦ a, y ↦ f(z)}

P(x, y, z)θ = P(a, f(z), z)
f(x, g(y))θ = f(a, g(f(z)))
```

#### 2.3.2 统一

**定义 2.10** (统一子 Unifier)

替换 θ 是项 s 和 t 的统一子，如果：

```text
sθ = tθ
```

**定义 2.11** (最一般统一子 MGU)

θ 是 s 和 t 的最一般统一子，如果：

1. θ 是统一子：sθ = tθ
2. 对任何统一子 σ，存在 ρ 使得 σ = θρ

**定理 2.1** (MGU存在性)

如果项 s 和 t 可统一，则存在唯一的（模重命名）最一般统一子。

**Robinson统一算法**:

```python
def unify(s, t):
    if s == t:
        return {}  # 空替换
    if is_var(s):
        if s in vars(t):
            return None  # Occur-check失败
        return {s: t}
    if is_var(t):
        return unify(t, s)
    if s.func != t.func:
        return None  # 函数符号不匹配
    theta = {}
    for s_i, t_i in zip(s.args, t.args):
        sigma = unify(s_i * theta, t_i * theta)
        if sigma is None:
            return None
        theta = compose(theta, sigma)
    return theta
```

**示例**:

```text
s = f(x, g(y))
t = f(a, g(b))

unify(s, t):
  unify(x, a): θ₁ = {x ↦ a}
  unify(g(y), g(b)): 
    unify(y, b): θ₂ = {y ↦ b}
  
MGU: θ = {x ↦ a, y ↦ b}

验证: sθ = f(a, g(b)) = t  ✓
```

### 2.4 推理系统

#### 2.4.1 自然演绎规则（一阶）

**全称量化规则**:

```text
       [x]
        :
        φ
(∀I)  ─────── (x 不在假设中自由)
      ∀x. φ

      ∀x. φ
(∀E)  ───────  (t 是任意项)
      φ[x↦t]
```

**存在量化规则**:

```text
      φ[x↦t]
(∃I)  ──────── (t 是任意项)
      ∃x. φ

      ∃x. φ    [φ[x↦c]]
(∃E)  ─────────────────  (c 是新常量)
            ψ
```

#### 2.4.2 消解原理（Resolution）

**一阶Resolution**:

```text
    C ∨ A    D ∨ ¬B
    ─────────────────  where θ = mgu(A, B)
      (C ∨ D)θ
```

**示例**:

```text
C₁ = P(x) ∨ Q(f(x))
C₂ = ¬P(a) ∨ R(x)

解析 P(x) 和 P(a):
  θ = {x ↦ a}
  C₃ = (Q(f(x)) ∨ R(x)){x↦a}
     = Q(f(a)) ∨ R(a)
```

---

## 3. Horn子句与Datalog

### 3.1 Horn子句定义

**定义 3.1** (Horn子句)

Horn子句是最多包含一个正文字的子句：

```text
Horn ::= H ← B₁, B₂, ..., Bₙ    (规则, n≥0)
       | H                        (事实, n=0)
       | ← B₁, B₂, ..., Bₙ        (查询/目标, 无头部)
```

其中：

- H (头部): 正原子
- Bᵢ (体部): 正原子

**等价一阶形式**:

```text
H ← B₁, B₂, ..., Bₙ
≡ B₁ ∧ B₂ ∧ ... ∧ Bₙ → H
≡ ¬B₁ ∨ ¬B₂ ∨ ... ∨ ¬Bₙ ∨ H    (子句形式)
```

**示例**:

```text
path(X,Y) ← edge(X,Y)                    -- 规则
path(X,Z) ← edge(X,Y), path(Y,Z)         -- 递归规则
edge(a,b)                                 -- 事实
← path(a,c)                               -- 查询
```

### 3.2 SLD-Resolution

**定义 3.2** (SLD-Resolution)

SLD = Linear resolution with Selection function for Definite clauses

**推理规则**:

```text
目标: ← A₁, A₂, ..., Aₙ
规则: H ← B₁, ..., Bₘ
选择 Aᵢ，MGU θ = mgu(Aᵢ, H)
────────────────────────────────────
新目标: ← (A₁,...,Aᵢ₋₁,B₁,...,Bₘ,Aᵢ₊₁,...,Aₙ)θ
```

**成功**: 目标变为空 ← □

**失败**: 无法选择任何 Aᵢ 与规则头部统一

**示例**（求解 path(a,c)）:

```text
规则:
R₁: path(X,Y) ← edge(X,Y)
R₂: path(X,Z) ← edge(X,Y), path(Y,Z)
R₃: edge(a,b)
R₄: edge(b,c)

推导:
G₀ = ← path(a,c)

G₁ = ← edge(a,c)                 (使用R₁, θ₁={X↦a,Y↦c})
     失败 (无 edge(a,c))

G₂ = ← edge(a,Y), path(Y,c)      (使用R₂, θ₂={X↦a,Z↦c})

G₃ = ← path(b,c)                 (使用R₃, θ₃={Y↦b})

G₄ = ← edge(b,c)                 (使用R₁, θ₄={X↦b,Y↦c})

G₅ = □                           (使用R₄, θ₅=ε)

成功！答案: θ = θ₂θ₃θ₄θ₅ = {X↦a, Y↦b, Z↦c}
```

### 3.3 Datalog语义

**定义 3.3** (Datalog程序)

Datalog程序 P 是有限的Horn子句集合，满足：

1. 无函数符号（仅常量和变量）
2. 安全性：规则头部变量必须出现在体部
3. 递归：允许谓词通过规则互相定义

**最小模型语义**:

```text
M_P = ⋂ { M | M 是 P 的模型 }
```

**定理 3.1** (最小模型存在性)

每个Datalog程序都有唯一的最小Herbrand模型。

**证明概要**:

1. Herbrand论域 H_P = 程序中所有常量
2. 定义 T_P 算子（立即后果算子）
3. 证明 T_P 单调且连续
4. 最小不动点 lfp(T_P) = M_P

**示例**:

```text
程序:
  parent(tom, bob)
  parent(bob, ann)
  ancestor(X,Y) ← parent(X,Y)
  ancestor(X,Z) ← parent(X,Y), ancestor(Y,Z)

最小模型:
  M_P = {
    parent(tom, bob),
    parent(bob, ann),
    ancestor(tom, bob),
    ancestor(bob, ann),
    ancestor(tom, ann)
  }
```

---

## 4. 与Rego的映射

### 4.1 Rego表达式的逻辑解释

**Rego表达式 → 一阶逻辑公式**:

| Rego | 逻辑 | 说明 |
|------|------|------|
| `x = 5` | `x = 5` | 等式 |
| `x != 5` | `¬(x = 5)` | 不等 |
| `x > 5` | `gt(x, 5)` | 谓词 |
| `a; b` | `a ∧ b` | 合取 |
| `a { ... } b { ... }` | `a ∨ b` | 析取 |
| `not a` | `¬a` | 否定 |
| `some x; a` | `∃x. a` | 存在 |
| `every x in xs { P }` | `∀x ∈ xs. P(x)` | 全称 |

**示例转换**:

```rego
# Rego规则
allow if {
    some role in input.user.roles
    role == "admin"
}

# 逻辑表示
allow ← ∃role. (role ∈ input.user.roles ∧ role = "admin")

# 完全一阶形式
allow ← ∃role. member(role, input.user.roles) ∧ eq(role, "admin")
```

### 4.2 规则作为Horn子句

**Rego规则的Horn子句形式**:

```rego
# Rego
allow if {
    input.method == "GET"
    input.path[0] == "public"
}

# Horn子句
allow ← 
    eq(input.method, "GET"),
    eq(index(input.path, 0), "public")

# 简化表示
allow(Input) ← 
    Input.method = "GET",
    Input.path[0] = "public"
```

**递归规则**:

```rego
# Rego递归
is_admin(user) if {
    user.role == "admin"
}

is_admin(user) if {
    some manager in user.managers
    is_admin(manager)
}

# Horn子句
is_admin(User) ← 
    User.role = "admin"

is_admin(User) ← 
    member(Manager, User.managers),
    is_admin(Manager)
```

### 4.3 求值作为推理

**Rego求值 ≈ SLD-Resolution**:

```text
查询: allow?

Rego求值步骤:
1. 查找 allow 规则
2. 尝试满足规则体部
3. 统一变量
4. 回溯（如果失败）
5. 返回结果

对应SLD-Resolution:
1. 目标 ← allow
2. 选择规则并统一头部
3. 新目标 = 规则体部
4. 递归求解子目标
5. 构造答案替换
```

**完整示例**:

```rego
# Rego程序
default allow = false

allow if {
    input.user.id == data.admin_id
}

allow if {
    input.user.role == "admin"
}

# 查询: allow with input as {"user": {"role": "admin"}}

# 逻辑推导
G₀ = ← allow

G₁ = ← input.user.id = data.admin_id    (规则1)
     失败 (admin_id未定义)

G₂ = ← input.user.role = "admin"        (规则2)

G₃ = □  成功! (θ = {})

结果: allow = true
```

---

## 5. 定理与证明

### 5.1 完备性定理

**定理 5.1** (Gödel完备性定理)

一阶逻辑中，如果 Γ ⊨ φ，则 Γ ⊢ φ。

即：语义蕴涵必有句法证明。

**推论**: Resolution对一阶逻辑完备。

### 5.2 紧致性定理

**定理 5.2** (紧致性定理)

公式集 Γ 可满足，当且仅当 Γ 的每个有限子集可满足。

**应用**:

1. 证明无限模型存在性
2. Datalog程序的有限可满足性

### 5.3 可靠性定理

**定理 5.3** (可靠性)

如果 Γ ⊢ φ，则 Γ ⊨ φ。

**证明**: 对推导长度归纳。

---

## 附录

### A. 数学符号表

| 符号 | 读作 | 含义 |
|------|------|------|
| ⊤ | 真 | 永真 |
| ⊥ | 假 | 永假 |
| ¬ | 非 | 否定 |
| ∧ | 与 | 合取 |
| ∨ | 或 | 析取 |
| → | 蕴含 | 条件 |
| ↔ | 当且仅当 | 双条件 |
| ∀ | 全称 | 对所有 |
| ∃ | 存在 | 存在某个 |
| ⊨ | 满足 | 语义蕴涵 |
| ⊢ | 推出 | 句法推导 |
| ≡ | 等价 | 逻辑等价 |

### B. 重要定理速查

1. **德摩根律**: ¬(φ ∧ ψ) ≡ ¬φ ∨ ¬ψ
2. **蕴含消除**: φ → ψ ≡ ¬φ ∨ ψ
3. **Resolution完备**: 可推导矛盾 ⟺ 不可满足
4. **MGU唯一性**: 模变量重命名唯一
5. **最小模型**: Datalog有唯一最小模型

### C. 参考文献

1. **Fitting, M.** "First-Order Logic and Automated Theorem Proving" (1996)
2. **Lloyd, J.W.** "Foundations of Logic Programming" (1987)
3. **Ullman, J.D.** "Principles of Database and Knowledge-Base Systems" (1988)
4. **Ceri, S., Gottlob, G., Tanca, L.** "Logic Programming and Databases" (1990)
5. **OPA Documentation** - <https://www.openpolicyagent.org/docs/latest/>

---

**文档版本**: v1.0  
**最后更新**: 2025年10月21日  
**维护者**: OPA技术文档项目  
**反馈**: 欢迎通过GitHub Issues提供建议

**下一步阅读**:

- [求值算法正确性证明](06.4-求值算法正确性证明.md) - 应用本文的逻辑工具
- [Datalog理论基础](06.1-Datalog理论基础.md) - 深入Datalog细节
- [Rego形式化语义](06.2-Rego形式化语义.md) - Rego的完整形式化定义
