# Rego å†…ç½®å‡½æ•°åº“ï¼ˆBuilt-in Functions Libraryï¼‰

> **é€‚ç”¨ç‰ˆæœ¬**: OPA v0.30+ (å¤§éƒ¨åˆ†å‡½æ•°) | æ¨è v0.68+  
> **Regoç‰ˆæœ¬**: v1.0  
> **å‡½æ•°æ€»æ•°**: 150+ (æŒç»­å¢åŠ )  
> **æœ€åéªŒè¯**: 2025-10-21  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²éªŒè¯  
> **å‚è€ƒ**: <https://www.openpolicyagent.org/docs/latest/policy-reference/>

---

## âš ï¸ å‡½æ•°ä½¿ç”¨æ³¨æ„äº‹é¡¹

> **ç‰ˆæœ¬å…¼å®¹æ€§**:
>
> - âš ï¸ **å…³é”®**: éƒ¨åˆ†å‡½æ•°åœ¨ä¸åŒOPAç‰ˆæœ¬æœ‰å·®å¼‚æˆ–æ–°å¢ï¼Œè¯¦è§[ç‰ˆæœ¬å…¼å®¹æ€§](../../VERSION_COMPATIBILITY.md)
> - âš ï¸ `http.send`ç­‰I/Oå‡½æ•°ä¸æ”¯æŒWASMç¼–è¯‘
> - âš ï¸ `opa.runtime`ç­‰è¿è¡Œæ—¶å‡½æ•°åœ¨éƒ¨åˆ†æ±‚å€¼ä¸­å—é™
> - âœ… å¤§éƒ¨åˆ†å­—ç¬¦ä¸²ã€æ•°ç»„ã€å¯¹è±¡å‡½æ•°åœ¨v0.30+ç¨³å®šå¯ç”¨
>
> **æ€§èƒ½è€ƒè™‘**:
>
> - æ­£åˆ™è¡¨è¾¾å¼å‡½æ•°ï¼ˆ`regex.*`ï¼‰ç›¸å¯¹è¾ƒæ…¢ï¼Œé¿å…åœ¨å¾ªç¯ä¸­ä½¿ç”¨
> - JSONè§£æå‡½æ•°ï¼ˆ`json.marshal/unmarshal`ï¼‰æœ‰é¢å¤–å¼€é”€
> - åŠ å¯†å‡½æ•°ï¼ˆ`crypto.*`ï¼‰è®¡ç®—å¯†é›†ï¼Œæ³¨æ„æ€§èƒ½å½±å“
>
> **å®‰å…¨æ€§**:
>
> - `http.send`éœ€è¦é…ç½®å…è®¸çš„ç›®æ ‡åœ°å€
> - è¾“å…¥éªŒè¯é¿å…æ³¨å…¥æ”»å‡»
>
> å®è·µ: [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../08-æœ€ä½³å®è·µ/08.2-æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md) | [å®‰å…¨åˆè§„](../01-æŠ€æœ¯è§„èŒƒ/01.5-å®‰å…¨åˆè§„æ ‡å‡†.md)

---

## ğŸ“ English Summary

Comprehensive reference for 150+ built-in functions available in Rego.

**Key Topics**:
- **String Functions**: Manipulation, formatting, regex matching
- **Collection Functions**: Array/object/set operations, aggregation
- **Comparison**: Equality, type checking, ordering
- **Encoding**: JSON, YAML, base64, JWT, crypto
- **Network**: HTTP requests, URL parsing (limited in WASM)
- **Time & Math**: Date parsing, arithmetic operations

**Target Audience**: All Rego developers, essential reference for policy authoring.

**Version**: OPA v0.30+ (Recommended: v0.68+), 150+ functions

---

## ç›®å½•

- [Rego å†…ç½®å‡½æ•°åº“ï¼ˆBuilt-in Functions Libraryï¼‰](#rego-å†…ç½®å‡½æ•°åº“built-in-functions-library)
  - [âš ï¸ å‡½æ•°ä½¿ç”¨æ³¨æ„äº‹é¡¹](#ï¸-å‡½æ•°ä½¿ç”¨æ³¨æ„äº‹é¡¹)
  - [ğŸ“ English Summary](#-english-summary)
  - [ç›®å½•](#ç›®å½•)
  - [1. å†…ç½®å‡½æ•°æ¦‚è¿°](#1-å†…ç½®å‡½æ•°æ¦‚è¿°)
    - [1.1 å‡½æ•°åˆ†ç±»](#11-å‡½æ•°åˆ†ç±»)
    - [1.2 è°ƒç”¨çº¦å®š](#12-è°ƒç”¨çº¦å®š)
    - [1.3 é”™è¯¯å¤„ç†](#13-é”™è¯¯å¤„ç†)
  - [2. å­—ç¬¦ä¸²å‡½æ•°](#2-å­—ç¬¦ä¸²å‡½æ•°)
    - [2.1 åŸºæœ¬æ“ä½œ](#21-åŸºæœ¬æ“ä½œ)
    - [2.2 æ ¼å¼åŒ–](#22-æ ¼å¼åŒ–)
    - [2.3 æ­£åˆ™è¡¨è¾¾å¼](#23-æ­£åˆ™è¡¨è¾¾å¼)
  - [3. æ•°ç»„å‡½æ•°](#3-æ•°ç»„å‡½æ•°)
    - [3.1 array.concat](#31-arrayconcat)
    - [3.2 array.slice](#32-arrayslice)
    - [3.3 sort / sort\_by](#33-sort--sort_by)
  - [4. å¯¹è±¡å‡½æ•°](#4-å¯¹è±¡å‡½æ•°)
    - [4.1 object.get](#41-objectget)
    - [4.2 object.keys / object.values](#42-objectkeys--objectvalues)
    - [4.3 object.union / object.remove](#43-objectunion--objectremove)
  - [5. é›†åˆå‡½æ•°](#5-é›†åˆå‡½æ•°)
    - [5.1 é›†åˆè¿ç®—](#51-é›†åˆè¿ç®—)
    - [5.2 intersection / union](#52-intersection--union)
  - [6. èšåˆå‡½æ•°](#6-èšåˆå‡½æ•°)
    - [6.1 count](#61-count)
    - [6.2 sum / product](#62-sum--product)
    - [6.3 max / min](#63-max--min)
  - [7. ç±»å‹æ£€æŸ¥å‡½æ•°](#7-ç±»å‹æ£€æŸ¥å‡½æ•°)
    - [7.1 is\_\* ç³»åˆ—](#71-is_-ç³»åˆ—)
    - [7.2 type\_name](#72-type_name)
  - [8. ç¼–ç /è§£ç å‡½æ•°](#8-ç¼–ç è§£ç å‡½æ•°)
    - [8.1 JSON](#81-json)
    - [8.2 Base64](#82-base64)
    - [8.3 URL](#83-url)
    - [8.4 YAML](#84-yaml)
  - [9. åŠ å¯†å‡½æ•°](#9-åŠ å¯†å‡½æ•°)
    - [9.1 å“ˆå¸Œå‡½æ•°](#91-å“ˆå¸Œå‡½æ•°)
    - [9.2 HMAC](#92-hmac)
    - [9.3 JWT](#93-jwt)
  - [10. æ—¶é—´å‡½æ•°](#10-æ—¶é—´å‡½æ•°)
    - [10.1 æ—¶é—´è§£æ](#101-æ—¶é—´è§£æ)
    - [10.2 æ—¶é—´æ ¼å¼åŒ–](#102-æ—¶é—´æ ¼å¼åŒ–)
    - [10.3 æ—¶é—´è¿ç®—](#103-æ—¶é—´è¿ç®—)
  - [11. HTTPå‡½æ•°](#11-httpå‡½æ•°)
    - [11.1 http.send](#111-httpsend)
  - [12. å›¾éå†å‡½æ•°](#12-å›¾éå†å‡½æ•°)
    - [12.1 walk](#121-walk)
    - [12.2 graph.reachable](#122-graphreachable)
  - [13. OPAä¸“æœ‰å‡½æ•°](#13-opaä¸“æœ‰å‡½æ•°)
    - [13.1 opa.runtime](#131-oparuntime)
    - [13.2 trace](#132-trace)
  - [14. è‡ªå®šä¹‰å‡½æ•°](#14-è‡ªå®šä¹‰å‡½æ•°)
    - [14.1 å‡½æ•°å®šä¹‰](#141-å‡½æ•°å®šä¹‰)
    - [14.2 é€’å½’å‡½æ•°](#142-é€’å½’å‡½æ•°)
    - [14.3 é«˜é˜¶å‡½æ•°æ¨¡å¼](#143-é«˜é˜¶å‡½æ•°æ¨¡å¼)
  - [15. æ€§èƒ½è€ƒè™‘](#15-æ€§èƒ½è€ƒè™‘)
    - [15.1 é«˜æ€§èƒ½å‡½æ•°](#151-é«˜æ€§èƒ½å‡½æ•°)
    - [15.2 ä½æ€§èƒ½å‡½æ•°](#152-ä½æ€§èƒ½å‡½æ•°)
    - [15.3 ä¼˜åŒ–å»ºè®®](#153-ä¼˜åŒ–å»ºè®®)
  - [é™„å½•Aï¼šå†…ç½®å‡½æ•°é€ŸæŸ¥è¡¨](#é™„å½•aå†…ç½®å‡½æ•°é€ŸæŸ¥è¡¨)
  - [é™„å½•Bï¼šå‡½æ•°åˆ†ç±»ç´¢å¼•](#é™„å½•bå‡½æ•°åˆ†ç±»ç´¢å¼•)

---

## 1. å†…ç½®å‡½æ•°æ¦‚è¿°

### 1.1 å‡½æ•°åˆ†ç±»

**æŒ‰åŠŸèƒ½åˆ†ç±»**ï¼š

```text
OPAå†…ç½®å‡½æ•°åº“ (150+)
â”œâ”€â”€ å­—ç¬¦ä¸²å¤„ç† (20+)
â”‚   â”œâ”€â”€ concat, split, trim
â”‚   â”œâ”€â”€ upper, lower, replace
â”‚   â””â”€â”€ regex.*, sprintf
â”œâ”€â”€ æ•°ç»„æ“ä½œ (15+)
â”‚   â”œâ”€â”€ array.concat, array.slice
â”‚   â””â”€â”€ sort, reverse
â”œâ”€â”€ å¯¹è±¡æ“ä½œ (10+)
â”‚   â”œâ”€â”€ object.get, object.keys
â”‚   â””â”€â”€ object.union, object.remove
â”œâ”€â”€ é›†åˆè¿ç®— (5+)
â”‚   â”œâ”€â”€ &, |, -
â”‚   â””â”€â”€ intersection, union
â”œâ”€â”€ èšåˆå‡½æ•° (8)
â”‚   â”œâ”€â”€ count, sum, product
â”‚   â””â”€â”€ max, min, all, any
â”œâ”€â”€ ç±»å‹æ£€æŸ¥ (10+)
â”‚   â”œâ”€â”€ is_number, is_string
â”‚   â””â”€â”€ type_name
â”œâ”€â”€ ç¼–ç /è§£ç  (15+)
â”‚   â”œâ”€â”€ base64.*, hex.*
â”‚   â”œâ”€â”€ json.*, yaml.*
â”‚   â””â”€â”€ urlquery.*
â”œâ”€â”€ åŠ å¯†å‡½æ•° (20+)
â”‚   â”œâ”€â”€ crypto.sha256, crypto.md5
â”‚   â”œâ”€â”€ crypto.hmac.*
â”‚   â””â”€â”€ io.jwt.*
â”œâ”€â”€ æ—¶é—´å¤„ç† (8)
â”‚   â”œâ”€â”€ time.now_ns, time.parse_*
â”‚   â””â”€â”€ time.add_date, time.diff
â”œâ”€â”€ HTTPè¯·æ±‚ (1)
â”‚   â””â”€â”€ http.send
â”œâ”€â”€ å›¾éå† (3)
â”‚   â”œâ”€â”€ walk, graph.reachable
â”‚   â””â”€â”€ graph.reachable_paths
â””â”€â”€ OPAä¸“æœ‰ (5)
    â”œâ”€â”€ opa.runtime
    â”œâ”€â”€ trace, print
    â””â”€â”€ rego.*
```

### 1.2 è°ƒç”¨çº¦å®š

**å‡½æ•°è°ƒç”¨è¯­æ³•**ï¼š

```rego
package example

import rego.v1

# 1. ç›´æ¥è°ƒç”¨
result := concat("/", ["a", "b", "c"])  # "a/b/c"

# 2. ç®¡é“é£æ ¼ï¼ˆRego v1.0+ï¼‰
result := ["a", "b", "c"] |> concat("/")

# 3. åœ¨è§„åˆ™ä¸­ä½¿ç”¨
rule if {
    count(input.users) > 10
}

# 4. èµ‹å€¼è°ƒç”¨
len := count(input.users)
```

**å‡½æ•°ç­¾åè¡¨ç¤º**ï¼š

```text
concat(sep: string, arr: array[string]) -> string

å‚æ•°:
  sep: åˆ†éš”ç¬¦å­—ç¬¦ä¸²
  arr: å­—ç¬¦ä¸²æ•°ç»„

è¿”å›:
  æ‹¼æ¥åçš„å­—ç¬¦ä¸²

ç¤ºä¾‹:
  concat(":", ["a", "b"]) == "a:b"
```

### 1.3 é”™è¯¯å¤„ç†

**é”™è¯¯è¡Œä¸º**ï¼š

```rego
# é”™è¯¯å¯¼è‡´undefinedï¼ˆè§„åˆ™å¤±è´¥ï¼‰
result := to_number("not-a-number")  # undefined

# ä½¿ç”¨æ¡ä»¶é¿å…é”™è¯¯
safe_result := to_number(x) if {
    regex.match("^[0-9]+$", x)
}

# æä¾›é»˜è®¤å€¼
value := to_number(input.value)
default value := 0
```

---

## 2. å­—ç¬¦ä¸²å‡½æ•°

### 2.1 åŸºæœ¬æ“ä½œ

**concat**ï¼š

```rego
package strings

import rego.v1

# æ‹¼æ¥å­—ç¬¦ä¸²æ•°ç»„
path := concat("/", ["api", "v1", "users"])  # "api/v1/users"

# æ— åˆ†éš”ç¬¦
name := concat("", ["John", " ", "Doe"])  # "John Doe"
```

**split**ï¼š

```rego
# åˆ†å‰²å­—ç¬¦ä¸²
parts := split("a:b:c", ":")  # ["a", "b", "c"]

# åˆ†å‰²è·¯å¾„
segments := split("/api/v1/users", "/")  # ["", "api", "v1", "users"]
```

**trim / trim_space / trim_prefix / trim_suffix**ï¼š

```rego
# å»é™¤ç©ºç™½
clean := trim_space("  hello  ")  # "hello"

# å»é™¤ç‰¹å®šå­—ç¬¦
trimmed := trim("xxxhelloxxx", "x")  # "hello"

# å»é™¤å‰ç¼€
no_prefix := trim_prefix("http://example.com", "http://")  # "example.com"

# å»é™¤åç¼€
no_suffix := trim_suffix("file.txt", ".txt")  # "file"
```

**upper / lower**ï¼š

```rego
upper_case := upper("hello")  # "HELLO"
lower_case := lower("WORLD")  # "world"
```

**substring / startswith / endswith / contains**ï¼š

```rego
# å­ä¸²æå–
sub := substring("hello", 1, 3)  # "ell"

# å‰ç¼€æ£€æŸ¥
has_prefix := startswith("hello", "he")  # true

# åç¼€æ£€æŸ¥
has_suffix := endswith("file.txt", ".txt")  # true

# åŒ…å«æ£€æŸ¥
has_substr := contains("hello world", "wo")  # true
```

**replace / replace_n**ï¼š

```rego
# æ›¿æ¢æ‰€æœ‰åŒ¹é…
replaced := replace("hello world", "o", "0")  # "hell0 w0rld"

# æ›¿æ¢næ¬¡
replaced_n := replace_n({"old": "o", "new": "0"}, "hello world", 1)  # "hell0 world"
```

### 2.2 æ ¼å¼åŒ–

**sprintf**ï¼š

```rego
# æ ¼å¼åŒ–å­—ç¬¦ä¸²
msg := sprintf("User %s has %d items", ["alice", 5])
# "User alice has 5 items"

# æ ¼å¼åŒ–é€‰é¡¹
hex_str := sprintf("0x%02x", [255])  # "0xff"
float_str := sprintf("%.2f", [3.14159])  # "3.14"
```

**format_int**ï¼š

```rego
# åè¿›åˆ¶
decimal := format_int(42, 10)  # "42"

# åå…­è¿›åˆ¶
hex := format_int(255, 16)  # "ff"

# äºŒè¿›åˆ¶
binary := format_int(10, 2)  # "1010"

# å…«è¿›åˆ¶
octal := format_int(64, 8)  # "100"
```

### 2.3 æ­£åˆ™è¡¨è¾¾å¼

**regex.match**ï¼š

```rego
# ç®€å•åŒ¹é…
is_email := regex.match("^[a-z]+@[a-z]+\\.[a-z]+$", "user@example.com")  # true

# æ•°å­—æ£€æŸ¥
is_numeric := regex.match("^[0-9]+$", "12345")  # true
```

**regex.split**ï¼š

```rego
# æŒ‰æ­£åˆ™åˆ†å‰²
parts := regex.split("[,;]", "a,b;c")  # ["a", "b", "c"]
```

**regex.find_n / regex.find_all_string_submatch_n**ï¼š

```rego
# æŸ¥æ‰¾åŒ¹é…é¡¹
matches := regex.find_n("[0-9]+", "abc123def456", -1)  # ["123", "456"]

# æŸ¥æ‰¾å¸¦æ•è·ç»„çš„åŒ¹é…
pattern := "([a-z]+)=([0-9]+)"
text := "a=1 b=2 c=3"
matches := regex.find_all_string_submatch_n(pattern, text, -1)
# [[["a=1", "a", "1"], ["b=2", "b", "2"], ["c=3", "c", "3"]]]
```

**regex.replace**ï¼š

```rego
# æ­£åˆ™æ›¿æ¢
cleaned := regex.replace("[^a-z0-9]", "Hello-World_123", "")  # "HelloWorld123"
```

---

## 3. æ•°ç»„å‡½æ•°

### 3.1 array.concat

```rego
package arrays

import rego.v1

# è¿æ¥ä¸¤ä¸ªæ•°ç»„
combined := array.concat([1, 2], [3, 4])  # [1, 2, 3, 4]

# è¿æ¥å¤šä¸ªæ•°ç»„
all := array.concat(
    array.concat([1], [2]),
    [3, 4]
)  # [1, 2, 3, 4]
```

### 3.2 array.slice

```rego
# æ•°ç»„åˆ‡ç‰‡
arr := [0, 1, 2, 3, 4, 5]

slice1 := array.slice(arr, 1, 4)  # [1, 2, 3]
slice2 := array.slice(arr, 0, 3)  # [0, 1, 2]
slice3 := array.slice(arr, 3, 6)  # [3, 4, 5]

# è´Ÿæ•°ç´¢å¼•ï¼ˆä»å³æ•°ï¼‰
# Note: Regoä¸ç›´æ¥æ”¯æŒï¼Œéœ€è¦æ‰‹åŠ¨è®¡ç®—
last_three := array.slice(arr, count(arr) - 3, count(arr))  # [3, 4, 5]
```

### 3.3 sort / sort_by

```rego
# ç®€å•æ’åº
sorted_nums := sort([3, 1, 4, 1, 5])  # [1, 1, 3, 4, 5]
sorted_strs := sort(["c", "a", "b"])  # ["a", "b", "c"]

# æŒ‰å¯¹è±¡å­—æ®µæ’åº
users := [
    {"name": "bob", "age": 30},
    {"name": "alice", "age": 25},
    {"name": "charlie", "age": 35}
]

sorted_by_age := sort_by(users, "age")
# [{"name": "alice", "age": 25}, {"name": "bob", "age": 30}, {"name": "charlie", "age": 35}]
```

**reverse**ï¼š

```rego
# åè½¬æ•°ç»„
reversed := [x | x := sort([1, 2, 3, 4, 5])[_]]
# éœ€è¦é€šè¿‡ç´¢å¼•åå‘éå†å®ç°
```

---

## 4. å¯¹è±¡å‡½æ•°

### 4.1 object.get

```rego
package objects

import rego.v1

user := {"name": "alice", "age": 30}

# è·å–å­˜åœ¨çš„é”®
name := object.get(user, "name", "unknown")  # "alice"

# è·å–ä¸å­˜åœ¨çš„é”®ï¼ˆè¿”å›é»˜è®¤å€¼ï¼‰
email := object.get(user, "email", "no-email")  # "no-email"

# åµŒå¥—å¯¹è±¡è®¿é—®
config := {
    "database": {
        "host": "localhost",
        "port": 5432
    }
}

host := object.get(config.database, "host", "127.0.0.1")  # "localhost"
```

### 4.2 object.keys / object.values

```rego
user := {"name": "alice", "age": 30, "active": true}

# è·å–æ‰€æœ‰é”®
keys := object.keys(user)  # {"name", "age", "active"} (Set)

# è·å–æ‰€æœ‰å€¼
values := [v | v := user[_]]  # [30, "alice", true] (é¡ºåºä¸å®š)
```

### 4.3 object.union / object.remove

**object.union**ï¼š

```rego
defaults := {"timeout": 30, "retry": 3}
overrides := {"timeout": 60, "cache": true}

# åˆå¹¶å¯¹è±¡ï¼ˆåè€…è¦†ç›–å‰è€…ï¼‰
config := object.union(defaults, overrides)
# {"timeout": 60, "retry": 3, "cache": true}
```

**object.remove**ï¼š

```rego
user := {"name": "alice", "age": 30, "password": "secret"}

# ç§»é™¤æ•æ„Ÿå­—æ®µ
safe_user := object.remove(user, {"password"})
# {"name": "alice", "age": 30}

# ç§»é™¤å¤šä¸ªå­—æ®µ
public_user := object.remove(user, {"password", "age"})
# {"name": "alice"}
```

**object.filter**ï¼š

```rego
user := {"name": "alice", "age": 30, "email": "alice@example.com", "internal_id": 123}

# è¿‡æ»¤å¯¹è±¡ï¼ˆä¿ç•™ç‰¹å®šé”®ï¼‰
filtered := {k: v | user[k]; k != "internal_id"}
# {"name": "alice", "age": 30, "email": "alice@example.com"}
```

---

## 5. é›†åˆå‡½æ•°

### 5.1 é›†åˆè¿ç®—

```rego
package sets

import rego.v1

set1 := {1, 2, 3, 4}
set2 := {3, 4, 5, 6}

# äº¤é›† (&)
intersection_result := set1 & set2  # {3, 4}

# å¹¶é›† (|)
union_result := set1 | set2  # {1, 2, 3, 4, 5, 6}

# å·®é›† (-)
difference_result := set1 - set2  # {1, 2}

# å¯¹ç§°å·®ï¼ˆXORï¼‰
symmetric_diff := (set1 | set2) - (set1 & set2)  # {1, 2, 5, 6}
```

### 5.2 intersection / union

```rego
# intersection (å‡½æ•°å½¢å¼)
common := intersection({set1, set2})  # {3, 4}

# union (å‡½æ•°å½¢å¼)
all := union({set1, set2})  # {1, 2, 3, 4, 5, 6}

# å¤šé›†åˆäº¤é›†
sets := [{1, 2, 3}, {2, 3, 4}, {3, 4, 5}]
common_all := intersection(sets)  # {3}
```

---

## 6. èšåˆå‡½æ•°

### 6.1 count

```rego
package aggregates

import rego.v1

# æ•°ç»„
count_arr := count([1, 2, 3, 4, 5])  # 5

# é›†åˆ
count_set := count({1, 2, 3})  # 3

# å¯¹è±¡ï¼ˆé”®çš„æ•°é‡ï¼‰
count_obj := count({"a": 1, "b": 2})  # 2

# å­—ç¬¦ä¸²ï¼ˆå­—ç¬¦æ•°ï¼‰
count_str := count("hello")  # 5
```

### 6.2 sum / product

```rego
numbers := [1, 2, 3, 4, 5]

# æ±‚å’Œ
total := sum(numbers)  # 15

# æ±‚ç§¯
prod := product(numbers)  # 120

# ç©ºæ•°ç»„
sum_empty := sum([])  # 0
product_empty := product([])  # 1 (æ•°å­¦æƒ¯ä¾‹)
```

### 6.3 max / min

```rego
numbers := [3, 1, 4, 1, 5, 9, 2, 6]

# æœ€å¤§å€¼
maximum := max(numbers)  # 9

# æœ€å°å€¼
minimum := min(numbers)  # 1

# å­—ç¬¦ä¸²æ¯”è¾ƒï¼ˆå­—å…¸åºï¼‰
strs := ["apple", "banana", "cherry"]
max_str := max(strs)  # "cherry"
min_str := min(strs)  # "apple"
```

**all / any**ï¼š

```rego
# all: æ‰€æœ‰å…ƒç´ ä¸ºtrue
conditions := [true, true, true]
all_true := all(conditions)  # true

conditions2 := [true, false, true]
all_true2 := all(conditions2)  # false

# any: è‡³å°‘ä¸€ä¸ªå…ƒç´ ä¸ºtrue
any_true := any(conditions2)  # true

none_true := any([false, false])  # false
```

---

## 7. ç±»å‹æ£€æŸ¥å‡½æ•°

### 7.1 is_* ç³»åˆ—

```rego
package types

import rego.v1

# åŸºæœ¬ç±»å‹æ£€æŸ¥
is_num := is_number(42)  # true
is_str := is_string("hello")  # true
is_bool := is_boolean(true)  # true
is_null_val := is_null(null)  # true

# å¤åˆç±»å‹æ£€æŸ¥
is_arr := is_array([1, 2, 3])  # true
is_obj := is_object({"a": 1})  # true
is_set_val := is_set({1, 2, 3})  # true

# å®é™…åº”ç”¨
validate_input if {
    is_object(input)
    is_string(input.user)
    is_number(input.age)
}
```

### 7.2 type_name

```rego
# è·å–ç±»å‹åç§°
type1 := type_name(42)  # "number"
type2 := type_name("hello")  # "string"
type3 := type_name([1, 2])  # "array"
type4 := type_name({"a": 1})  # "object"
type5 := type_name({1, 2})  # "set"
type6 := type_name(true)  # "boolean"
type7 := type_name(null)  # "null"

# åŠ¨æ€ç±»å‹åˆ†æ´¾
process(x) := x * 2 if {
    type_name(x) == "number"
}

process(x) := upper(x) if {
    type_name(x) == "string"
}
```

---

## 8. ç¼–ç /è§£ç å‡½æ•°

### 8.1 JSON

```rego
package encoding

import rego.v1

# JSONåºåˆ—åŒ–
obj := {"name": "alice", "age": 30}
json_str := json.marshal(obj)  # '{"name":"alice","age":30}'

# JSONååºåˆ—åŒ–
data := json.unmarshal('{"x":1,"y":2}')  # {"x": 1, "y": 2}

# JSONè¿‡æ»¤ï¼ˆç§»é™¤nullï¼‰
obj_with_null := {"a": 1, "b": null, "c": 3}
filtered := json.filter(obj_with_null, ["a", "c"])  # {"a": 1, "c": 3}

# JSONè¡¥ä¸
base := {"a": 1, "b": 2}
patch := [{"op": "replace", "path": "/b", "value": 3}]
patched := json.patch(base, patch)  # {"a": 1, "b": 3}
```

### 8.2 Base64

```rego
# Base64ç¼–ç 
text := "Hello, World!"
encoded := base64.encode(text)  # "SGVsbG8sIFdvcmxkIQ=="

# Base64è§£ç 
decoded := base64.decode(encoded)  # "Hello, World!"

# URLå®‰å…¨Base64
url_encoded := base64url.encode(text)  # "SGVsbG8sIFdvcmxkIQ"
url_decoded := base64url.decode(url_encoded)  # "Hello, World!"
```

### 8.3 URL

```rego
# URLç¼–ç 
query := urlquery.encode("hello world!")  # "hello+world%21"

# URLè§£ç 
decoded_query := urlquery.decode("hello+world%21")  # "hello world!"

# URLå¯¹è±¡ç¼–ç 
params := {"name": "alice", "age": "30"}
encoded_params := urlquery.encode_object(params)  # "age=30&name=alice"

# URLè§£æ
url := "https://example.com/path?query=1"
parsed := urlquery.decode_object(url)
```

### 8.4 YAML

```rego
# YAMLåºåˆ—åŒ–
data := {"name": "alice", "roles": ["admin", "user"]}
yaml_str := yaml.marshal(data)
# "name: alice\nroles:\n- admin\n- user\n"

# YAMLååºåˆ—åŒ–
yaml_text := "name: bob\nage: 25"
parsed := yaml.unmarshal(yaml_text)  # {"name": "bob", "age": 25}
```

**hexç¼–ç **ï¼š

```rego
# åå…­è¿›åˆ¶ç¼–ç 
text := "hello"
hex_str := hex.encode(text)  # "68656c6c6f"

# åå…­è¿›åˆ¶è§£ç 
decoded := hex.decode(hex_str)  # "hello"
```

---

## 9. åŠ å¯†å‡½æ•°

### 9.1 å“ˆå¸Œå‡½æ•°

```rego
package crypto

import rego.v1

data := "hello world"

# MD5 (ä¸æ¨èç”¨äºå®‰å…¨)
md5_hash := crypto.md5(data)  # "5eb63bbbe01eeed093cb22bb8f5acdc3"

# SHAç³»åˆ—
sha1_hash := crypto.sha1(data)  # "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed"
sha256_hash := crypto.sha256(data)  # "b94d27b9..."
sha512_hash := crypto.sha512(data)  # "309ecc48..."

# å®é™…åº”ç”¨ï¼šå†…å®¹éªŒè¯
expected_hash := "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"
valid := crypto.sha256(input.content) == expected_hash
```

### 9.2 HMAC

```rego
# HMAC-SHA256
key := "secret_key"
message := "important data"
hmac_result := crypto.hmac.sha256(message, key)

# HMAC-SHA512
hmac512 := crypto.hmac.sha512(message, key)

# å®é™…åº”ç”¨ï¼šç­¾åéªŒè¯
verify_signature if {
    expected := crypto.hmac.sha256(input.data, data.secret_key)
    input.signature == expected
}
```

### 9.3 JWT

**JWTè§£ç **ï¼š

```rego
# è§£ç JWTï¼ˆä¸éªŒè¯ç­¾åï¼‰
token := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
decoded := io.jwt.decode(token)
# [header, payload, signature]

# è®¿é—®payload
payload := decoded[1]
user_id := payload.sub
```

**JWTéªŒè¯**ï¼š

```rego
# éªŒè¯JWTç­¾å
token := input.token
secret := data.jwt_secret

# ä½¿ç”¨HS256ç®—æ³•éªŒè¯
valid, header, payload := io.jwt.decode_verify(token, {
    "secret": secret,
    "alg": "HS256"
})

allow if {
    valid
    payload.role == "admin"
}
```

**JWTéªŒè¯ï¼ˆRSAï¼‰**ï¼š

```rego
# ä½¿ç”¨RS256éªŒè¯
cert := data.public_key  # PEMæ ¼å¼å…¬é’¥

valid, header, payload := io.jwt.decode_verify(token, {
    "cert": cert,
    "alg": "RS256"
})
```

**JWTéªŒè¯ï¼ˆJWKSï¼‰**ï¼š

```rego
# ä»JWKSéªŒè¯
jwks := data.jwks  # JSON Web Key Set

valid, header, payload := io.jwt.decode_verify(token, {
    "jwks": jwks
})
```

---

## 10. æ—¶é—´å‡½æ•°

### 10.1 æ—¶é—´è§£æ

```rego
package time

import rego.v1

# å½“å‰æ—¶é—´ï¼ˆçº³ç§’ï¼‰
now_ns := time.now_ns()  # 1729425000000000000

# è§£æRFC3339æ—¶é—´
timestamp := time.parse_rfc3339_ns("2025-10-20T10:00:00Z")  # çº³ç§’

# è§£æè‡ªå®šä¹‰æ ¼å¼
layout := "2006-01-02 15:04:05"
parsed := time.parse_ns(layout, "2025-10-20 10:00:00")

# è§£ææŒç»­æ—¶é—´
duration := time.parse_duration_ns("2h30m")  # 9000000000000 (çº³ç§’)
```

### 10.2 æ—¶é—´æ ¼å¼åŒ–

```rego
# å½“å‰æ—¶é—´å­—ç¬¦ä¸²
now_rfc3339 := time.format(time.now_ns())  # "2025-10-20T10:00:00Z"

# è‡ªå®šä¹‰æ ¼å¼
timestamp := time.now_ns()
formatted := time.format([timestamp, "America/New_York", "2006-01-02 15:04:05"])
```

### 10.3 æ—¶é—´è¿ç®—

```rego
# æ—¶é—´å·®ï¼ˆçº³ç§’ï¼‰
start := time.parse_rfc3339_ns("2025-10-20T10:00:00Z")
end := time.parse_rfc3339_ns("2025-10-20T12:30:00Z")
diff_ns := end - start  # 9000000000000 (2.5å°æ—¶)

# æ·»åŠ æŒç»­æ—¶é—´
new_time := time.add_date(timestamp, 0, 1, 0)  # åŠ 1ä¸ªæœˆ

# æ—¶é—´æ¯”è¾ƒ
is_after := end > start  # true

# å®é™…åº”ç”¨ï¼šæ£€æŸ¥è¿‡æœŸ
token_exp := time.parse_rfc3339_ns(input.token.exp)
now := time.now_ns()

token_valid if {
    token_exp > now
}
```

---

## 11. HTTPå‡½æ•°

### 11.1 http.send

**åŸºæœ¬è¯·æ±‚**ï¼š

```rego
package http_example

import rego.v1

# GETè¯·æ±‚
response := http.send({
    "method": "GET",
    "url": "https://api.example.com/users/123"
})

user_data := response.body

# POSTè¯·æ±‚
create_response := http.send({
    "method": "POST",
    "url": "https://api.example.com/users",
    "headers": {
        "Content-Type": "application/json",
        "Authorization": "Bearer token123"
    },
    "body": json.marshal({"name": "alice", "email": "alice@example.com"})
})
```

**é«˜çº§é€‰é¡¹**ï¼š

```rego
# å¸¦è¶…æ—¶å’ŒTLSé…ç½®
response := http.send({
    "method": "GET",
    "url": "https://secure-api.example.com/data",
    "headers": {"Authorization": "Bearer token"},
    "timeout": "30s",
    "tls_insecure_skip_verify": false,
    "tls_ca_cert": data.ca_certificate,
    "raise_error": false  # ä¸æŠ›å‡ºHTTPé”™è¯¯
})

# æ£€æŸ¥å“åº”
allow if {
    response.status_code == 200
    response.body.approved == true
}
```

**ç¼“å­˜æ§åˆ¶**ï¼š

```rego
# å¯ç”¨ç¼“å­˜ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
response := http.send({
    "method": "GET",
    "url": "https://api.example.com/static/config",
    "cache": true,  # å¯ç”¨ç¼“å­˜
    "force_cache": false,  # å…è®¸ç¼“å­˜è¿‡æœŸ
    "force_cache_duration_seconds": 300  # 5åˆ†é’Ÿç¼“å­˜
})
```

---

## 12. å›¾éå†å‡½æ•°

### 12.1 walk

```rego
package graph

import rego.v1

# é€’å½’éå†æ‰€æœ‰å€¼
data_structure := {
    "users": [
        {"name": "alice", "role": "admin"},
        {"name": "bob", "role": "user"}
    ],
    "config": {
        "timeout": 30,
        "debug": true
    }
}

# æŸ¥æ‰¾æ‰€æœ‰å­—ç¬¦ä¸²å€¼
strings := {v | walk(data_structure, [path, v]); is_string(v)}
# {"alice", "bob", "admin", "user"}

# æŸ¥æ‰¾ç‰¹å®šè·¯å¾„
admin_users := {user | 
    walk(data_structure, [["users", i, "role"], "admin"])
    user := data_structure.users[i]
}
```

### 12.2 graph.reachable

```rego
# å›¾çš„å¯è¾¾æ€§åˆ†æ
graph := {
    "a": {"b", "c"},
    "b": {"d"},
    "c": {"d", "e"},
    "d": {},
    "e": {"f"},
    "f": {}
}

# ä»"a"å¯è¾¾çš„æ‰€æœ‰èŠ‚ç‚¹
reachable := graph.reachable(graph, {"a"})
# {"a", "b", "c", "d", "e", "f"}

# å®é™…åº”ç”¨ï¼šæƒé™ç»§æ‰¿
roles := {
    "admin": {"manager", "developer"},
    "manager": {"user"},
    "developer": {"user"},
    "user": {}
}

# è·å–ç”¨æˆ·çš„æ‰€æœ‰æœ‰æ•ˆè§’è‰²
effective_roles := graph.reachable(roles, {input.user.role})

allow if {
    "admin" in effective_roles
}
```

**graph.reachable_paths**ï¼š

```rego
# è·å–æ‰€æœ‰è·¯å¾„
paths := graph.reachable_paths(graph, {"a"})
# è¿”å›ä»"a"åˆ°å„èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„
```

---

## 13. OPAä¸“æœ‰å‡½æ•°

### 13.1 opa.runtime

```rego
package opa_funcs

import rego.v1

# è·å–OPAè¿è¡Œæ—¶ä¿¡æ¯
runtime_info := opa.runtime()

# è®¿é—®é…ç½®
bundle_name := runtime_info.config.bundles["authz"].resource
opa_version := runtime_info.version

# å®é™…åº”ç”¨ï¼šç¯å¢ƒæ„ŸçŸ¥ç­–ç•¥
allow if {
    opa.runtime().env == "production"
    # ç”Ÿäº§ç¯å¢ƒç‰¹å®šé€»è¾‘
}
```

### 13.2 trace

```rego
# è°ƒè¯•è¿½è¸ª
rule if {
    trace(sprintf("Input: %v", [input]))
    x := input.value
    trace(sprintf("x = %v", [x]))
    x > 10
}

# print (ç«‹å³è¾“å‡º)
rule if {
    print("Debug: checking condition")
    input.enabled
}
```

**rego.parse_module**ï¼š

```rego
# è§£æRegoä»£ç 
module_ast := rego.parse_module("policy.rego", `
package example
allow if { true }
`)

# ç”¨äºå…ƒç¼–ç¨‹å’Œç­–ç•¥ç”Ÿæˆ
```

---

## 14. è‡ªå®šä¹‰å‡½æ•°

### 14.1 å‡½æ•°å®šä¹‰

```rego
package custom

import rego.v1

# ç®€å•å‡½æ•°
add(x, y) := x + y

# å¸¦æ¡ä»¶çš„å‡½æ•°
safe_div(x, y) := x / y if {
    y != 0
}

safe_div(x, y) := 0 if {
    y == 0
}

# å¤šè¿”å›å€¼ï¼ˆå®é™…ä¸Šæ˜¯è§„åˆ™é›†ï¼‰
minmax(arr) := {"min": min(arr), "max": max(arr)}
```

### 14.2 é€’å½’å‡½æ•°

```rego
# é˜¶ä¹˜
factorial(0) := 1

factorial(n) := n * factorial(n - 1) if {
    n > 0
}

# æ–æ³¢é‚£å¥‘
fibonacci(0) := 0
fibonacci(1) := 1

fibonacci(n) := fibonacci(n - 1) + fibonacci(n - 2) if {
    n > 1
}

# å®é™…åº”ç”¨ï¼šè®¡ç®—åµŒå¥—å¯¹è±¡æ·±åº¦
depth(x) := 0 if {
    not is_object(x)
    not is_array(x)
}

depth(obj) := 1 + max([depth(v) | v := obj[_]]) if {
    is_object(obj)
    count(obj) > 0
}

depth(arr) := 1 + max([depth(v) | v := arr[_]]) if {
    is_array(arr)
    count(arr) > 0
}
```

### 14.3 é«˜é˜¶å‡½æ•°æ¨¡å¼

```rego
# mapæ¨¡å¼
map_arr(arr, f) := [f(x) | x := arr[_]]

double(x) := x * 2

doubled := map_arr([1, 2, 3], double)  # [2, 4, 6]

# filteræ¨¡å¼
filter_arr(arr, pred) := [x | x := arr[_]; pred(x)]

is_even(x) if {
    x % 2 == 0
}

evens := filter_arr([1, 2, 3, 4, 5], is_even)  # [2, 4]

# reduceæ¨¡å¼ï¼ˆé€šè¿‡èšåˆå®ç°ï¼‰
sum_arr(arr) := sum(arr)
product_arr(arr) := product(arr)
```

---

## 15. æ€§èƒ½è€ƒè™‘

### 15.1 é«˜æ€§èƒ½å‡½æ•°

```text
âš¡ é«˜æ€§èƒ½ï¼ˆO(1) or O(n)ï¼‰:
  - åŸºæœ¬ç®—æœ¯: +, -, *, /, %
  - ç±»å‹æ£€æŸ¥: is_*, type_name
  - é›†åˆè¿ç®—: &, |, -, in
  - æ•°ç»„è®¿é—®: arr[i]
  - å¯¹è±¡è®¿é—®: obj.key
  - count, sum, min, max
```

### 15.2 ä½æ€§èƒ½å‡½æ•°

```text
ğŸŒ ä½æ€§èƒ½ï¼ˆæ³¨æ„ä½¿ç”¨åœºæ™¯ï¼‰:
  - http.send (ç½‘ç»œI/O)
  - walk (é€’å½’éå†)
  - graph.reachable (å›¾ç®—æ³•)
  - regex.* (æ­£åˆ™åŒ¹é…)
  - crypto.* (åŠ å¯†è®¡ç®—)
  - é€’å½’å‡½æ•°ï¼ˆæ·±åº¦å¤§æ—¶ï¼‰
```

### 15.3 ä¼˜åŒ–å»ºè®®

**é¿å…é‡å¤è®¡ç®—**ï¼š

```rego
# âŒ æ…¢: é‡å¤è°ƒç”¨
rule if {
    count(input.items) > 10
    count(input.items) < 100
}

# âœ… å¿«: ç¼“å­˜ç»“æœ
item_count := count(input.items)

rule if {
    item_count > 10
    item_count < 100
}
```

**ä½¿ç”¨ç´¢å¼•**ï¼š

```rego
# âŒ æ…¢: çº¿æ€§æœç´¢
user_exists if {
    user := data.users[_]
    user.id == input.user_id
}

# âœ… å¿«: ç›´æ¥ç´¢å¼•
user_exists if {
    data.users[input.user_id]
}
```

**æ‰¹é‡æ“ä½œ**ï¼š

```rego
# âŒ æ…¢: å¤šæ¬¡APIè°ƒç”¨
results := [http.send({"url": url}) | url := urls[_]]

# âœ… å¿«: å•æ¬¡æ‰¹é‡APIï¼ˆå¦‚æœæ”¯æŒï¼‰
results := http.send({
    "method": "POST",
    "url": "https://api.example.com/batch",
    "body": json.marshal({"urls": urls})
})
```

---

## é™„å½•Aï¼šå†…ç½®å‡½æ•°é€ŸæŸ¥è¡¨

**æœ€å¸¸ç”¨å‡½æ•°Top 20**ï¼š

| å‡½æ•° | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| `count` | è®¡æ•° | `count([1,2,3])` â†’ `3` |
| `concat` | å­—ç¬¦ä¸²æ‹¼æ¥ | `concat("/", ["a","b"])` â†’ `"a/b"` |
| `split` | å­—ç¬¦ä¸²åˆ†å‰² | `split("a:b", ":")` â†’ `["a","b"]` |
| `sprintf` | æ ¼å¼åŒ– | `sprintf("x=%d", [5])` â†’ `"x=5"` |
| `upper` / `lower` | å¤§å°å†™ | `upper("hi")` â†’ `"HI"` |
| `startswith` | å‰ç¼€æ£€æŸ¥ | `startswith("hello", "he")` â†’ `true` |
| `contains` | åŒ…å«æ£€æŸ¥ | `contains("abc", "b")` â†’ `true` |
| `regex.match` | æ­£åˆ™åŒ¹é… | `regex.match("^[0-9]+$", "123")` â†’ `true` |
| `array.concat` | æ•°ç»„è¿æ¥ | `array.concat([1], [2])` â†’ `[1,2]` |
| `sort` | æ’åº | `sort([3,1,2])` â†’ `[1,2,3]` |
| `object.get` | å®‰å…¨å–å€¼ | `object.get(obj, "k", 0)` |
| `sum` / `max` / `min` | èšåˆ | `sum([1,2,3])` â†’ `6` |
| `is_string` | ç±»å‹æ£€æŸ¥ | `is_string("x")` â†’ `true` |
| `json.marshal` | JSONåºåˆ—åŒ– | `json.marshal({"a":1})` |
| `base64.encode` | Base64ç¼–ç  | `base64.encode("hi")` |
| `crypto.sha256` | SHA256å“ˆå¸Œ | `crypto.sha256("data")` |
| `time.now_ns` | å½“å‰æ—¶é—´ | `time.now_ns()` |
| `http.send` | HTTPè¯·æ±‚ | `http.send({"url": "..."})` |
| `walk` | é€’å½’éå† | `walk(data, [path, val])` |
| `graph.reachable` | å›¾å¯è¾¾æ€§ | `graph.reachable(g, {"a"})` |

---

## é™„å½•Bï¼šå‡½æ•°åˆ†ç±»ç´¢å¼•

**æŒ‰ä½¿ç”¨é¢‘ç‡**ï¼š

```text
ğŸ”¥ é«˜é¢‘ (æ¯ä¸ªç­–ç•¥éƒ½ç”¨):
  - count, concat, split
  - is_*, type_name
  - object.get, array.concat

â­ ä¸­é¢‘ (å¸¸è§åœºæ™¯):
  - regex.*, sprintf
  - sum, max, min
  - json.marshal, base64.*

ğŸ’ ä½é¢‘ (ç‰¹æ®Šåœºæ™¯):
  - http.send
  - crypto.*, io.jwt.*
  - graph.*, walk
  - time.*
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [Regoè¯­æ³•è§„èŒƒ](./02.1-Regoè¯­æ³•è§„èŒƒ.md)
- [ç±»å‹ç³»ç»Ÿ](./02.2-ç±»å‹ç³»ç»Ÿ.md)
- [ç­–ç•¥è®¾è®¡æ¨¡å¼](../08-æœ€ä½³å®è·µ/08.1-ç­–ç•¥è®¾è®¡æ¨¡å¼.md)

**å‚è€ƒèµ„æº**ï¼š

- Built-in Functions Reference: <https://www.openpolicyagent.org/docs/latest/policy-reference/>
- Function Performance: <https://www.openpolicyagent.org/docs/latest/performance/>
