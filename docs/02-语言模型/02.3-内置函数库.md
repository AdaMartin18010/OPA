# Rego 内置函数库（Built-in Functions Library）

> **适用版本**: OPA v0.30+ (大部分函数) | 推荐 v0.68+  
> **Rego版本**: v1.0  
> **函数总数**: 150+ (持续增加)  
> **最后验证**: 2025-10-21  
> **文档状态**: ✅ 已验证  
> **参考**: <https://www.openpolicyagent.org/docs/latest/policy-reference/>

---

## ⚠️ 函数使用注意事项

> **版本兼容性**:
>
> - ⚠️ **关键**: 部分函数在不同OPA版本有差异或新增，详见[版本兼容性](../../VERSION_COMPATIBILITY.md)
> - ⚠️ `http.send`等I/O函数不支持WASM编译
> - ⚠️ `opa.runtime`等运行时函数在部分求值中受限
> - ✅ 大部分字符串、数组、对象函数在v0.30+稳定可用
>
> **性能考虑**:
>
> - 正则表达式函数（`regex.*`）相对较慢，避免在循环中使用
> - JSON解析函数（`json.marshal/unmarshal`）有额外开销
> - 加密函数（`crypto.*`）计算密集，注意性能影响
>
> **安全性**:
>
> - `http.send`需要配置允许的目标地址
> - 输入验证避免注入攻击
>
> 实践: [性能优化指南](../08-最佳实践/08.2-性能优化指南.md) | [安全合规](../01-技术规范/01.5-安全合规标准.md)

---

## 📝 English Summary

Comprehensive reference for 150+ built-in functions available in Rego.

**Key Topics**:
- **String Functions**: Manipulation, formatting, regex matching
- **Collection Functions**: Array/object/set operations, aggregation
- **Comparison**: Equality, type checking, ordering
- **Encoding**: JSON, YAML, base64, JWT, crypto
- **Network**: HTTP requests, URL parsing (limited in WASM)
- **Time & Math**: Date parsing, arithmetic operations

**Target Audience**: All Rego developers, essential reference for policy authoring.

**Version**: OPA v0.30+ (Recommended: v0.68+), 150+ functions

---

## 目录

- [Rego 内置函数库（Built-in Functions Library）](#rego-内置函数库built-in-functions-library)
  - [⚠️ 函数使用注意事项](#️-函数使用注意事项)
  - [📝 English Summary](#-english-summary)
  - [目录](#目录)
  - [1. 内置函数概述](#1-内置函数概述)
    - [1.1 函数分类](#11-函数分类)
    - [1.2 调用约定](#12-调用约定)
    - [1.3 错误处理](#13-错误处理)
  - [2. 字符串函数](#2-字符串函数)
    - [2.1 基本操作](#21-基本操作)
    - [2.2 格式化](#22-格式化)
    - [2.3 正则表达式](#23-正则表达式)
  - [3. 数组函数](#3-数组函数)
    - [3.1 array.concat](#31-arrayconcat)
    - [3.2 array.slice](#32-arrayslice)
    - [3.3 sort / sort\_by](#33-sort--sort_by)
  - [4. 对象函数](#4-对象函数)
    - [4.1 object.get](#41-objectget)
    - [4.2 object.keys / object.values](#42-objectkeys--objectvalues)
    - [4.3 object.union / object.remove](#43-objectunion--objectremove)
  - [5. 集合函数](#5-集合函数)
    - [5.1 集合运算](#51-集合运算)
    - [5.2 intersection / union](#52-intersection--union)
  - [6. 聚合函数](#6-聚合函数)
    - [6.1 count](#61-count)
    - [6.2 sum / product](#62-sum--product)
    - [6.3 max / min](#63-max--min)
  - [7. 类型检查函数](#7-类型检查函数)
    - [7.1 is\_\* 系列](#71-is_-系列)
    - [7.2 type\_name](#72-type_name)
  - [8. 编码/解码函数](#8-编码解码函数)
    - [8.1 JSON](#81-json)
    - [8.2 Base64](#82-base64)
    - [8.3 URL](#83-url)
    - [8.4 YAML](#84-yaml)
  - [9. 加密函数](#9-加密函数)
    - [9.1 哈希函数](#91-哈希函数)
    - [9.2 HMAC](#92-hmac)
    - [9.3 JWT](#93-jwt)
  - [10. 时间函数](#10-时间函数)
    - [10.1 时间解析](#101-时间解析)
    - [10.2 时间格式化](#102-时间格式化)
    - [10.3 时间运算](#103-时间运算)
  - [11. HTTP函数](#11-http函数)
    - [11.1 http.send](#111-httpsend)
  - [12. 图遍历函数](#12-图遍历函数)
    - [12.1 walk](#121-walk)
    - [12.2 graph.reachable](#122-graphreachable)
  - [13. OPA专有函数](#13-opa专有函数)
    - [13.1 opa.runtime](#131-oparuntime)
    - [13.2 trace](#132-trace)
  - [14. 自定义函数](#14-自定义函数)
    - [14.1 函数定义](#141-函数定义)
    - [14.2 递归函数](#142-递归函数)
    - [14.3 高阶函数模式](#143-高阶函数模式)
  - [15. 性能考虑](#15-性能考虑)
    - [15.1 高性能函数](#151-高性能函数)
    - [15.2 低性能函数](#152-低性能函数)
    - [15.3 优化建议](#153-优化建议)
  - [附录A：内置函数速查表](#附录a内置函数速查表)
  - [附录B：函数分类索引](#附录b函数分类索引)

---

## 1. 内置函数概述

### 1.1 函数分类

**按功能分类**：

```text
OPA内置函数库 (150+)
├── 字符串处理 (20+)
│   ├── concat, split, trim
│   ├── upper, lower, replace
│   └── regex.*, sprintf
├── 数组操作 (15+)
│   ├── array.concat, array.slice
│   └── sort, reverse
├── 对象操作 (10+)
│   ├── object.get, object.keys
│   └── object.union, object.remove
├── 集合运算 (5+)
│   ├── &, |, -
│   └── intersection, union
├── 聚合函数 (8)
│   ├── count, sum, product
│   └── max, min, all, any
├── 类型检查 (10+)
│   ├── is_number, is_string
│   └── type_name
├── 编码/解码 (15+)
│   ├── base64.*, hex.*
│   ├── json.*, yaml.*
│   └── urlquery.*
├── 加密函数 (20+)
│   ├── crypto.sha256, crypto.md5
│   ├── crypto.hmac.*
│   └── io.jwt.*
├── 时间处理 (8)
│   ├── time.now_ns, time.parse_*
│   └── time.add_date, time.diff
├── HTTP请求 (1)
│   └── http.send
├── 图遍历 (3)
│   ├── walk, graph.reachable
│   └── graph.reachable_paths
└── OPA专有 (5)
    ├── opa.runtime
    ├── trace, print
    └── rego.*
```

### 1.2 调用约定

**函数调用语法**：

```rego
package example

import rego.v1

# 1. 直接调用
result := concat("/", ["a", "b", "c"])  # "a/b/c"

# 2. 管道风格（Rego v1.0+）
result := ["a", "b", "c"] |> concat("/")

# 3. 在规则中使用
rule if {
    count(input.users) > 10
}

# 4. 赋值调用
len := count(input.users)
```

**函数签名表示**：

```text
concat(sep: string, arr: array[string]) -> string

参数:
  sep: 分隔符字符串
  arr: 字符串数组

返回:
  拼接后的字符串

示例:
  concat(":", ["a", "b"]) == "a:b"
```

### 1.3 错误处理

**错误行为**：

```rego
# 错误导致undefined（规则失败）
result := to_number("not-a-number")  # undefined

# 使用条件避免错误
safe_result := to_number(x) if {
    regex.match("^[0-9]+$", x)
}

# 提供默认值
value := to_number(input.value)
default value := 0
```

---

## 2. 字符串函数

### 2.1 基本操作

**concat**：

```rego
package strings

import rego.v1

# 拼接字符串数组
path := concat("/", ["api", "v1", "users"])  # "api/v1/users"

# 无分隔符
name := concat("", ["John", " ", "Doe"])  # "John Doe"
```

**split**：

```rego
# 分割字符串
parts := split("a:b:c", ":")  # ["a", "b", "c"]

# 分割路径
segments := split("/api/v1/users", "/")  # ["", "api", "v1", "users"]
```

**trim / trim_space / trim_prefix / trim_suffix**：

```rego
# 去除空白
clean := trim_space("  hello  ")  # "hello"

# 去除特定字符
trimmed := trim("xxxhelloxxx", "x")  # "hello"

# 去除前缀
no_prefix := trim_prefix("http://example.com", "http://")  # "example.com"

# 去除后缀
no_suffix := trim_suffix("file.txt", ".txt")  # "file"
```

**upper / lower**：

```rego
upper_case := upper("hello")  # "HELLO"
lower_case := lower("WORLD")  # "world"
```

**substring / startswith / endswith / contains**：

```rego
# 子串提取
sub := substring("hello", 1, 3)  # "ell"

# 前缀检查
has_prefix := startswith("hello", "he")  # true

# 后缀检查
has_suffix := endswith("file.txt", ".txt")  # true

# 包含检查
has_substr := contains("hello world", "wo")  # true
```

**replace / replace_n**：

```rego
# 替换所有匹配
replaced := replace("hello world", "o", "0")  # "hell0 w0rld"

# 替换n次
replaced_n := replace_n({"old": "o", "new": "0"}, "hello world", 1)  # "hell0 world"
```

### 2.2 格式化

**sprintf**：

```rego
# 格式化字符串
msg := sprintf("User %s has %d items", ["alice", 5])
# "User alice has 5 items"

# 格式化选项
hex_str := sprintf("0x%02x", [255])  # "0xff"
float_str := sprintf("%.2f", [3.14159])  # "3.14"
```

**format_int**：

```rego
# 十进制
decimal := format_int(42, 10)  # "42"

# 十六进制
hex := format_int(255, 16)  # "ff"

# 二进制
binary := format_int(10, 2)  # "1010"

# 八进制
octal := format_int(64, 8)  # "100"
```

### 2.3 正则表达式

**regex.match**：

```rego
# 简单匹配
is_email := regex.match("^[a-z]+@[a-z]+\\.[a-z]+$", "user@example.com")  # true

# 数字检查
is_numeric := regex.match("^[0-9]+$", "12345")  # true
```

**regex.split**：

```rego
# 按正则分割
parts := regex.split("[,;]", "a,b;c")  # ["a", "b", "c"]
```

**regex.find_n / regex.find_all_string_submatch_n**：

```rego
# 查找匹配项
matches := regex.find_n("[0-9]+", "abc123def456", -1)  # ["123", "456"]

# 查找带捕获组的匹配
pattern := "([a-z]+)=([0-9]+)"
text := "a=1 b=2 c=3"
matches := regex.find_all_string_submatch_n(pattern, text, -1)
# [[["a=1", "a", "1"], ["b=2", "b", "2"], ["c=3", "c", "3"]]]
```

**regex.replace**：

```rego
# 正则替换
cleaned := regex.replace("[^a-z0-9]", "Hello-World_123", "")  # "HelloWorld123"
```

---

## 3. 数组函数

### 3.1 array.concat

```rego
package arrays

import rego.v1

# 连接两个数组
combined := array.concat([1, 2], [3, 4])  # [1, 2, 3, 4]

# 连接多个数组
all := array.concat(
    array.concat([1], [2]),
    [3, 4]
)  # [1, 2, 3, 4]
```

### 3.2 array.slice

```rego
# 数组切片
arr := [0, 1, 2, 3, 4, 5]

slice1 := array.slice(arr, 1, 4)  # [1, 2, 3]
slice2 := array.slice(arr, 0, 3)  # [0, 1, 2]
slice3 := array.slice(arr, 3, 6)  # [3, 4, 5]

# 负数索引（从右数）
# Note: Rego不直接支持，需要手动计算
last_three := array.slice(arr, count(arr) - 3, count(arr))  # [3, 4, 5]
```

### 3.3 sort / sort_by

```rego
# 简单排序
sorted_nums := sort([3, 1, 4, 1, 5])  # [1, 1, 3, 4, 5]
sorted_strs := sort(["c", "a", "b"])  # ["a", "b", "c"]

# 按对象字段排序
users := [
    {"name": "bob", "age": 30},
    {"name": "alice", "age": 25},
    {"name": "charlie", "age": 35}
]

sorted_by_age := sort_by(users, "age")
# [{"name": "alice", "age": 25}, {"name": "bob", "age": 30}, {"name": "charlie", "age": 35}]
```

**reverse**：

```rego
# 反转数组
reversed := [x | x := sort([1, 2, 3, 4, 5])[_]]
# 需要通过索引反向遍历实现
```

---

## 4. 对象函数

### 4.1 object.get

```rego
package objects

import rego.v1

user := {"name": "alice", "age": 30}

# 获取存在的键
name := object.get(user, "name", "unknown")  # "alice"

# 获取不存在的键（返回默认值）
email := object.get(user, "email", "no-email")  # "no-email"

# 嵌套对象访问
config := {
    "database": {
        "host": "localhost",
        "port": 5432
    }
}

host := object.get(config.database, "host", "127.0.0.1")  # "localhost"
```

### 4.2 object.keys / object.values

```rego
user := {"name": "alice", "age": 30, "active": true}

# 获取所有键
keys := object.keys(user)  # {"name", "age", "active"} (Set)

# 获取所有值
values := [v | v := user[_]]  # [30, "alice", true] (顺序不定)
```

### 4.3 object.union / object.remove

**object.union**：

```rego
defaults := {"timeout": 30, "retry": 3}
overrides := {"timeout": 60, "cache": true}

# 合并对象（后者覆盖前者）
config := object.union(defaults, overrides)
# {"timeout": 60, "retry": 3, "cache": true}
```

**object.remove**：

```rego
user := {"name": "alice", "age": 30, "password": "secret"}

# 移除敏感字段
safe_user := object.remove(user, {"password"})
# {"name": "alice", "age": 30}

# 移除多个字段
public_user := object.remove(user, {"password", "age"})
# {"name": "alice"}
```

**object.filter**：

```rego
user := {"name": "alice", "age": 30, "email": "alice@example.com", "internal_id": 123}

# 过滤对象（保留特定键）
filtered := {k: v | user[k]; k != "internal_id"}
# {"name": "alice", "age": 30, "email": "alice@example.com"}
```

---

## 5. 集合函数

### 5.1 集合运算

```rego
package sets

import rego.v1

set1 := {1, 2, 3, 4}
set2 := {3, 4, 5, 6}

# 交集 (&)
intersection_result := set1 & set2  # {3, 4}

# 并集 (|)
union_result := set1 | set2  # {1, 2, 3, 4, 5, 6}

# 差集 (-)
difference_result := set1 - set2  # {1, 2}

# 对称差（XOR）
symmetric_diff := (set1 | set2) - (set1 & set2)  # {1, 2, 5, 6}
```

### 5.2 intersection / union

```rego
# intersection (函数形式)
common := intersection({set1, set2})  # {3, 4}

# union (函数形式)
all := union({set1, set2})  # {1, 2, 3, 4, 5, 6}

# 多集合交集
sets := [{1, 2, 3}, {2, 3, 4}, {3, 4, 5}]
common_all := intersection(sets)  # {3}
```

---

## 6. 聚合函数

### 6.1 count

```rego
package aggregates

import rego.v1

# 数组
count_arr := count([1, 2, 3, 4, 5])  # 5

# 集合
count_set := count({1, 2, 3})  # 3

# 对象（键的数量）
count_obj := count({"a": 1, "b": 2})  # 2

# 字符串（字符数）
count_str := count("hello")  # 5
```

### 6.2 sum / product

```rego
numbers := [1, 2, 3, 4, 5]

# 求和
total := sum(numbers)  # 15

# 求积
prod := product(numbers)  # 120

# 空数组
sum_empty := sum([])  # 0
product_empty := product([])  # 1 (数学惯例)
```

### 6.3 max / min

```rego
numbers := [3, 1, 4, 1, 5, 9, 2, 6]

# 最大值
maximum := max(numbers)  # 9

# 最小值
minimum := min(numbers)  # 1

# 字符串比较（字典序）
strs := ["apple", "banana", "cherry"]
max_str := max(strs)  # "cherry"
min_str := min(strs)  # "apple"
```

**all / any**：

```rego
# all: 所有元素为true
conditions := [true, true, true]
all_true := all(conditions)  # true

conditions2 := [true, false, true]
all_true2 := all(conditions2)  # false

# any: 至少一个元素为true
any_true := any(conditions2)  # true

none_true := any([false, false])  # false
```

---

## 7. 类型检查函数

### 7.1 is_* 系列

```rego
package types

import rego.v1

# 基本类型检查
is_num := is_number(42)  # true
is_str := is_string("hello")  # true
is_bool := is_boolean(true)  # true
is_null_val := is_null(null)  # true

# 复合类型检查
is_arr := is_array([1, 2, 3])  # true
is_obj := is_object({"a": 1})  # true
is_set_val := is_set({1, 2, 3})  # true

# 实际应用
validate_input if {
    is_object(input)
    is_string(input.user)
    is_number(input.age)
}
```

### 7.2 type_name

```rego
# 获取类型名称
type1 := type_name(42)  # "number"
type2 := type_name("hello")  # "string"
type3 := type_name([1, 2])  # "array"
type4 := type_name({"a": 1})  # "object"
type5 := type_name({1, 2})  # "set"
type6 := type_name(true)  # "boolean"
type7 := type_name(null)  # "null"

# 动态类型分派
process(x) := x * 2 if {
    type_name(x) == "number"
}

process(x) := upper(x) if {
    type_name(x) == "string"
}
```

---

## 8. 编码/解码函数

### 8.1 JSON

```rego
package encoding

import rego.v1

# JSON序列化
obj := {"name": "alice", "age": 30}
json_str := json.marshal(obj)  # '{"name":"alice","age":30}'

# JSON反序列化
data := json.unmarshal('{"x":1,"y":2}')  # {"x": 1, "y": 2}

# JSON过滤（移除null）
obj_with_null := {"a": 1, "b": null, "c": 3}
filtered := json.filter(obj_with_null, ["a", "c"])  # {"a": 1, "c": 3}

# JSON补丁
base := {"a": 1, "b": 2}
patch := [{"op": "replace", "path": "/b", "value": 3}]
patched := json.patch(base, patch)  # {"a": 1, "b": 3}
```

### 8.2 Base64

```rego
# Base64编码
text := "Hello, World!"
encoded := base64.encode(text)  # "SGVsbG8sIFdvcmxkIQ=="

# Base64解码
decoded := base64.decode(encoded)  # "Hello, World!"

# URL安全Base64
url_encoded := base64url.encode(text)  # "SGVsbG8sIFdvcmxkIQ"
url_decoded := base64url.decode(url_encoded)  # "Hello, World!"
```

### 8.3 URL

```rego
# URL编码
query := urlquery.encode("hello world!")  # "hello+world%21"

# URL解码
decoded_query := urlquery.decode("hello+world%21")  # "hello world!"

# URL对象编码
params := {"name": "alice", "age": "30"}
encoded_params := urlquery.encode_object(params)  # "age=30&name=alice"

# URL解析
url := "https://example.com/path?query=1"
parsed := urlquery.decode_object(url)
```

### 8.4 YAML

```rego
# YAML序列化
data := {"name": "alice", "roles": ["admin", "user"]}
yaml_str := yaml.marshal(data)
# "name: alice\nroles:\n- admin\n- user\n"

# YAML反序列化
yaml_text := "name: bob\nage: 25"
parsed := yaml.unmarshal(yaml_text)  # {"name": "bob", "age": 25}
```

**hex编码**：

```rego
# 十六进制编码
text := "hello"
hex_str := hex.encode(text)  # "68656c6c6f"

# 十六进制解码
decoded := hex.decode(hex_str)  # "hello"
```

---

## 9. 加密函数

### 9.1 哈希函数

```rego
package crypto

import rego.v1

data := "hello world"

# MD5 (不推荐用于安全)
md5_hash := crypto.md5(data)  # "5eb63bbbe01eeed093cb22bb8f5acdc3"

# SHA系列
sha1_hash := crypto.sha1(data)  # "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed"
sha256_hash := crypto.sha256(data)  # "b94d27b9..."
sha512_hash := crypto.sha512(data)  # "309ecc48..."

# 实际应用：内容验证
expected_hash := "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"
valid := crypto.sha256(input.content) == expected_hash
```

### 9.2 HMAC

```rego
# HMAC-SHA256
key := "secret_key"
message := "important data"
hmac_result := crypto.hmac.sha256(message, key)

# HMAC-SHA512
hmac512 := crypto.hmac.sha512(message, key)

# 实际应用：签名验证
verify_signature if {
    expected := crypto.hmac.sha256(input.data, data.secret_key)
    input.signature == expected
}
```

### 9.3 JWT

**JWT解码**：

```rego
# 解码JWT（不验证签名）
token := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
decoded := io.jwt.decode(token)
# [header, payload, signature]

# 访问payload
payload := decoded[1]
user_id := payload.sub
```

**JWT验证**：

```rego
# 验证JWT签名
token := input.token
secret := data.jwt_secret

# 使用HS256算法验证
valid, header, payload := io.jwt.decode_verify(token, {
    "secret": secret,
    "alg": "HS256"
})

allow if {
    valid
    payload.role == "admin"
}
```

**JWT验证（RSA）**：

```rego
# 使用RS256验证
cert := data.public_key  # PEM格式公钥

valid, header, payload := io.jwt.decode_verify(token, {
    "cert": cert,
    "alg": "RS256"
})
```

**JWT验证（JWKS）**：

```rego
# 从JWKS验证
jwks := data.jwks  # JSON Web Key Set

valid, header, payload := io.jwt.decode_verify(token, {
    "jwks": jwks
})
```

---

## 10. 时间函数

### 10.1 时间解析

```rego
package time

import rego.v1

# 当前时间（纳秒）
now_ns := time.now_ns()  # 1729425000000000000

# 解析RFC3339时间
timestamp := time.parse_rfc3339_ns("2025-10-20T10:00:00Z")  # 纳秒

# 解析自定义格式
layout := "2006-01-02 15:04:05"
parsed := time.parse_ns(layout, "2025-10-20 10:00:00")

# 解析持续时间
duration := time.parse_duration_ns("2h30m")  # 9000000000000 (纳秒)
```

### 10.2 时间格式化

```rego
# 当前时间字符串
now_rfc3339 := time.format(time.now_ns())  # "2025-10-20T10:00:00Z"

# 自定义格式
timestamp := time.now_ns()
formatted := time.format([timestamp, "America/New_York", "2006-01-02 15:04:05"])
```

### 10.3 时间运算

```rego
# 时间差（纳秒）
start := time.parse_rfc3339_ns("2025-10-20T10:00:00Z")
end := time.parse_rfc3339_ns("2025-10-20T12:30:00Z")
diff_ns := end - start  # 9000000000000 (2.5小时)

# 添加持续时间
new_time := time.add_date(timestamp, 0, 1, 0)  # 加1个月

# 时间比较
is_after := end > start  # true

# 实际应用：检查过期
token_exp := time.parse_rfc3339_ns(input.token.exp)
now := time.now_ns()

token_valid if {
    token_exp > now
}
```

---

## 11. HTTP函数

### 11.1 http.send

**基本请求**：

```rego
package http_example

import rego.v1

# GET请求
response := http.send({
    "method": "GET",
    "url": "https://api.example.com/users/123"
})

user_data := response.body

# POST请求
create_response := http.send({
    "method": "POST",
    "url": "https://api.example.com/users",
    "headers": {
        "Content-Type": "application/json",
        "Authorization": "Bearer token123"
    },
    "body": json.marshal({"name": "alice", "email": "alice@example.com"})
})
```

**高级选项**：

```rego
# 带超时和TLS配置
response := http.send({
    "method": "GET",
    "url": "https://secure-api.example.com/data",
    "headers": {"Authorization": "Bearer token"},
    "timeout": "30s",
    "tls_insecure_skip_verify": false,
    "tls_ca_cert": data.ca_certificate,
    "raise_error": false  # 不抛出HTTP错误
})

# 检查响应
allow if {
    response.status_code == 200
    response.body.approved == true
}
```

**缓存控制**：

```rego
# 启用缓存（性能优化）
response := http.send({
    "method": "GET",
    "url": "https://api.example.com/static/config",
    "cache": true,  # 启用缓存
    "force_cache": false,  # 允许缓存过期
    "force_cache_duration_seconds": 300  # 5分钟缓存
})
```

---

## 12. 图遍历函数

### 12.1 walk

```rego
package graph

import rego.v1

# 递归遍历所有值
data_structure := {
    "users": [
        {"name": "alice", "role": "admin"},
        {"name": "bob", "role": "user"}
    ],
    "config": {
        "timeout": 30,
        "debug": true
    }
}

# 查找所有字符串值
strings := {v | walk(data_structure, [path, v]); is_string(v)}
# {"alice", "bob", "admin", "user"}

# 查找特定路径
admin_users := {user | 
    walk(data_structure, [["users", i, "role"], "admin"])
    user := data_structure.users[i]
}
```

### 12.2 graph.reachable

```rego
# 图的可达性分析
graph := {
    "a": {"b", "c"},
    "b": {"d"},
    "c": {"d", "e"},
    "d": {},
    "e": {"f"},
    "f": {}
}

# 从"a"可达的所有节点
reachable := graph.reachable(graph, {"a"})
# {"a", "b", "c", "d", "e", "f"}

# 实际应用：权限继承
roles := {
    "admin": {"manager", "developer"},
    "manager": {"user"},
    "developer": {"user"},
    "user": {}
}

# 获取用户的所有有效角色
effective_roles := graph.reachable(roles, {input.user.role})

allow if {
    "admin" in effective_roles
}
```

**graph.reachable_paths**：

```rego
# 获取所有路径
paths := graph.reachable_paths(graph, {"a"})
# 返回从"a"到各节点的所有路径
```

---

## 13. OPA专有函数

### 13.1 opa.runtime

```rego
package opa_funcs

import rego.v1

# 获取OPA运行时信息
runtime_info := opa.runtime()

# 访问配置
bundle_name := runtime_info.config.bundles["authz"].resource
opa_version := runtime_info.version

# 实际应用：环境感知策略
allow if {
    opa.runtime().env == "production"
    # 生产环境特定逻辑
}
```

### 13.2 trace

```rego
# 调试追踪
rule if {
    trace(sprintf("Input: %v", [input]))
    x := input.value
    trace(sprintf("x = %v", [x]))
    x > 10
}

# print (立即输出)
rule if {
    print("Debug: checking condition")
    input.enabled
}
```

**rego.parse_module**：

```rego
# 解析Rego代码
module_ast := rego.parse_module("policy.rego", `
package example
allow if { true }
`)

# 用于元编程和策略生成
```

---

## 14. 自定义函数

### 14.1 函数定义

```rego
package custom

import rego.v1

# 简单函数
add(x, y) := x + y

# 带条件的函数
safe_div(x, y) := x / y if {
    y != 0
}

safe_div(x, y) := 0 if {
    y == 0
}

# 多返回值（实际上是规则集）
minmax(arr) := {"min": min(arr), "max": max(arr)}
```

### 14.2 递归函数

```rego
# 阶乘
factorial(0) := 1

factorial(n) := n * factorial(n - 1) if {
    n > 0
}

# 斐波那契
fibonacci(0) := 0
fibonacci(1) := 1

fibonacci(n) := fibonacci(n - 1) + fibonacci(n - 2) if {
    n > 1
}

# 实际应用：计算嵌套对象深度
depth(x) := 0 if {
    not is_object(x)
    not is_array(x)
}

depth(obj) := 1 + max([depth(v) | v := obj[_]]) if {
    is_object(obj)
    count(obj) > 0
}

depth(arr) := 1 + max([depth(v) | v := arr[_]]) if {
    is_array(arr)
    count(arr) > 0
}
```

### 14.3 高阶函数模式

```rego
# map模式
map_arr(arr, f) := [f(x) | x := arr[_]]

double(x) := x * 2

doubled := map_arr([1, 2, 3], double)  # [2, 4, 6]

# filter模式
filter_arr(arr, pred) := [x | x := arr[_]; pred(x)]

is_even(x) if {
    x % 2 == 0
}

evens := filter_arr([1, 2, 3, 4, 5], is_even)  # [2, 4]

# reduce模式（通过聚合实现）
sum_arr(arr) := sum(arr)
product_arr(arr) := product(arr)
```

---

## 15. 性能考虑

### 15.1 高性能函数

```text
⚡ 高性能（O(1) or O(n)）:
  - 基本算术: +, -, *, /, %
  - 类型检查: is_*, type_name
  - 集合运算: &, |, -, in
  - 数组访问: arr[i]
  - 对象访问: obj.key
  - count, sum, min, max
```

### 15.2 低性能函数

```text
🐌 低性能（注意使用场景）:
  - http.send (网络I/O)
  - walk (递归遍历)
  - graph.reachable (图算法)
  - regex.* (正则匹配)
  - crypto.* (加密计算)
  - 递归函数（深度大时）
```

### 15.3 优化建议

**避免重复计算**：

```rego
# ❌ 慢: 重复调用
rule if {
    count(input.items) > 10
    count(input.items) < 100
}

# ✅ 快: 缓存结果
item_count := count(input.items)

rule if {
    item_count > 10
    item_count < 100
}
```

**使用索引**：

```rego
# ❌ 慢: 线性搜索
user_exists if {
    user := data.users[_]
    user.id == input.user_id
}

# ✅ 快: 直接索引
user_exists if {
    data.users[input.user_id]
}
```

**批量操作**：

```rego
# ❌ 慢: 多次API调用
results := [http.send({"url": url}) | url := urls[_]]

# ✅ 快: 单次批量API（如果支持）
results := http.send({
    "method": "POST",
    "url": "https://api.example.com/batch",
    "body": json.marshal({"urls": urls})
})
```

---

## 附录A：内置函数速查表

**最常用函数Top 20**：

| 函数 | 用途 | 示例 |
|------|------|------|
| `count` | 计数 | `count([1,2,3])` → `3` |
| `concat` | 字符串拼接 | `concat("/", ["a","b"])` → `"a/b"` |
| `split` | 字符串分割 | `split("a:b", ":")` → `["a","b"]` |
| `sprintf` | 格式化 | `sprintf("x=%d", [5])` → `"x=5"` |
| `upper` / `lower` | 大小写 | `upper("hi")` → `"HI"` |
| `startswith` | 前缀检查 | `startswith("hello", "he")` → `true` |
| `contains` | 包含检查 | `contains("abc", "b")` → `true` |
| `regex.match` | 正则匹配 | `regex.match("^[0-9]+$", "123")` → `true` |
| `array.concat` | 数组连接 | `array.concat([1], [2])` → `[1,2]` |
| `sort` | 排序 | `sort([3,1,2])` → `[1,2,3]` |
| `object.get` | 安全取值 | `object.get(obj, "k", 0)` |
| `sum` / `max` / `min` | 聚合 | `sum([1,2,3])` → `6` |
| `is_string` | 类型检查 | `is_string("x")` → `true` |
| `json.marshal` | JSON序列化 | `json.marshal({"a":1})` |
| `base64.encode` | Base64编码 | `base64.encode("hi")` |
| `crypto.sha256` | SHA256哈希 | `crypto.sha256("data")` |
| `time.now_ns` | 当前时间 | `time.now_ns()` |
| `http.send` | HTTP请求 | `http.send({"url": "..."})` |
| `walk` | 递归遍历 | `walk(data, [path, val])` |
| `graph.reachable` | 图可达性 | `graph.reachable(g, {"a"})` |

---

## 附录B：函数分类索引

**按使用频率**：

```text
🔥 高频 (每个策略都用):
  - count, concat, split
  - is_*, type_name
  - object.get, array.concat

⭐ 中频 (常见场景):
  - regex.*, sprintf
  - sum, max, min
  - json.marshal, base64.*

💎 低频 (特殊场景):
  - http.send
  - crypto.*, io.jwt.*
  - graph.*, walk
  - time.*
```

---

**相关文档**：

- [Rego语法规范](./02.1-Rego语法规范.md)
- [类型系统](./02.2-类型系统.md)
- [策略设计模式](../08-最佳实践/08.1-策略设计模式.md)

**参考资源**：

- Built-in Functions Reference: <https://www.openpolicyagent.org/docs/latest/policy-reference/>
- Function Performance: <https://www.openpolicyagent.org/docs/latest/performance/>
