# Rego 求值模型（Evaluation Model）

> **更新日期**: 2025年10月21日  
> **Rego版本**: v1.0  
> **求值策略**: Top-Down + Unification  
> **参考**: <https://www.openpolicyagent.org/docs/latest/policy-language/>

---

## 目录

- [Rego 求值模型（Evaluation Model）](#rego-求值模型evaluation-model)
  - [目录](#目录)
  - [1. 求值模型概述](#1-求值模型概述)
    - [1.1 求值策略](#11-求值策略)
    - [1.2 核心概念](#12-核心概念)
    - [1.3 求值生命周期](#13-求值生命周期)
  - [2. 统一（Unification）](#2-统一unification)
    - [2.1 统一算法](#21-统一算法)
    - [2.2 统一示例](#22-统一示例)
    - [2.3 统一与赋值的区别](#23-统一与赋值的区别)
  - [3. Top-Down求值](#3-top-down求值)
    - [3.1 查询求值过程](#31-查询求值过程)
    - [3.2 回溯机制](#32-回溯机制)
    - [3.3 规则匹配](#33-规则匹配)
  - [4. 变量绑定](#4-变量绑定)
    - [4.1 变量作用域](#41-变量作用域)
    - [4.2 变量绑定顺序](#42-变量绑定顺序)
    - [4.3 未绑定变量](#43-未绑定变量)
  - [5. 集合推导求值](#5-集合推导求值)
    - [5.1 数组推导](#51-数组推导)
    - [5.2 对象推导](#52-对象推导)
    - [5.3 集合推导](#53-集合推导)
  - [6. 否定与全称量化](#6-否定与全称量化)
    - [6.1 否定求值](#61-否定求值)
    - [6.2 全称量化](#62-全称量化)
    - [6.3 安全性约束](#63-安全性约束)
  - [7. 部分求值](#7-部分求值)
    - [7.1 部分求值原理](#71-部分求值原理)
    - [7.2 未知变量](#72-未知变量)
    - [7.3 优化效果](#73-优化效果)
  - [8. 缓存机制](#8-缓存机制)
    - [8.1 规则缓存](#81-规则缓存)
    - [8.2 内置函数缓存](#82-内置函数缓存)
    - [8.3 缓存失效](#83-缓存失效)
  - [9. 短路求值](#9-短路求值)
    - [9.1 逻辑短路](#91-逻辑短路)
    - [9.2 提前退出](#92-提前退出)
    - [9.3 优化策略](#93-优化策略)
  - [10. 性能优化](#10-性能优化)
    - [10.1 求值顺序优化](#101-求值顺序优化)
    - [10.2 索引利用](#102-索引利用)
    - [10.3 复杂度分析](#103-复杂度分析)
  - [附录A：求值形式化语义](#附录a求值形式化语义)
  - [附录B：求值调试技巧](#附录b求值调试技巧)

---

## 1. 求值模型概述

### 1.1 求值策略

**Rego求值特征**：

```text
声明式求值（Declarative Evaluation）
├── 非过程式: 描述"是什么"而非"怎么做"
├── 无副作用: 求值过程不改变状态
├── 幂等性: 多次求值结果相同
└── 顺序无关: 规则顺序不影响结果

Top-Down求值（Goal-Driven）
├── 从查询目标开始
├── 递归分解子目标
├── 深度优先搜索
└── 回溯探索所有可能

统一驱动（Unification-Based）
├── 模式匹配
├── 变量绑定
├── 约束传播
└── 失败回溯
```

**求值模式对比**：

| 特性 | Rego (Top-Down) | SQL (Set-Based) | 命令式语言 |
|------|----------------|----------------|-----------|
| **执行方式** | 目标驱动 | 集合运算 | 指令顺序 |
| **回溯** | ✅ 自动 | ❌ 无 | ⚠️ 手动 |
| **变量绑定** | 统一 | 联接 | 赋值 |
| **副作用** | ❌ 无 | ❌ 无（纯查询） | ✅ 有 |
| **顺序敏感** | ❌ 否 | ❌ 否 | ✅ 是 |

### 1.2 核心概念

**术语定义**：

```text
术语（Term）
├── 值: 123, "hello", true, null
├── 变量: x, user, input
├── 引用: input.user, data.roles[x]
├── 数组: [1, 2, x]
├── 对象: {"key": value, "x": y}
└── 集合: {1, 2, x}

查询（Query）
├── 等式: x = 10
├── 统一: [x, y] = [1, 2]
├── 比较: x > y
├── 函数调用: count(arr, n)
├── 规则引用: allow
└── 复合: x = 1; y = 2

绑定（Binding）
└── 变量 → 值的映射
    例: {x: 10, y: "hello"}
```

### 1.3 求值生命周期

```text
┌─────────────────────────────────────┐
│  1. 解析查询                          │
│     Query: data.authz.allow         │
└─────────────┬───────────────────────┘
              ↓
┌─────────────────────────────────────┐
│  2. 查找规则定义                      │
│     package authz                    │
│     allow if { ... }                 │
└─────────────┬───────────────────────┘
              ↓
┌─────────────────────────────────────┐
│  3. 求值规则体（Body）                │
│     - 统一变量                       │
│     - 求值表达式                     │
│     - 回溯探索                       │
└─────────────┬───────────────────────┘
              ↓
┌─────────────────────────────────────┐
│  4. 收集结果                         │
│     - 聚合所有成功的绑定              │
│     - 应用规则头（Head）              │
└─────────────┬───────────────────────┘
              ↓
┌─────────────────────────────────────┐
│  5. 返回结果集                       │
│     {true} / {false} / {value, ...} │
└─────────────────────────────────────┘
```

---

## 2. 统一（Unification）

### 2.1 统一算法

**Robinson统一算法**：

```text
unify(t1, t2, θ) → θ'

规则:
1. unify(x, x, θ) = θ
   (相同项统一为自身)

2. unify(x, t, θ) = θ ∪ {x: t}  if x ∉ vars(t)
   (变量与非变量统一，绑定变量)

3. unify(f(t1,...,tn), f(s1,...,sn), θ) = 
      unify(t1,s1,unify(t2,s2,...unify(tn,sn,θ)...))
   (复合项递归统一)

4. unify(t1, t2, θ) = fail
   (不兼容项统一失败)
```

**统一示例**：

```rego
package unification_examples

import rego.v1

# 示例1: 变量与常量统一
test_simple_unify if {
    x = 10        # x统一为10
    x == 10       # 成功
}

# 示例2: 变量与变量统一
test_var_unify if {
    x = y         # x和y统一（共享同一变量）
    y = 42
    x == 42       # 成功，x也是42
}

# 示例3: 数组统一
test_array_unify if {
    [x, y, 3] = [1, 2, 3]
    x == 1
    y == 2
}

# 示例4: 对象统一
test_object_unify if {
    {"name": n, "age": a} = {"name": "alice", "age": 30}
    n == "alice"
    a == 30
}

# 示例5: 部分统一
test_partial_unify if {
    # 只需匹配部分字段
    {"name": name} = {"name": "bob", "role": "admin"}
    name == "bob"
}
```

### 2.2 统一示例

**复杂统一场景**：

```rego
package complex_unification

import rego.v1

# 嵌套结构统一
users := {
    "alice": {"role": "admin", "dept": "eng"},
    "bob": {"role": "user", "dept": "sales"}
}

# 提取嵌套值
admin_dept := dept if {
    # 统一嵌套对象
    {"role": "admin", "dept": dept} = users[_]
}
# 结果: admin_dept = "eng"

# 多变量协同统一
pairs := [[x, y] | 
    some x in [1, 2, 3]
    some y in [4, 5, 6]
    x + y == 7
]
# 结果: [[1, 6], [2, 5], [3, 4]]
```

### 2.3 统一与赋值的区别

**对比**：

```rego
package unification_vs_assignment

import rego.v1

# 统一 (=) - 双向约束
test_unification if {
    x = 10        # x绑定为10
    10 = x        # 也成功（交换律）
    [a, b] = [1, 2]  # 模式匹配
}

# 赋值 (:=) - 单向绑定
test_assignment if {
    x := 10       # x赋值为10
    # 10 := x    # ❌ 错误! 赋值左侧必须是变量
    
    # 赋值可以覆盖（局部作用域）
    y := 1
    y := 2        # y在新作用域中为2
}

# 比较 (==) - 值相等检查
test_comparison if {
    x = 10
    x == 10       # 比较值
    x == 5        # 失败
}
```

**使用指南**：

| 操作符 | 用途 | 特性 |
|-------|------|-----|
| `=` | 统一 | 模式匹配、双向、可重复绑定 |
| `:=` | 赋值 | 计算表达式、单向、作用域内唯一 |
| `==` | 比较 | 值相等测试、不绑定变量 |

---

## 3. Top-Down求值

### 3.1 查询求值过程

**求值树示例**：

```rego
package authz

import rego.v1

allow if {
    user_is_admin
    action_is_permitted
}

user_is_admin if {
    input.user.role == "admin"
}

action_is_permitted if {
    input.action in ["read", "write"]
}
```

**求值树**：

```text
目标: allow
├─ 子目标1: user_is_admin
│  └─ input.user.role == "admin"
│     ├─ 绑定: input.user.role → "admin"
│     └─ 成功 ✓
│
└─ 子目标2: action_is_permitted
   └─ input.action in ["read", "write"]
      ├─ 绑定: input.action → "read"
      └─ 成功 ✓

最终结果: allow = true
```

### 3.2 回溯机制

**回溯示例**：

```rego
package backtracking

import rego.v1

# 查找所有满足条件的配对
valid_pairs := [[x, y] |
    some x in [1, 2, 3]
    some y in [10, 20, 30]
    x + y > 25
]
```

**回溯过程**：

```text
尝试 x=1:
  尝试 y=10: 1+10=11 < 25 ❌ 回溯
  尝试 y=20: 1+20=21 < 25 ❌ 回溯
  尝试 y=30: 1+30=31 > 25 ✓ → [1, 30]

尝试 x=2:
  尝试 y=10: 2+10=12 < 25 ❌ 回溯
  尝试 y=20: 2+20=22 < 25 ❌ 回溯
  尝试 y=30: 2+30=32 > 25 ✓ → [2, 30]

尝试 x=3:
  尝试 y=10: 3+10=13 < 25 ❌ 回溯
  尝试 y=20: 3+20=23 < 25 ❌ 回溯
  尝试 y=30: 3+30=33 > 25 ✓ → [3, 30]

结果: [[1, 30], [2, 30], [3, 30]]
```

### 3.3 规则匹配

**多规则匹配**：

```rego
package multi_rule

import rego.v1

# 规则1: 管理员总是允许
allow if {
    input.user.role == "admin"
}

# 规则2: 资源所有者允许
allow if {
    input.user.id == data.resources[input.resource].owner
}

# 规则3: 团队成员只读允许
allow if {
    input.user.team == data.resources[input.resource].team
    input.action == "read"
}
```

**求值逻辑**：

```text
查询: allow

尝试规则1:
  input.user.role == "admin"
  → 失败 (role = "user")

尝试规则2:
  input.user.id == data.resources[input.resource].owner
  → 失败 (不是所有者)

尝试规则3:
  input.user.team == data.resources[input.resource].team
  → 成功 (team匹配)
  input.action == "read"
  → 成功

最终: allow = true (规则3成功)
```

---

## 4. 变量绑定

### 4.1 变量作用域

**作用域规则**：

```rego
package scoping

import rego.v1

# 全局变量（规则级别）
global_var := 100

rule1 if {
    # 局部变量
    local_x := 10
    local_y := 20
    local_x + local_y == 30
}

rule2 if {
    # local_x 在这里不可见
    # global_var 可见
    global_var == 100
}

# 推导中的作用域
array := [x |
    some x in [1, 2, 3]
    # x只在这个推导内可见
]

# some的作用域
test_some if {
    some x in [1, 2, 3]
    # x在整个规则体内可见
    y := x * 2
}
```

### 4.2 变量绑定顺序

**依赖顺序**：

```rego
package binding_order

import rego.v1

# ✅ 正确: 先绑定后使用
valid if {
    x := 10           # 1. 绑定x
    y := x * 2        # 2. 使用x，绑定y
    y > 15            # 3. 使用y
}

# ❌ 错误: 未绑定变量
invalid if {
    y := x * 2        # x未绑定!
    x := 10
}

# ✅ 统一可以任意顺序
flexible if {
    x + y == 30       # x和y的约束
    x == 10           # x绑定
    # y自动推导为20
}
```

### 4.3 未绑定变量

**安全性规则**：

```rego
package safety

import rego.v1

# ❌ 不安全: 否定中的未绑定变量
unsafe1 if {
    not input.user == x  # x未绑定
}

# ✅ 安全: 先绑定再否定
safe1 if {
    x := "admin"
    not input.user == x
}

# ❌ 不安全: 推导中未绑定变量
unsafe2 := [x | x > 10]  # x来源未知

# ✅ 安全: 明确变量来源
safe2 := [x | 
    some x in [1, 2, 3, 10, 20]
    x > 10
]
```

---

## 5. 集合推导求值

### 5.1 数组推导

**求值过程**：

```rego
package array_comprehension

import rego.v1

# 简单数组推导
squares := [x * x | some x in [1, 2, 3, 4, 5]]
# 求值:
# 1. x=1: 1*1=1  → [1]
# 2. x=2: 2*2=4  → [1, 4]
# 3. x=3: 3*3=9  → [1, 4, 9]
# 4. x=4: 4*4=16 → [1, 4, 9, 16]
# 5. x=5: 5*5=25 → [1, 4, 9, 16, 25]

# 带过滤的推导
evens := [x | 
    some x in [1, 2, 3, 4, 5, 6]
    x % 2 == 0
]
# 求值:
# x=1: 1%2=1 ≠ 0 ❌ 跳过
# x=2: 2%2=0 ✓ → [2]
# x=3: 3%2=1 ❌ 跳过
# x=4: 4%2=0 ✓ → [2, 4]
# x=5: 5%2=1 ❌ 跳过
# x=6: 6%2=0 ✓ → [2, 4, 6]
```

### 5.2 对象推导

**键值对生成**：

```rego
package object_comprehension

import rego.v1

users := [
    {"id": "u1", "name": "alice", "role": "admin"},
    {"id": "u2", "name": "bob", "role": "user"},
    {"id": "u3", "name": "charlie", "role": "user"}
]

# 对象推导: id → name
user_names := {user.id: user.name | 
    some user in users
}
# 结果: {"u1": "alice", "u2": "bob", "u3": "charlie"}

# 带过滤
admin_names := {user.id: user.name |
    some user in users
    user.role == "admin"
}
# 结果: {"u1": "alice"}
```

### 5.3 集合推导

**去重特性**：

```rego
package set_comprehension

import rego.v1

data_points := [
    {"category": "A", "value": 10},
    {"category": "B", "value": 20},
    {"category": "A", "value": 15}
]

# 集合推导（自动去重）
categories := {point.category | some point in data_points}
# 结果: {"A", "B"}  (A只出现一次)

# 对比数组推导（不去重）
categories_array := [point.category | some point in data_points]
# 结果: ["A", "B", "A"]  (A出现两次)
```

---

## 6. 否定与全称量化

### 6.1 否定求值

**否定即失败（Negation as Failure）**：

```rego
package negation

import rego.v1

# 基本否定
deny if {
    not allow  # allow失败时deny成功
}

# 否定约束
not_admin if {
    not input.user.role == "admin"
}

# 复杂否定
no_conflicts if {
    not has_conflict
}

has_conflict if {
    some r1 in data.roles
    some r2 in data.roles
    r1 != r2
    r1.permissions & r2.permissions != set()
}
```

**求值过程**：

```text
求值 not P:
1. 尝试求值 P
2. 如果 P 成功 → not P 失败
3. 如果 P 失败 → not P 成功

注意: 
- not不绑定变量
- not中的变量必须已绑定
```

### 6.2 全称量化

**every关键字（Rego v1.0）**：

```rego
package quantification

import rego.v1

pods := [
    {"name": "pod1", "image": "alpine:3.14"},
    {"name": "pod2", "image": "nginx:1.21"},
    {"name": "pod3", "image": "redis:6.2"}
]

# 全称量化: 所有Pod必须来自允许的注册表
all_images_allowed if {
    every pod in pods {
        startswith(pod.image, "docker.io/") or
        startswith(pod.image, "gcr.io/")
    }
}

# 等价的传统写法
all_images_allowed_traditional if {
    not any_image_disallowed
}

any_image_disallowed if {
    some pod in pods
    not startswith(pod.image, "docker.io/")
    not startswith(pod.image, "gcr.io/")
}
```

### 6.3 安全性约束

**不安全示例与修复**：

```rego
package safety_constraints

import rego.v1

# ❌ 不安全: 否定中引入新变量
unsafe_negation if {
    not input.user == x  # x未绑定
}

# ✅ 安全: 先绑定变量
safe_negation if {
    some x in data.allowed_users
    not input.user == x
}

# ❌ 不安全: 全称量化中的未绑定变量
unsafe_quantification := [x |
    every y in data.items {
        x > y  # x来自哪里?
    }
]

# ✅ 安全: 明确变量来源
safe_quantification := [x |
    some x in data.candidates
    every y in data.items {
        x > y
    }
]
```

---

## 7. 部分求值

### 7.1 部分求值原理

**基本概念**：

```text
部分求值 = 编译时优化 + 运行时加速

原理:
1. 将查询分为已知部分和未知部分
2. 编译时求值已知部分（data、常量）
3. 生成简化的策略（只包含未知部分）
4. 运行时只处理未知变量（input）

效果:
- 减小策略大小
- 降低运行时复杂度
- 提升求值速度
```

**示例**：

```rego
package partial_eval

import rego.v1

# 原始策略
allow if {
    user := data.users[input.user_id]
    user.role in data.roles.privileged
    input.action in user.permissions
}

# 部分求值后（假设data已知，input未知）
# allow if {
#     input.user_id == "u123"  # 用户alice
#     input.action in ["read", "write", "admin"]  # alice的权限
# }
```

### 7.2 未知变量

**指定未知变量**：

```bash
# 编译时指定input为未知
opa compile \
    --partial \
    --unknowns input \
    --output partial-bundle.tar.gz \
    policy/

# 多个未知变量
opa compile \
    --partial \
    --unknowns input.user \
    --unknowns input.action \
    policy/
```

### 7.3 优化效果

**性能对比**：

```text
场景: RBAC策略，1000个用户，10000条规则

完整求值:
  - 策略大小: 10MB
  - 加载时间: 500ms
  - 求值时间: 5ms

部分求值:
  - 策略大小: 50KB (99%减少)
  - 加载时间: 10ms (98%减少)
  - 求值时间: 0.1ms (98%减少)

适用场景:
✅ 数据变化慢，查询变化快
✅ 策略复杂，数据量大
✅ 边缘部署（WASM）
```

---

## 8. 缓存机制

### 8.1 规则缓存

**自动缓存**：

```rego
package caching

import rego.v1

# 纯函数规则（自动缓存）
expensive_computation(x) := result if {
    # 复杂计算
    result := x * x * x + x * x + x + 1
}

allow if {
    # 第一次调用: 计算并缓存
    v1 := expensive_computation(10)
    
    # 第二次调用: 直接从缓存返回
    v2 := expensive_computation(10)
    
    v1 == v2
}
```

### 8.2 内置函数缓存

**缓存配置**：

```yaml
# config.yaml
caching:
  inter_query_builtin_cache:
    max_size_bytes: 10485760  # 10MB
```

**受益的内置函数**：

```rego
package builtin_caching

import rego.v1

# http.send结果缓存（同一请求）
external_data := http.send({
    "method": "GET",
    "url": "https://api.example.com/data"
}).body

# JWT解码缓存
token_payload := io.jwt.decode(input.token)[1]

# 正则表达式缓存
matches if {
    regex.match(`^[a-z0-9-]+$`, input.name)
}
```

### 8.3 缓存失效

**缓存策略**：

```text
缓存生命周期:
├── 查询间缓存（Inter-Query Cache）
│   └── 多个查询共享
│   └── OPA进程重启时清空
│
└── 查询内缓存（Intra-Query Cache）
    └── 单个查询内有效
    └── 查询结束时清空

缓存键:
- 内置函数: 函数名 + 参数哈希
- 规则: 规则路径 + 绑定哈希
- HTTP: URL + 方法 + 请求体哈希
```

---

## 9. 短路求值

### 9.1 逻辑短路

**AND短路**：

```rego
package short_circuit

import rego.v1

# AND短路: 第一个失败后立即停止
allow if {
    cheap_check       # 快速检查
    expensive_check   # 昂贵检查（cheap_check失败时不执行）
}

cheap_check if {
    input.user != null
}

expensive_check if {
    # 昂贵的数据库查询或API调用
    user := data.users[input.user]
    user.verified == true
}
```

### 9.2 提前退出

**default规则优化**：

```rego
package early_exit

import rego.v1

# ❌ 不优化: 总是评估所有规则
default allow := false

allow if {
    condition1
    condition2
    condition3
}

# ✅ 优化: 使用else提前退出
allow := true if {
    condition1
} else := false

# ✅ 更优: 直接返回false
default allow := false

allow if {
    condition1
}
```

### 9.3 优化策略

**求值顺序优化**：

```rego
package optimization

import rego.v1

# ✅ 好: 廉价检查在前
allow if {
    input.method == "GET"           # O(1)
    input.path == "/api/public"     # O(1)
    check_rate_limit                # O(log n)
    verify_signature                # 昂贵
}

# ❌ 差: 昂贵操作在前
allow_slow if {
    verify_signature                # 总是执行
    input.method == "GET"           # 可能提前过滤
}
```

---

## 10. 性能优化

### 10.1 求值顺序优化

**策略**：

```rego
package eval_order

import rego.v1

# 原则1: 过滤性强的条件在前
users_in_department := {user |
    some user in data.users  # 10000个用户
    user.dept == "engineering"  # 过滤到100个
    user.active == true  # 过滤到50个
}

# 更好的顺序（如果active用户少）
users_in_department_optimized := {user |
    some user in data.users
    user.active == true  # 先过滤到1000个
    user.dept == "engineering"  # 再过滤到50个
}

# 原则2: 常量比较在前
allow if {
    input.action == "read"  # 常量比较，极快
    user := data.users[input.user_id]  # 数据访问
    check_permissions(user, input.resource)  # 函数调用
}
```

### 10.2 索引利用

**利用索引**：

```rego
package indexing

import rego.v1

# ❌ 线性搜索 O(n)
user_by_email_slow(email) := user if {
    some user in data.users
    user.email == email
}

# ✅ 索引访问 O(1)
# 数据结构: {"users_by_email": {"alice@example.com": {...}}}
user_by_email_fast(email) := data.users_by_email[email]

# OPA自动索引优化
# 当pattern是: data.x[_].y == constant
# OPA自动构建 y → x 的索引
```

### 10.3 复杂度分析

**常见操作复杂度**：

| 操作 | 复杂度 | 示例 |
|------|-------|------|
| 常量比较 | O(1) | `x == 10` |
| 索引访问 | O(1) | `data.users[id]` |
| 数组遍历 | O(n) | `some x in array` |
| 嵌套循环 | O(n²) | `some x in A; some y in B` |
| 集合交集 | O(min(n,m)) | `set_a & set_b` |
| 字符串匹配 | O(n*m) | `contains(str, pattern)` |
| 正则表达式 | O(n) | `regex.match(pattern, str)` |

**优化技巧**：

```rego
# ❌ O(n²): 笛卡尔积
conflicts := {[u1, u2] |
    some u1 in data.users
    some u2 in data.users
    u1.team == u2.team
}

# ✅ O(n): 分组后处理
teams := {team: members |
    some user in data.users
    team := user.team
    members := {u | some u in data.users; u.team == team}
}
```

---

## 附录A：求值形式化语义

**大步语义（Big-Step Semantics）**：

```text
求值判断: Γ ⊢ e ⇓ v
(在环境Γ下，表达式e求值为值v)

规则:

[Var]
──────────────
Γ ⊢ x ⇓ Γ(x)

[Const]
──────────────
Γ ⊢ c ⇓ c

[Unify]
Γ ⊢ t1 ⇓ v1    Γ ⊢ t2 ⇓ v2    unify(v1, v2) = θ
─────────────────────────────────────────────────
Γ ⊢ t1 = t2 ⇓ θ

[And]
Γ ⊢ e1 ⇓ θ1    Γ ∪ θ1 ⊢ e2 ⇓ θ2
──────────────────────────────────
Γ ⊢ e1; e2 ⇓ θ1 ∪ θ2

[Rule]
Γ ⊢ body ⇓ θ    Γ ∪ θ ⊢ head ⇓ v
──────────────────────────────────
Γ ⊢ (head :- body) ⇓ {v}

[Not]
Γ ⊢ e ⇓ fail
──────────────
Γ ⊢ not e ⇓ {}
```

---

## 附录B：求值调试技巧

**trace函数**：

```rego
package debugging

import rego.v1

allow if {
    trace(sprintf("检查用户: %v", [input.user]))
    user := data.users[input.user]
    
    trace(sprintf("用户角色: %v", [user.role]))
    user.role == "admin"
    
    trace("授权成功")
}
```

**print函数（开发模式）**：

```bash
# 启用print输出
opa eval -d policy.rego 'data.authz.allow' \
    -i input.json \
    --format pretty \
    --explain=full
```

**explain模式**：

```bash
# 详细求值过程
opa eval -d policy.rego 'data.authz.allow' \
    --explain=notes \
    -i input.json

# 输出:
# query:1     Enter data.authz.allow
# policy.rego:5 | Enter data.authz.allow
# policy.rego:6 | | Eval input.user.role
# policy.rego:6 | | Index data.users (matched 1 rule)
# policy.rego:7 | | Eval input.action in ["read", "write"]
# policy.rego:5 | | Exit data.authz.allow
```

---

**相关文档**：

- [Rego语法规范](./02.1-Rego语法规范.md)
- [类型系统](./02.2-类型系统.md)
- [Top-Down求值器](../03-实现架构/03.4-Top-Down求值器.md)

**参考资源**：

- Policy Language: <https://www.openpolicyagent.org/docs/latest/policy-language/>
- Policy Reference: <https://www.openpolicyagent.org/docs/latest/policy-reference/>
- Rego Playground: <https://play.openpolicyagent.org/>

