# Rego 类型系统（Type System）

> **更新日期**: 2025年10月20日  
> **Rego版本**: v1.0  
> **类型检查**: 动态强类型 + 结构化类型  
> **参考**: <https://www.openpolicyagent.org/docs/latest/policy-language/#typing>

---

## 目录

- [Rego 类型系统（Type System）](#rego-类型系统type-system)
  - [目录](#目录)
  - [1. 类型系统概述](#1-类型系统概述)
    - [1.1 类型系统特性](#11-类型系统特性)
    - [1.2 类型层次结构](#12-类型层次结构)
    - [1.3 类型检查时机](#13-类型检查时机)
  - [2. 基本类型](#2-基本类型)
    - [2.1 Null类型](#21-null类型)
    - [2.2 Boolean类型](#22-boolean类型)
    - [2.3 Number类型](#23-number类型)
    - [2.4 String类型](#24-string类型)
  - [3. 复合类型](#3-复合类型)
    - [3.1 Array类型](#31-array类型)
    - [3.2 Object类型](#32-object类型)
    - [3.3 Set类型](#33-set类型)
  - [4. 类型推断](#4-类型推断)
    - [4.1 字面量推断](#41-字面量推断)
    - [4.2 变量推断](#42-变量推断)
    - [4.3 函数返回类型推断](#43-函数返回类型推断)
  - [5. 类型兼容性](#5-类型兼容性)
    - [5.1 类型相等](#51-类型相等)
    - [5.2 子类型关系](#52-子类型关系)
    - [5.3 类型转换](#53-类型转换)
  - [6. 泛型与多态](#6-泛型与多态)
    - [6.1 参数多态](#61-参数多态)
    - [6.2 内置函数的类型签名](#62-内置函数的类型签名)
  - [7. 类型错误](#7-类型错误)
    - [7.1 常见类型错误](#71-常见类型错误)
    - [7.2 错误诊断](#72-错误诊断)
    - [7.3 错误修复策略](#73-错误修复策略)
  - [8. 类型注解（未来特性）](#8-类型注解未来特性)
    - [8.1 函数签名注解](#81-函数签名注解)
    - [8.2 变量类型注解](#82-变量类型注解)
  - [9. 实践建议](#9-实践建议)
    - [9.1 利用类型推断](#91-利用类型推断)
    - [9.2 避免类型陷阱](#92-避免类型陷阱)
    - [9.3 类型安全模式](#93-类型安全模式)
  - [附录A：类型形式化定义](#附录a类型形式化定义)
  - [附录B：类型检查算法](#附录b类型检查算法)

---

## 1. 类型系统概述

### 1.1 类型系统特性

**Rego类型系统定位**：

```text
┌────────────────────────────────────────┐
│   动态类型 (Dynamic Typing)             │
│   - 运行时类型检查                      │
│   - 灵活的变量绑定                      │
├────────────────────────────────────────┤
│   强类型 (Strong Typing)               │
│   - 禁止隐式类型转换                    │
│   - 严格的类型兼容性检查                 │
├────────────────────────────────────────┤
│   结构化类型 (Structural Typing)        │
│   - 基于值的结构而非名称                 │
│   - 灵活的对象匹配                      │
└────────────────────────────────────────┘
```

**核心特性**：

- ✅ **动态类型绑定**: 变量类型在运行时确定
- ✅ **强类型约束**: 不允许隐式类型转换（除了number）
- ✅ **类型推断**: 自动推断表达式类型
- ✅ **结构化类型**: 基于值的结构匹配
- ✅ **无类型声明**: 不需要显式类型注解（目前）

### 1.2 类型层次结构

```text
                    Any (⊤)
                      │
        ┌─────────────┼─────────────┬─────────────┐
        │             │             │             │
     Scalar       Composite     Set         Function
        │             │
    ┌───┼───┬────┐    ├─────┬─────┐
    │   │   │    │    │     │
  Null Bool Num Str Array Object
```

**类型定义**：

```text
Type τ ::=
  | Null                 # null
  | Boolean              # true | false
  | Number               # 整数 | 浮点数
  | String               # 字符串
  | Array(τ)             # [τ, τ, ...]
  | Object(String, τ)    # {k: τ, ...}
  | Set(τ)               # {τ, τ, ...}
  | Function(τ*, τ)      # (τ1, ..., τn) → τ
  | Any                  # 顶类型
```

### 1.3 类型检查时机

**编译时检查**：

```rego
package example

import rego.v1

# ✅ 编译时可检测的错误
rule if {
    x := 5
    y := "hello"
    z := x + y  # 错误: 类型不兼容
}
```

**运行时检查**：

```rego
package example

import rego.v1

# 运行时检查
rule if {
    x := input.value
    y := x + 10  # 如果input.value不是数字，运行时失败
}
```

**类型检查流程**：

```text
编译阶段:
  1. 词法分析 → Tokens
  2. 语法解析 → AST
  3. 类型推断 → Typed AST
     ├── 字面量类型
     ├── 变量类型
     └── 表达式类型
  4. 类型检查 → 验证类型兼容性
     ├── 操作符参数类型
     ├── 函数调用类型
     └── 赋值类型匹配

运行时:
  5. 求值 → 动态类型验证
     ├── Input数据类型
     ├── 外部数据类型
     └── 函数返回类型
```

---

## 2. 基本类型

### 2.1 Null类型

**定义**：

```rego
package types

import rego.v1

# Null字面量
null_value := null

# 类型检查
is_null(x) if {
    x == null
}

# 使用场景
optional_field := input.field  # 可能为null
```

**特性**：

- 唯一值: `null`
- 表示缺失或未定义
- 不等于任何其他类型的值

### 2.2 Boolean类型

**定义**：

```rego
package types

import rego.v1

# Boolean字面量
true_value := true
false_value := false

# 逻辑运算
and_result := true && false  # false
or_result := true || false   # true
not_result := not false      # true
```

**类型规则**：

```rego
# ✅ 允许: Boolean运算
x := true
y := false
z := x && y

# ❌ 禁止: 非Boolean值作为条件
rule if {
    1  # 错误: 期望Boolean，得到Number
}

# ✅ 正确: 显式比较
rule if {
    input.count > 0  # Boolean表达式
}
```

### 2.3 Number类型

**定义**：

```rego
package types

import rego.v1

# 整数
int_value := 42
neg_int := -100

# 浮点数
float_value := 3.14
scientific := 1.5e10

# 特殊值
infinity := 1e1000  # +∞ (实际会溢出)
```

**数值运算**：

```rego
# 算术运算
sum := 10 + 5        # 15
diff := 10 - 5       # 5
prod := 10 * 5       # 50
quot := 10 / 5       # 2
mod := 10 % 3        # 1

# 比较运算
gt := 10 > 5         # true
gte := 10 >= 10      # true
lt := 5 < 10         # true
lte := 5 <= 5        # true
```

**类型规则**：

```rego
# ✅ 允许: 整数与浮点混合运算
result := 10 + 3.5  # 13.5

# ❌ 禁止: Number与String运算
invalid := 10 + "5"  # 错误: 类型不兼容

# ✅ 需要显式转换
valid := 10 + to_number("5")  # 15
```

### 2.4 String类型

**定义**：

```rego
package types

import rego.v1

# 字符串字面量
simple := "hello"
with_quotes := "He said \"Hi\""
multiline := `This is
a multiline
string`

# Raw字符串
raw := `C:\path\to\file`  # 反引号，无需转义
```

**字符串操作**：

```rego
# 拼接
full_name := concat("", [input.first_name, " ", input.last_name])

# 比较
is_equal := "abc" == "abc"  # true
is_less := "abc" < "def"    # true (字典序)

# 模式匹配
matches := regex.match("^[a-z]+$", "hello")  # true
```

**类型规则**：

```rego
# ❌ 禁止: 隐式转换
invalid := "Age: " + 30  # 错误

# ✅ 显式转换
valid := sprintf("Age: %d", [30])  # "Age: 30"
```

---

## 3. 复合类型

### 3.1 Array类型

**定义**：

```rego
package types

import rego.v1

# 数组字面量
numbers := [1, 2, 3, 4, 5]
mixed := [1, "two", true, null]  # 允许混合类型
nested := [[1, 2], [3, 4]]

# 空数组
empty := []
```

**类型表示**：

```text
Array(τ) 表示元素类型为 τ 的数组

示例:
  [1, 2, 3]       → Array(Number)
  ["a", "b"]      → Array(String)
  [1, "a"]        → Array(Number | String)  # 联合类型
```

**数组操作**：

```rego
# 索引访问
first := numbers[0]  # 1
last := numbers[4]   # 5

# 切片
slice := array.slice(numbers, 1, 3)  # [2, 3]

# 连接
concat_result := array.concat([1, 2], [3, 4])  # [1, 2, 3, 4]

# 长度
length := count(numbers)  # 5
```

**类型检查**：

```rego
# ✅ 允许: 数组推导
squares := [x * x | x := numbers[_]]

# ✅ 允许: 不同元素类型
hetero := [1, "two", 3.0]

# ❌ 禁止: 非整数索引
invalid := numbers["key"]  # 错误
```

### 3.2 Object类型

**定义**：

```rego
package types

import rego.v1

# 对象字面量
person := {
    "name": "Alice",
    "age": 30,
    "active": true
}

# 嵌套对象
config := {
    "database": {
        "host": "localhost",
        "port": 5432
    },
    "cache": {
        "ttl": 300
    }
}
```

**类型表示**：

```text
Object(K, V) 表示键类型为 K，值类型为 V 的对象

示例:
  {"a": 1, "b": 2}           → Object(String, Number)
  {"x": "foo", "y": "bar"}   → Object(String, String)
  {"a": 1, "b": "two"}       → Object(String, Number | String)
```

**对象操作**：

```rego
# 属性访问
name := person.name         # "Alice"
name2 := person["name"]     # "Alice"

# 嵌套访问
host := config.database.host  # "localhost"

# 合并对象
merged := object.union(
    {"a": 1, "b": 2},
    {"b": 3, "c": 4}
)  # {"a": 1, "b": 3, "c": 4}

# 移除键
removed := object.remove(person, {"age"})
```

**结构化类型匹配**：

```rego
# 结构匹配
valid_user(user) if {
    user.name  # 必须有name字段
    user.age   # 必须有age字段
    is_number(user.age)
}

# 部分匹配
has_config if {
    input.config.database.host  # 嵌套字段存在
}
```

### 3.3 Set类型

**定义**：

```rego
package types

import rego.v1

# Set字面量
numbers_set := {1, 2, 3, 4, 5}
strings_set := {"apple", "banana", "cherry"}

# 空Set
empty_set := set()

# Set推导
even_set := {x | x := numbers[_]; x % 2 == 0}
```

**类型表示**：

```text
Set(τ) 表示元素类型为 τ 的集合

特性:
  - 无序
  - 唯一性（自动去重）
  - 支持集合运算
```

**Set操作**：

```rego
# 成员测试
is_member := 3 in numbers_set  # true

# 并集
union := numbers_set | {6, 7}  # {1, 2, 3, 4, 5, 6, 7}

# 交集
intersection := {1, 2, 3} & {2, 3, 4}  # {2, 3}

# 差集
difference := {1, 2, 3} - {2}  # {1, 3}

# 大小
size := count(numbers_set)  # 5
```

**类型检查**：

```rego
# ✅ 允许: Set推导
admins := {u | u := data.users[_]; u.role == "admin"}

# ✅ 允许: 混合类型Set
mixed_set := {1, "two", true}

# ❌ Set字面量语法陷阱
not_a_set := {1}  # 这是Set: {1}
also_set := {x | x := 1}  # 这也是Set: {1}
```

---

## 4. 类型推断

### 4.1 字面量推断

```rego
package inference

import rego.v1

# 直接推断
x := 42            # x: Number
y := "hello"       # y: String
z := true          # z: Boolean
w := null          # w: Null

# 复合类型推断
arr := [1, 2, 3]   # arr: Array(Number)
obj := {"a": 1}    # obj: Object(String, Number)
set_val := {1, 2}  # set_val: Set(Number)
```

### 4.2 变量推断

```rego
package inference

import rego.v1

# 从input推断
user_name := input.user.name  # 类型取决于运行时input

# 从data推断
role := data.roles[input.user.role]

# 从迭代推断
user_ids := [u.id | u := data.users[_]]  # Array(?)
# 类型取决于data.users[_].id的类型
```

**推断规则**：

```text
Γ ⊢ e : τ  (在环境Γ下，表达式e的类型为τ)

[Lit-Num]
──────────────
Γ ⊢ n : Number

[Lit-Str]
──────────────
Γ ⊢ "s" : String

[Var]
x : τ ∈ Γ
──────────────
Γ ⊢ x : τ

[Array]
Γ ⊢ e₁ : τ  ...  Γ ⊢ eₙ : τ
─────────────────────────────
Γ ⊢ [e₁, ..., eₙ] : Array(τ)
```

### 4.3 函数返回类型推断

```rego
package inference

import rego.v1

# 内置函数
len := count([1, 2, 3])        # len: Number
upper := upper("hello")         # upper: String
keys := object.keys({"a": 1})   # keys: Array(String)

# 用户定义函数
add(x, y) := x + y

result := add(1, 2)  # result: Number (推断自x + y)
```

---

## 5. 类型兼容性

### 5.1 类型相等

```rego
package compatibility

import rego.v1

# 类型相等判断
type_eq(x, y) if {
    type_name(x) == type_name(y)
}

# 示例
eq1 := type_eq(1, 2)         # true (都是Number)
eq2 := type_eq(1, "1")       # false (Number vs String)
eq3 := type_eq([1], [2])     # true (都是Array)
```

### 5.2 子类型关系

Rego不支持传统的子类型关系，但有结构化兼容性：

```rego
# 结构化类型匹配
matches_schema(obj, schema) if {
    # 检查obj是否包含schema要求的所有字段
    required_keys := {k | schema[k]}
    object_keys := {k | obj[k]}
    required_keys & object_keys == required_keys
}

# 示例
user := {"name": "Alice", "age": 30, "email": "alice@example.com"}
schema := {"name": null, "age": null}  # 只要求name和age

valid := matches_schema(user, schema)  # true
```

### 5.3 类型转换

**显式转换函数**：

```rego
package conversion

import rego.v1

# Number ← String
num := to_number("42")     # 42

# String ← Number
str := format_int(42, 10)  # "42"
str2 := sprintf("%d", [42]) # "42"

# Array ← Set
arr := [x | x := {1, 2, 3}[_]]  # [1, 2, 3] (顺序不定)

# Set ← Array
set_val := {x | x := [1, 1, 2, 3][_]}  # {1, 2, 3}
```

**类型转换规则**：

```text
✅ 允许的转换:
  - String → Number: to_number()
  - Number → String: sprintf(), format_int()
  - Array ↔ Set: 推导
  - Any → String: 序列化

❌ 禁止的转换:
  - 自动类型转换（除Number内部）
  - Boolean ↔ Number (不像C语言)
  - null → 其他类型
```

---

## 6. 泛型与多态

### 6.1 参数多态

Rego的内置函数支持参数多态：

```rego
package polymorphism

import rego.v1

# count()函数是多态的
count_array := count([1, 2, 3])      # 3
count_set := count({1, 2, 3})        # 3
count_object := count({"a": 1})      # 1
count_string := count("hello")       # 5

# array.concat()是多态的
concat1 := array.concat([1, 2], [3, 4])      # [1, 2, 3, 4]
concat2 := array.concat(["a"], ["b", "c"])   # ["a", "b", "c"]
```

**类型签名表示**：

```text
count: ∀α. Collection(α) → Number

array.concat: ∀α. (Array(α), Array(α)) → Array(α)

object.get: ∀α, β. (Object(α, β), α, β) → β
```

### 6.2 内置函数的类型签名

```rego
# 字符串函数
concat: (String, Array(String)) → String
split: (String, String) → Array(String)
sprintf: (String, Array(Any)) → String

# 数组函数
array.slice: ∀α. (Array(α), Number, Number) → Array(α)
sort: ∀α. Array(α) → Array(α)

# 集合函数
union: ∀α. (Set(α), Set(α)) → Set(α)
intersection: ∀α. (Set(α), Set(α)) → Set(α)

# 对象函数
object.get: ∀α, β. (Object(α, β), α, β) → β
object.remove: ∀α, β. (Object(α, β), Set(α)) → Object(α, β)
```

---

## 7. 类型错误

### 7.1 常见类型错误

**算术运算类型错误**：

```rego
# ❌ 错误: Number + String
result := 10 + "5"
# 错误: operands must be numbers

# ✅ 正确: 显式转换
result := 10 + to_number("5")
```

**比较运算类型错误**：

```rego
# ❌ 错误: 不同类型比较
cmp := "10" > 5
# 错误: type mismatch

# ✅ 正确: 相同类型
cmp1 := 10 > 5        # true
cmp2 := "10" > "5"    # true (字典序)
```

**函数参数类型错误**：

```rego
# ❌ 错误: 参数类型不匹配
result := count(42)
# 错误: operand must be object, array, set, or string

# ✅ 正确: 使用正确类型
result := count([42])  # 1
```

### 7.2 错误诊断

**类型错误消息格式**：

```text
error: type error
  location: policy.rego:10
  message: operand 1 must be number but got string
  have: "10"
  want: number
```

**调试策略**：

```rego
# 1. 使用type_name()检查类型
debug_type(x) := type_name(x)

# 2. 条件类型检查
safe_add(x, y) := result if {
    is_number(x)
    is_number(y)
    result := x + y
}

# 3. 提供类型guard
validate_input if {
    is_object(input)
    is_string(input.user)
    is_number(input.age)
}
```

### 7.3 错误修复策略

**策略1: 显式类型转换**：

```rego
# 问题
age := input.age + 1  # 如果input.age是字符串会失败

# 修复
age := to_number(input.age) + 1
```

**策略2: 类型防护**：

```rego
# 问题
process_value(v) := v * 2  # 假设v是数字

# 修复
process_value(v) := v * 2 if {
    is_number(v)
}

process_value(v) := 0 if {
    not is_number(v)
}
```

**策略3: 默认值**：

```rego
# 问题
age := input.age  # 可能不存在或类型错误

# 修复
age := to_number(object.get(input, "age", "0"))
```

---

## 8. 类型注解（未来特性）

### 8.1 函数签名注解

**提案语法**（尚未实现）：

```rego
# 类型注解提案
add(x: number, y: number) -> number := x + y

get_user(id: string) -> object := data.users[id]

validate_age(age: number) -> boolean if {
    age >= 18
}
```

### 8.2 变量类型注解

**提案语法**：

```rego
# 变量类型注解
user: object := input.user
age: number := user.age
permissions: set[string] := user.permissions
```

**现状**：目前只能通过运行时检查模拟：

```rego
ensure_type(value, expected_type) if {
    type_name(value) == expected_type
}

rule if {
    ensure_type(input.user, "object")
    ensure_type(input.user.age, "number")
    # ... 使用input.user
}
```

---

## 9. 实践建议

### 9.1 利用类型推断

```rego
# ✅ 好: 让类型推断工作
numbers := [1, 2, 3, 4, 5]
doubled := [x * 2 | x := numbers[_]]  # 自动推断为Array(Number)

# ✅ 好: 明确的类型使用
user_ids := {u.id | u := data.users[_]; is_string(u.id)}
```

### 9.2 避免类型陷阱

**陷阱1: 隐式期望**：

```rego
# ❌ 危险: 假设input.count是数字
rule if {
    input.count > 10
}

# ✅ 安全: 显式检查
rule if {
    is_number(input.count)
    input.count > 10
}
```

**陷阱2: 混合类型数组**：

```rego
# ⚠️ 可能有问题: 混合类型
mixed := [1, "two", 3]
sum := sum([x | x := mixed[_]; is_number(x)])  # 需要过滤

# ✅ 更好: 统一类型
numbers := [1, 2, 3]
sum := sum(numbers)
```

### 9.3 类型安全模式

**模式1: 输入验证**：

```rego
package authz

import rego.v1

default allow := false

allow if {
    valid_input
    # ... 授权逻辑
}

valid_input if {
    is_object(input)
    is_string(input.user)
    is_string(input.action)
    is_string(input.resource)
}
```

**模式2: 防御性编程**：

```rego
# 提供多个规则体，处理不同类型
process(x) := x * 2 if {
    is_number(x)
}

process(x) := to_number(x) * 2 if {
    is_string(x)
}

process(x) := 0 if {
    not is_number(x)
    not is_string(x)
}
```

**模式3: 类型工具函数**：

```rego
# 类型检查辅助函数
is_valid_user(user) if {
    is_object(user)
    is_string(user.id)
    is_string(user.name)
    is_array(user.roles)
}

is_valid_request(req) if {
    is_object(req)
    is_string(req.method)
    is_string(req.path)
}
```

---

## 附录A：类型形式化定义

**类型语法**：

```text
Types:
  τ ::= Null                       # Null类型
      | Boolean                    # Boolean类型
      | Number                     # Number类型
      | String                     # String类型
      | Array(τ)                   # 数组类型
      | Object(String, τ)          # 对象类型
      | Set(τ)                     # 集合类型
      | τ₁ | τ₂                    # 联合类型
      | Any                        # 顶类型
```

**类型判断**：

```text
Γ ⊢ e : τ

环境Γ中，表达式e的类型为τ
```

**类型规则**：

```text
[T-Null]
──────────────
Γ ⊢ null : Null

[T-Bool]
──────────────────
Γ ⊢ true : Boolean
Γ ⊢ false : Boolean

[T-Num]
──────────────
Γ ⊢ n : Number

[T-Str]
──────────────
Γ ⊢ "s" : String

[T-Array]
Γ ⊢ e₁ : τ  ...  Γ ⊢ eₙ : τ
─────────────────────────────
Γ ⊢ [e₁, ..., eₙ] : Array(τ)

[T-Object]
Γ ⊢ v₁ : τ  ...  Γ ⊢ vₙ : τ
────────────────────────────────────
Γ ⊢ {k₁: v₁, ..., kₙ: vₙ} : Object(String, τ)

[T-Set]
Γ ⊢ e₁ : τ  ...  Γ ⊢ eₙ : τ
─────────────────────────────
Γ ⊢ {e₁, ..., eₙ} : Set(τ)

[T-Add]
Γ ⊢ e₁ : Number  Γ ⊢ e₂ : Number
──────────────────────────────────
Γ ⊢ e₁ + e₂ : Number

[T-Concat]
Γ ⊢ e₁ : String  Γ ⊢ e₂ : String
──────────────────────────────────
Γ ⊢ concat(e₁, [e₂]) : String
```

---

## 附录B：类型检查算法

**类型推断算法**：

```python
def infer_type(expr, env):
    """推断表达式的类型"""
    match expr:
        case Literal(value):
            return typeof(value)
        
        case Variable(name):
            return env.lookup(name)
        
        case Array(elements):
            elem_types = [infer_type(e, env) for e in elements]
            unified = unify_types(elem_types)
            return ArrayType(unified)
        
        case Object(pairs):
            val_types = [infer_type(v, env) for k, v in pairs]
            unified = unify_types(val_types)
            return ObjectType(StringType(), unified)
        
        case BinaryOp(op, left, right):
            left_type = infer_type(left, env)
            right_type = infer_type(right, env)
            return check_binary_op(op, left_type, right_type)

def unify_types(types):
    """统一多个类型"""
    if len(types) == 0:
        return AnyType()
    if all(t == types[0] for t in types):
        return types[0]
    return UnionType(types)

def check_binary_op(op, left_type, right_type):
    """检查二元操作符的类型"""
    if op in ['+', '-', '*', '/', '%']:
        if left_type == NumberType() and right_type == NumberType():
            return NumberType()
        else:
            raise TypeError(f"Expected numbers, got {left_type} and {right_type}")
    
    if op in ['==', '!=', '<', '>', '<=', '>=']:
        if left_type == right_type:
            return BooleanType()
        else:
            raise TypeError(f"Cannot compare {left_type} and {right_type}")
    
    # ... 其他操作符
```

---

**相关文档**：

- [Rego语法规范](./02.1-Rego语法规范.md)
- [内置函数库](./02.3-内置函数库.md)
- [Rego形式化语义](../06-形式化证明/06.2-Rego形式化语义.md)

**参考资源**：

- Type System: <https://www.openpolicyagent.org/docs/latest/policy-language/#typing>
- Built-in Functions: <https://www.openpolicyagent.org/docs/latest/policy-reference/>
