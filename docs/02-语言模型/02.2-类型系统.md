# Rego ç±»å‹ç³»ç»Ÿï¼ˆType Systemï¼‰

> **é€‚ç”¨ç‰ˆæœ¬**: OPA v0.42+ (Rego v1) | æ¨è v0.68+  
> **Regoç‰ˆæœ¬**: v1.0  
> **ç±»å‹æ£€æŸ¥**: åŠ¨æ€å¼ºç±»å‹ + ç»“æ„åŒ–ç±»å‹  
> **æœ€åéªŒè¯**: 2025-10-21  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²éªŒè¯  
> **å‚è€ƒ**: <https://www.openpolicyagent.org/docs/latest/policy-language/#typing>

---

## ğŸ“– ç±»å‹ç³»ç»Ÿè¦ç‚¹

> **ç†è§£Regoç±»å‹ç³»ç»Ÿ**:
>
> - âœ… Regoæ˜¯**åŠ¨æ€ç±»å‹**è¯­è¨€ï¼Œè¿è¡Œæ—¶æ‰æ£€æŸ¥ç±»å‹
> - âœ… ä½¿ç”¨**ç»“æ„åŒ–ç±»å‹**ï¼ˆStructural Typingï¼‰ï¼ŒåŸºäºå€¼çš„å½¢çŠ¶
> - âœ… æ”¯æŒ**ç±»å‹æ¨æ–­**ï¼Œå¤šæ•°æƒ…å†µæ— éœ€æ˜¾å¼å£°æ˜ç±»å‹
> - âš ï¸ ç±»å‹é”™è¯¯åœ¨è¿è¡Œæ—¶æ‰ä¼šæš´éœ²ï¼Œéœ€è¦å®Œæ•´æµ‹è¯•è¦†ç›–
> - âš ï¸ ä¸é™æ€ç±»å‹è¯­è¨€ï¼ˆå¦‚Go/Javaï¼‰æœ‰æœ¬è´¨å·®å¼‚
>
> **å®è·µå»ºè®®**:
>
> - ç¼–å†™å•å…ƒæµ‹è¯•è¦†ç›–å„ç§ç±»å‹ç»„åˆ
> - ä½¿ç”¨`opa check`è¿›è¡Œé™æ€åˆ†æ
> - åˆ©ç”¨ç±»å‹æ¨æ–­ç®€åŒ–ä»£ç 
>
> ç›¸å…³: [Regoè¯­æ³•è§„èŒƒ](02.1-Regoè¯­æ³•è§„èŒƒ.md) | [å†…ç½®å‡½æ•°åº“](02.3-å†…ç½®å‡½æ•°åº“.md)

---

## ğŸ“ English Summary

This document explains Rego's dynamic type system and structural typing semantics.

**Key Topics**:

- **Type Categories**: Scalars (null, boolean, number, string), Composites (object, array, set)
- **Structural Typing**: Type compatibility based on value shape, not explicit declarations
- **Type Inference**: Automatic type inference from context
- **Type Checking**: Runtime type checking, type errors and handling
- **Best Practices**: Type safety strategies, unit testing for type coverage

**Target Audience**: Rego developers, policy authors needing deep language understanding.

**Version**: Rego v1.0 (OPA v0.42+)

---

## ç›®å½•

- [Rego ç±»å‹ç³»ç»Ÿï¼ˆType Systemï¼‰](#rego-ç±»å‹ç³»ç»Ÿtype-system)
  - [ğŸ“– ç±»å‹ç³»ç»Ÿè¦ç‚¹](#-ç±»å‹ç³»ç»Ÿè¦ç‚¹)
  - [ğŸ“ English Summary](#-english-summary)
  - [ç›®å½•](#ç›®å½•)
  - [1. ç±»å‹ç³»ç»Ÿæ¦‚è¿°](#1-ç±»å‹ç³»ç»Ÿæ¦‚è¿°)
    - [1.1 ç±»å‹ç³»ç»Ÿç‰¹æ€§](#11-ç±»å‹ç³»ç»Ÿç‰¹æ€§)
    - [1.2 ç±»å‹å±‚æ¬¡ç»“æ„](#12-ç±»å‹å±‚æ¬¡ç»“æ„)
    - [1.3 ç±»å‹æ£€æŸ¥æ—¶æœº](#13-ç±»å‹æ£€æŸ¥æ—¶æœº)
  - [2. åŸºæœ¬ç±»å‹](#2-åŸºæœ¬ç±»å‹)
    - [2.1 Nullç±»å‹](#21-nullç±»å‹)
    - [2.2 Booleanç±»å‹](#22-booleanç±»å‹)
    - [2.3 Numberç±»å‹](#23-numberç±»å‹)
    - [2.4 Stringç±»å‹](#24-stringç±»å‹)
  - [3. å¤åˆç±»å‹](#3-å¤åˆç±»å‹)
    - [3.1 Arrayç±»å‹](#31-arrayç±»å‹)
    - [3.2 Objectç±»å‹](#32-objectç±»å‹)
    - [3.3 Setç±»å‹](#33-setç±»å‹)
  - [4. ç±»å‹æ¨æ–­](#4-ç±»å‹æ¨æ–­)
    - [4.1 å­—é¢é‡æ¨æ–­](#41-å­—é¢é‡æ¨æ–­)
    - [4.2 å˜é‡æ¨æ–­](#42-å˜é‡æ¨æ–­)
    - [4.3 å‡½æ•°è¿”å›ç±»å‹æ¨æ–­](#43-å‡½æ•°è¿”å›ç±»å‹æ¨æ–­)
  - [5. ç±»å‹å…¼å®¹æ€§](#5-ç±»å‹å…¼å®¹æ€§)
    - [5.1 ç±»å‹ç›¸ç­‰](#51-ç±»å‹ç›¸ç­‰)
    - [5.2 å­ç±»å‹å…³ç³»](#52-å­ç±»å‹å…³ç³»)
    - [5.3 ç±»å‹è½¬æ¢](#53-ç±»å‹è½¬æ¢)
  - [6. æ³›å‹ä¸å¤šæ€](#6-æ³›å‹ä¸å¤šæ€)
    - [6.1 å‚æ•°å¤šæ€](#61-å‚æ•°å¤šæ€)
    - [6.2 å†…ç½®å‡½æ•°çš„ç±»å‹ç­¾å](#62-å†…ç½®å‡½æ•°çš„ç±»å‹ç­¾å)
  - [7. ç±»å‹é”™è¯¯](#7-ç±»å‹é”™è¯¯)
    - [7.1 å¸¸è§ç±»å‹é”™è¯¯](#71-å¸¸è§ç±»å‹é”™è¯¯)
    - [7.2 é”™è¯¯è¯Šæ–­](#72-é”™è¯¯è¯Šæ–­)
    - [7.3 é”™è¯¯ä¿®å¤ç­–ç•¥](#73-é”™è¯¯ä¿®å¤ç­–ç•¥)
  - [8. ç±»å‹æ³¨è§£ï¼ˆæœªæ¥ç‰¹æ€§ï¼‰](#8-ç±»å‹æ³¨è§£æœªæ¥ç‰¹æ€§)
    - [8.1 å‡½æ•°ç­¾åæ³¨è§£](#81-å‡½æ•°ç­¾åæ³¨è§£)
    - [8.2 å˜é‡ç±»å‹æ³¨è§£](#82-å˜é‡ç±»å‹æ³¨è§£)
  - [9. å®è·µå»ºè®®](#9-å®è·µå»ºè®®)
    - [9.1 åˆ©ç”¨ç±»å‹æ¨æ–­](#91-åˆ©ç”¨ç±»å‹æ¨æ–­)
    - [9.2 é¿å…ç±»å‹é™·é˜±](#92-é¿å…ç±»å‹é™·é˜±)
    - [9.3 ç±»å‹å®‰å…¨æ¨¡å¼](#93-ç±»å‹å®‰å…¨æ¨¡å¼)
  - [é™„å½•Aï¼šç±»å‹å½¢å¼åŒ–å®šä¹‰](#é™„å½•aç±»å‹å½¢å¼åŒ–å®šä¹‰)
  - [é™„å½•Bï¼šç±»å‹æ£€æŸ¥ç®—æ³•](#é™„å½•bç±»å‹æ£€æŸ¥ç®—æ³•)

---

## 1. ç±»å‹ç³»ç»Ÿæ¦‚è¿°

### 1.1 ç±»å‹ç³»ç»Ÿç‰¹æ€§

**Regoç±»å‹ç³»ç»Ÿå®šä½**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åŠ¨æ€ç±»å‹ (Dynamic Typing)             â”‚
â”‚   - è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥                      â”‚
â”‚   - çµæ´»çš„å˜é‡ç»‘å®š                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   å¼ºç±»å‹ (Strong Typing)               â”‚
â”‚   - ç¦æ­¢éšå¼ç±»å‹è½¬æ¢                    â”‚
â”‚   - ä¸¥æ ¼çš„ç±»å‹å…¼å®¹æ€§æ£€æŸ¥                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ç»“æ„åŒ–ç±»å‹ (Structural Typing)        â”‚
â”‚   - åŸºäºå€¼çš„ç»“æ„è€Œéåç§°                 â”‚
â”‚   - çµæ´»çš„å¯¹è±¡åŒ¹é…                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒç‰¹æ€§**ï¼š

- âœ… **åŠ¨æ€ç±»å‹ç»‘å®š**: å˜é‡ç±»å‹åœ¨è¿è¡Œæ—¶ç¡®å®š
- âœ… **å¼ºç±»å‹çº¦æŸ**: ä¸å…è®¸éšå¼ç±»å‹è½¬æ¢ï¼ˆé™¤äº†numberï¼‰
- âœ… **ç±»å‹æ¨æ–­**: è‡ªåŠ¨æ¨æ–­è¡¨è¾¾å¼ç±»å‹
- âœ… **ç»“æ„åŒ–ç±»å‹**: åŸºäºå€¼çš„ç»“æ„åŒ¹é…
- âœ… **æ— ç±»å‹å£°æ˜**: ä¸éœ€è¦æ˜¾å¼ç±»å‹æ³¨è§£ï¼ˆç›®å‰ï¼‰

### 1.2 ç±»å‹å±‚æ¬¡ç»“æ„

```text
                    Any (âŠ¤)
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚             â”‚             â”‚
     Scalar       Composite     Set         Function
        â”‚             â”‚
    â”Œâ”€â”€â”€â”¼â”€â”€â”€â”¬â”€â”€â”€â”€â”    â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
    â”‚   â”‚   â”‚    â”‚    â”‚     â”‚
  Null Bool Num Str Array Object
```

**ç±»å‹å®šä¹‰**ï¼š

```text
Type Ï„ ::=
  | Null                 # null
  | Boolean              # true | false
  | Number               # æ•´æ•° | æµ®ç‚¹æ•°
  | String               # å­—ç¬¦ä¸²
  | Array(Ï„)             # [Ï„, Ï„, ...]
  | Object(String, Ï„)    # {k: Ï„, ...}
  | Set(Ï„)               # {Ï„, Ï„, ...}
  | Function(Ï„*, Ï„)      # (Ï„1, ..., Ï„n) â†’ Ï„
  | Any                  # é¡¶ç±»å‹
```

### 1.3 ç±»å‹æ£€æŸ¥æ—¶æœº

**ç¼–è¯‘æ—¶æ£€æŸ¥**ï¼š

```rego
package example

import rego.v1

# âœ… ç¼–è¯‘æ—¶å¯æ£€æµ‹çš„é”™è¯¯
rule if {
    x := 5
    y := "hello"
    z := x + y  # é”™è¯¯: ç±»å‹ä¸å…¼å®¹
}
```

**è¿è¡Œæ—¶æ£€æŸ¥**ï¼š

```rego
package example

import rego.v1

# è¿è¡Œæ—¶æ£€æŸ¥
rule if {
    x := input.value
    y := x + 10  # å¦‚æœinput.valueä¸æ˜¯æ•°å­—ï¼Œè¿è¡Œæ—¶å¤±è´¥
}
```

**ç±»å‹æ£€æŸ¥æµç¨‹**ï¼š

```text
ç¼–è¯‘é˜¶æ®µ:
  1. è¯æ³•åˆ†æ â†’ Tokens
  2. è¯­æ³•è§£æ â†’ AST
  3. ç±»å‹æ¨æ–­ â†’ Typed AST
     â”œâ”€â”€ å­—é¢é‡ç±»å‹
     â”œâ”€â”€ å˜é‡ç±»å‹
     â””â”€â”€ è¡¨è¾¾å¼ç±»å‹
  4. ç±»å‹æ£€æŸ¥ â†’ éªŒè¯ç±»å‹å…¼å®¹æ€§
     â”œâ”€â”€ æ“ä½œç¬¦å‚æ•°ç±»å‹
     â”œâ”€â”€ å‡½æ•°è°ƒç”¨ç±»å‹
     â””â”€â”€ èµ‹å€¼ç±»å‹åŒ¹é…

è¿è¡Œæ—¶:
  5. æ±‚å€¼ â†’ åŠ¨æ€ç±»å‹éªŒè¯
     â”œâ”€â”€ Inputæ•°æ®ç±»å‹
     â”œâ”€â”€ å¤–éƒ¨æ•°æ®ç±»å‹
     â””â”€â”€ å‡½æ•°è¿”å›ç±»å‹
```

---

## 2. åŸºæœ¬ç±»å‹

### 2.1 Nullç±»å‹

**å®šä¹‰**ï¼š

```rego
package types

import rego.v1

# Nullå­—é¢é‡
null_value := null

# ç±»å‹æ£€æŸ¥
is_null(x) if {
    x == null
}

# ä½¿ç”¨åœºæ™¯
optional_field := input.field  # å¯èƒ½ä¸ºnull
```

**ç‰¹æ€§**ï¼š

- å”¯ä¸€å€¼: `null`
- è¡¨ç¤ºç¼ºå¤±æˆ–æœªå®šä¹‰
- ä¸ç­‰äºä»»ä½•å…¶ä»–ç±»å‹çš„å€¼

### 2.2 Booleanç±»å‹

**å®šä¹‰**ï¼š

```rego
package types

import rego.v1

# Booleanå­—é¢é‡
true_value := true
false_value := false

# é€»è¾‘è¿ç®—
and_result := true && false  # false
or_result := true || false   # true
not_result := not false      # true
```

**ç±»å‹è§„åˆ™**ï¼š

```rego
# âœ… å…è®¸: Booleanè¿ç®—
x := true
y := false
z := x && y

# âŒ ç¦æ­¢: éBooleanå€¼ä½œä¸ºæ¡ä»¶
rule if {
    1  # é”™è¯¯: æœŸæœ›Booleanï¼Œå¾—åˆ°Number
}

# âœ… æ­£ç¡®: æ˜¾å¼æ¯”è¾ƒ
rule if {
    input.count > 0  # Booleanè¡¨è¾¾å¼
}
```

### 2.3 Numberç±»å‹

**å®šä¹‰**ï¼š

```rego
package types

import rego.v1

# æ•´æ•°
int_value := 42
neg_int := -100

# æµ®ç‚¹æ•°
float_value := 3.14
scientific := 1.5e10

# ç‰¹æ®Šå€¼
infinity := 1e1000  # +âˆ (å®é™…ä¼šæº¢å‡º)
```

**æ•°å€¼è¿ç®—**ï¼š

```rego
# ç®—æœ¯è¿ç®—
sum := 10 + 5        # 15
diff := 10 - 5       # 5
prod := 10 * 5       # 50
quot := 10 / 5       # 2
mod := 10 % 3        # 1

# æ¯”è¾ƒè¿ç®—
gt := 10 > 5         # true
gte := 10 >= 10      # true
lt := 5 < 10         # true
lte := 5 <= 5        # true
```

**ç±»å‹è§„åˆ™**ï¼š

```rego
# âœ… å…è®¸: æ•´æ•°ä¸æµ®ç‚¹æ··åˆè¿ç®—
result := 10 + 3.5  # 13.5

# âŒ ç¦æ­¢: Numberä¸Stringè¿ç®—
invalid := 10 + "5"  # é”™è¯¯: ç±»å‹ä¸å…¼å®¹

# âœ… éœ€è¦æ˜¾å¼è½¬æ¢
valid := 10 + to_number("5")  # 15
```

### 2.4 Stringç±»å‹

**å®šä¹‰**ï¼š

```rego
package types

import rego.v1

# å­—ç¬¦ä¸²å­—é¢é‡
simple := "hello"
with_quotes := "He said \"Hi\""
multiline := `This is
a multiline
string`

# Rawå­—ç¬¦ä¸²
raw := `C:\path\to\file`  # åå¼•å·ï¼Œæ— éœ€è½¬ä¹‰
```

**å­—ç¬¦ä¸²æ“ä½œ**ï¼š

```rego
# æ‹¼æ¥
full_name := concat("", [input.first_name, " ", input.last_name])

# æ¯”è¾ƒ
is_equal := "abc" == "abc"  # true
is_less := "abc" < "def"    # true (å­—å…¸åº)

# æ¨¡å¼åŒ¹é…
matches := regex.match("^[a-z]+$", "hello")  # true
```

**ç±»å‹è§„åˆ™**ï¼š

```rego
# âŒ ç¦æ­¢: éšå¼è½¬æ¢
invalid := "Age: " + 30  # é”™è¯¯

# âœ… æ˜¾å¼è½¬æ¢
valid := sprintf("Age: %d", [30])  # "Age: 30"
```

---

## 3. å¤åˆç±»å‹

### 3.1 Arrayç±»å‹

**å®šä¹‰**ï¼š

```rego
package types

import rego.v1

# æ•°ç»„å­—é¢é‡
numbers := [1, 2, 3, 4, 5]
mixed := [1, "two", true, null]  # å…è®¸æ··åˆç±»å‹
nested := [[1, 2], [3, 4]]

# ç©ºæ•°ç»„
empty := []
```

**ç±»å‹è¡¨ç¤º**ï¼š

```text
Array(Ï„) è¡¨ç¤ºå…ƒç´ ç±»å‹ä¸º Ï„ çš„æ•°ç»„

ç¤ºä¾‹:
  [1, 2, 3]       â†’ Array(Number)
  ["a", "b"]      â†’ Array(String)
  [1, "a"]        â†’ Array(Number | String)  # è”åˆç±»å‹
```

**æ•°ç»„æ“ä½œ**ï¼š

```rego
# ç´¢å¼•è®¿é—®
first := numbers[0]  # 1
last := numbers[4]   # 5

# åˆ‡ç‰‡
slice := array.slice(numbers, 1, 3)  # [2, 3]

# è¿æ¥
concat_result := array.concat([1, 2], [3, 4])  # [1, 2, 3, 4]

# é•¿åº¦
length := count(numbers)  # 5
```

**ç±»å‹æ£€æŸ¥**ï¼š

```rego
# âœ… å…è®¸: æ•°ç»„æ¨å¯¼
squares := [x * x | x := numbers[_]]

# âœ… å…è®¸: ä¸åŒå…ƒç´ ç±»å‹
hetero := [1, "two", 3.0]

# âŒ ç¦æ­¢: éæ•´æ•°ç´¢å¼•
invalid := numbers["key"]  # é”™è¯¯
```

### 3.2 Objectç±»å‹

**å®šä¹‰**ï¼š

```rego
package types

import rego.v1

# å¯¹è±¡å­—é¢é‡
person := {
    "name": "Alice",
    "age": 30,
    "active": true
}

# åµŒå¥—å¯¹è±¡
config := {
    "database": {
        "host": "localhost",
        "port": 5432
    },
    "cache": {
        "ttl": 300
    }
}
```

**ç±»å‹è¡¨ç¤º**ï¼š

```text
Object(K, V) è¡¨ç¤ºé”®ç±»å‹ä¸º Kï¼Œå€¼ç±»å‹ä¸º V çš„å¯¹è±¡

ç¤ºä¾‹:
  {"a": 1, "b": 2}           â†’ Object(String, Number)
  {"x": "foo", "y": "bar"}   â†’ Object(String, String)
  {"a": 1, "b": "two"}       â†’ Object(String, Number | String)
```

**å¯¹è±¡æ“ä½œ**ï¼š

```rego
# å±æ€§è®¿é—®
name := person.name         # "Alice"
name2 := person["name"]     # "Alice"

# åµŒå¥—è®¿é—®
host := config.database.host  # "localhost"

# åˆå¹¶å¯¹è±¡
merged := object.union(
    {"a": 1, "b": 2},
    {"b": 3, "c": 4}
)  # {"a": 1, "b": 3, "c": 4}

# ç§»é™¤é”®
removed := object.remove(person, {"age"})
```

**ç»“æ„åŒ–ç±»å‹åŒ¹é…**ï¼š

```rego
# ç»“æ„åŒ¹é…
valid_user(user) if {
    user.name  # å¿…é¡»æœ‰nameå­—æ®µ
    user.age   # å¿…é¡»æœ‰ageå­—æ®µ
    is_number(user.age)
}

# éƒ¨åˆ†åŒ¹é…
has_config if {
    input.config.database.host  # åµŒå¥—å­—æ®µå­˜åœ¨
}
```

### 3.3 Setç±»å‹

**å®šä¹‰**ï¼š

```rego
package types

import rego.v1

# Setå­—é¢é‡
numbers_set := {1, 2, 3, 4, 5}
strings_set := {"apple", "banana", "cherry"}

# ç©ºSet
empty_set := set()

# Setæ¨å¯¼
even_set := {x | x := numbers[_]; x % 2 == 0}
```

**ç±»å‹è¡¨ç¤º**ï¼š

```text
Set(Ï„) è¡¨ç¤ºå…ƒç´ ç±»å‹ä¸º Ï„ çš„é›†åˆ

ç‰¹æ€§:
  - æ— åº
  - å”¯ä¸€æ€§ï¼ˆè‡ªåŠ¨å»é‡ï¼‰
  - æ”¯æŒé›†åˆè¿ç®—
```

**Setæ“ä½œ**ï¼š

```rego
# æˆå‘˜æµ‹è¯•
is_member := 3 in numbers_set  # true

# å¹¶é›†
union := numbers_set | {6, 7}  # {1, 2, 3, 4, 5, 6, 7}

# äº¤é›†
intersection := {1, 2, 3} & {2, 3, 4}  # {2, 3}

# å·®é›†
difference := {1, 2, 3} - {2}  # {1, 3}

# å¤§å°
size := count(numbers_set)  # 5
```

**ç±»å‹æ£€æŸ¥**ï¼š

```rego
# âœ… å…è®¸: Setæ¨å¯¼
admins := {u | u := data.users[_]; u.role == "admin"}

# âœ… å…è®¸: æ··åˆç±»å‹Set
mixed_set := {1, "two", true}

# âŒ Setå­—é¢é‡è¯­æ³•é™·é˜±
not_a_set := {1}  # è¿™æ˜¯Set: {1}
also_set := {x | x := 1}  # è¿™ä¹Ÿæ˜¯Set: {1}
```

---

## 4. ç±»å‹æ¨æ–­

### 4.1 å­—é¢é‡æ¨æ–­

```rego
package inference

import rego.v1

# ç›´æ¥æ¨æ–­
x := 42            # x: Number
y := "hello"       # y: String
z := true          # z: Boolean
w := null          # w: Null

# å¤åˆç±»å‹æ¨æ–­
arr := [1, 2, 3]   # arr: Array(Number)
obj := {"a": 1}    # obj: Object(String, Number)
set_val := {1, 2}  # set_val: Set(Number)
```

### 4.2 å˜é‡æ¨æ–­

```rego
package inference

import rego.v1

# ä»inputæ¨æ–­
user_name := input.user.name  # ç±»å‹å–å†³äºè¿è¡Œæ—¶input

# ä»dataæ¨æ–­
role := data.roles[input.user.role]

# ä»è¿­ä»£æ¨æ–­
user_ids := [u.id | u := data.users[_]]  # Array(?)
# ç±»å‹å–å†³äºdata.users[_].idçš„ç±»å‹
```

**æ¨æ–­è§„åˆ™**ï¼š

```text
Î“ âŠ¢ e : Ï„  (åœ¨ç¯å¢ƒÎ“ä¸‹ï¼Œè¡¨è¾¾å¼eçš„ç±»å‹ä¸ºÏ„)

[Lit-Num]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ n : Number

[Lit-Str]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ "s" : String

[Var]
x : Ï„ âˆˆ Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x : Ï„

[Array]
Î“ âŠ¢ eâ‚ : Ï„  ...  Î“ âŠ¢ eâ‚™ : Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ [eâ‚, ..., eâ‚™] : Array(Ï„)
```

### 4.3 å‡½æ•°è¿”å›ç±»å‹æ¨æ–­

```rego
package inference

import rego.v1

# å†…ç½®å‡½æ•°
len := count([1, 2, 3])        # len: Number
upper := upper("hello")         # upper: String
keys := object.keys({"a": 1})   # keys: Array(String)

# ç”¨æˆ·å®šä¹‰å‡½æ•°
add(x, y) := x + y

result := add(1, 2)  # result: Number (æ¨æ–­è‡ªx + y)
```

---

## 5. ç±»å‹å…¼å®¹æ€§

### 5.1 ç±»å‹ç›¸ç­‰

```rego
package compatibility

import rego.v1

# ç±»å‹ç›¸ç­‰åˆ¤æ–­
type_eq(x, y) if {
    type_name(x) == type_name(y)
}

# ç¤ºä¾‹
eq1 := type_eq(1, 2)         # true (éƒ½æ˜¯Number)
eq2 := type_eq(1, "1")       # false (Number vs String)
eq3 := type_eq([1], [2])     # true (éƒ½æ˜¯Array)
```

### 5.2 å­ç±»å‹å…³ç³»

Regoä¸æ”¯æŒä¼ ç»Ÿçš„å­ç±»å‹å…³ç³»ï¼Œä½†æœ‰ç»“æ„åŒ–å…¼å®¹æ€§ï¼š

```rego
# ç»“æ„åŒ–ç±»å‹åŒ¹é…
matches_schema(obj, schema) if {
    # æ£€æŸ¥objæ˜¯å¦åŒ…å«schemaè¦æ±‚çš„æ‰€æœ‰å­—æ®µ
    required_keys := {k | schema[k]}
    object_keys := {k | obj[k]}
    required_keys & object_keys == required_keys
}

# ç¤ºä¾‹
user := {"name": "Alice", "age": 30, "email": "alice@example.com"}
schema := {"name": null, "age": null}  # åªè¦æ±‚nameå’Œage

valid := matches_schema(user, schema)  # true
```

### 5.3 ç±»å‹è½¬æ¢

**æ˜¾å¼è½¬æ¢å‡½æ•°**ï¼š

```rego
package conversion

import rego.v1

# Number â† String
num := to_number("42")     # 42

# String â† Number
str := format_int(42, 10)  # "42"
str2 := sprintf("%d", [42]) # "42"

# Array â† Set
arr := [x | x := {1, 2, 3}[_]]  # [1, 2, 3] (é¡ºåºä¸å®š)

# Set â† Array
set_val := {x | x := [1, 1, 2, 3][_]}  # {1, 2, 3}
```

**ç±»å‹è½¬æ¢è§„åˆ™**ï¼š

```text
âœ… å…è®¸çš„è½¬æ¢:
  - String â†’ Number: to_number()
  - Number â†’ String: sprintf(), format_int()
  - Array â†” Set: æ¨å¯¼
  - Any â†’ String: åºåˆ—åŒ–

âŒ ç¦æ­¢çš„è½¬æ¢:
  - è‡ªåŠ¨ç±»å‹è½¬æ¢ï¼ˆé™¤Numberå†…éƒ¨ï¼‰
  - Boolean â†” Number (ä¸åƒCè¯­è¨€)
  - null â†’ å…¶ä»–ç±»å‹
```

---

## 6. æ³›å‹ä¸å¤šæ€

### 6.1 å‚æ•°å¤šæ€

Regoçš„å†…ç½®å‡½æ•°æ”¯æŒå‚æ•°å¤šæ€ï¼š

```rego
package polymorphism

import rego.v1

# count()å‡½æ•°æ˜¯å¤šæ€çš„
count_array := count([1, 2, 3])      # 3
count_set := count({1, 2, 3})        # 3
count_object := count({"a": 1})      # 1
count_string := count("hello")       # 5

# array.concat()æ˜¯å¤šæ€çš„
concat1 := array.concat([1, 2], [3, 4])      # [1, 2, 3, 4]
concat2 := array.concat(["a"], ["b", "c"])   # ["a", "b", "c"]
```

**ç±»å‹ç­¾åè¡¨ç¤º**ï¼š

```text
count: âˆ€Î±. Collection(Î±) â†’ Number

array.concat: âˆ€Î±. (Array(Î±), Array(Î±)) â†’ Array(Î±)

object.get: âˆ€Î±, Î². (Object(Î±, Î²), Î±, Î²) â†’ Î²
```

### 6.2 å†…ç½®å‡½æ•°çš„ç±»å‹ç­¾å

```rego
# å­—ç¬¦ä¸²å‡½æ•°
concat: (String, Array(String)) â†’ String
split: (String, String) â†’ Array(String)
sprintf: (String, Array(Any)) â†’ String

# æ•°ç»„å‡½æ•°
array.slice: âˆ€Î±. (Array(Î±), Number, Number) â†’ Array(Î±)
sort: âˆ€Î±. Array(Î±) â†’ Array(Î±)

# é›†åˆå‡½æ•°
union: âˆ€Î±. (Set(Î±), Set(Î±)) â†’ Set(Î±)
intersection: âˆ€Î±. (Set(Î±), Set(Î±)) â†’ Set(Î±)

# å¯¹è±¡å‡½æ•°
object.get: âˆ€Î±, Î². (Object(Î±, Î²), Î±, Î²) â†’ Î²
object.remove: âˆ€Î±, Î². (Object(Î±, Î²), Set(Î±)) â†’ Object(Î±, Î²)
```

---

## 7. ç±»å‹é”™è¯¯

### 7.1 å¸¸è§ç±»å‹é”™è¯¯

**ç®—æœ¯è¿ç®—ç±»å‹é”™è¯¯**ï¼š

```rego
# âŒ é”™è¯¯: Number + String
result := 10 + "5"
# é”™è¯¯: operands must be numbers

# âœ… æ­£ç¡®: æ˜¾å¼è½¬æ¢
result := 10 + to_number("5")
```

**æ¯”è¾ƒè¿ç®—ç±»å‹é”™è¯¯**ï¼š

```rego
# âŒ é”™è¯¯: ä¸åŒç±»å‹æ¯”è¾ƒ
cmp := "10" > 5
# é”™è¯¯: type mismatch

# âœ… æ­£ç¡®: ç›¸åŒç±»å‹
cmp1 := 10 > 5        # true
cmp2 := "10" > "5"    # true (å­—å…¸åº)
```

**å‡½æ•°å‚æ•°ç±»å‹é”™è¯¯**ï¼š

```rego
# âŒ é”™è¯¯: å‚æ•°ç±»å‹ä¸åŒ¹é…
result := count(42)
# é”™è¯¯: operand must be object, array, set, or string

# âœ… æ­£ç¡®: ä½¿ç”¨æ­£ç¡®ç±»å‹
result := count([42])  # 1
```

### 7.2 é”™è¯¯è¯Šæ–­

**ç±»å‹é”™è¯¯æ¶ˆæ¯æ ¼å¼**ï¼š

```text
error: type error
  location: policy.rego:10
  message: operand 1 must be number but got string
  have: "10"
  want: number
```

**è°ƒè¯•ç­–ç•¥**ï¼š

```rego
# 1. ä½¿ç”¨type_name()æ£€æŸ¥ç±»å‹
debug_type(x) := type_name(x)

# 2. æ¡ä»¶ç±»å‹æ£€æŸ¥
safe_add(x, y) := result if {
    is_number(x)
    is_number(y)
    result := x + y
}

# 3. æä¾›ç±»å‹guard
validate_input if {
    is_object(input)
    is_string(input.user)
    is_number(input.age)
}
```

### 7.3 é”™è¯¯ä¿®å¤ç­–ç•¥

**ç­–ç•¥1: æ˜¾å¼ç±»å‹è½¬æ¢**ï¼š

```rego
# é—®é¢˜
age := input.age + 1  # å¦‚æœinput.ageæ˜¯å­—ç¬¦ä¸²ä¼šå¤±è´¥

# ä¿®å¤
age := to_number(input.age) + 1
```

**ç­–ç•¥2: ç±»å‹é˜²æŠ¤**ï¼š

```rego
# é—®é¢˜
process_value(v) := v * 2  # å‡è®¾væ˜¯æ•°å­—

# ä¿®å¤
process_value(v) := v * 2 if {
    is_number(v)
}

process_value(v) := 0 if {
    not is_number(v)
}
```

**ç­–ç•¥3: é»˜è®¤å€¼**ï¼š

```rego
# é—®é¢˜
age := input.age  # å¯èƒ½ä¸å­˜åœ¨æˆ–ç±»å‹é”™è¯¯

# ä¿®å¤
age := to_number(object.get(input, "age", "0"))
```

---

## 8. ç±»å‹æ³¨è§£ï¼ˆæœªæ¥ç‰¹æ€§ï¼‰

### 8.1 å‡½æ•°ç­¾åæ³¨è§£

**ææ¡ˆè¯­æ³•**ï¼ˆå°šæœªå®ç°ï¼‰ï¼š

```rego
# ç±»å‹æ³¨è§£ææ¡ˆ
add(x: number, y: number) -> number := x + y

get_user(id: string) -> object := data.users[id]

validate_age(age: number) -> boolean if {
    age >= 18
}
```

### 8.2 å˜é‡ç±»å‹æ³¨è§£

**ææ¡ˆè¯­æ³•**ï¼š

```rego
# å˜é‡ç±»å‹æ³¨è§£
user: object := input.user
age: number := user.age
permissions: set[string] := user.permissions
```

**ç°çŠ¶**ï¼šç›®å‰åªèƒ½é€šè¿‡è¿è¡Œæ—¶æ£€æŸ¥æ¨¡æ‹Ÿï¼š

```rego
ensure_type(value, expected_type) if {
    type_name(value) == expected_type
}

rule if {
    ensure_type(input.user, "object")
    ensure_type(input.user.age, "number")
    # ... ä½¿ç”¨input.user
}
```

---

## 9. å®è·µå»ºè®®

### 9.1 åˆ©ç”¨ç±»å‹æ¨æ–­

```rego
# âœ… å¥½: è®©ç±»å‹æ¨æ–­å·¥ä½œ
numbers := [1, 2, 3, 4, 5]
doubled := [x * 2 | x := numbers[_]]  # è‡ªåŠ¨æ¨æ–­ä¸ºArray(Number)

# âœ… å¥½: æ˜ç¡®çš„ç±»å‹ä½¿ç”¨
user_ids := {u.id | u := data.users[_]; is_string(u.id)}
```

### 9.2 é¿å…ç±»å‹é™·é˜±

**é™·é˜±1: éšå¼æœŸæœ›**ï¼š

```rego
# âŒ å±é™©: å‡è®¾input.countæ˜¯æ•°å­—
rule if {
    input.count > 10
}

# âœ… å®‰å…¨: æ˜¾å¼æ£€æŸ¥
rule if {
    is_number(input.count)
    input.count > 10
}
```

**é™·é˜±2: æ··åˆç±»å‹æ•°ç»„**ï¼š

```rego
# âš ï¸ å¯èƒ½æœ‰é—®é¢˜: æ··åˆç±»å‹
mixed := [1, "two", 3]
sum := sum([x | x := mixed[_]; is_number(x)])  # éœ€è¦è¿‡æ»¤

# âœ… æ›´å¥½: ç»Ÿä¸€ç±»å‹
numbers := [1, 2, 3]
sum := sum(numbers)
```

### 9.3 ç±»å‹å®‰å…¨æ¨¡å¼

**æ¨¡å¼1: è¾“å…¥éªŒè¯**ï¼š

```rego
package authz

import rego.v1

default allow := false

allow if {
    valid_input
    # ... æˆæƒé€»è¾‘
}

valid_input if {
    is_object(input)
    is_string(input.user)
    is_string(input.action)
    is_string(input.resource)
}
```

**æ¨¡å¼2: é˜²å¾¡æ€§ç¼–ç¨‹**ï¼š

```rego
# æä¾›å¤šä¸ªè§„åˆ™ä½“ï¼Œå¤„ç†ä¸åŒç±»å‹
process(x) := x * 2 if {
    is_number(x)
}

process(x) := to_number(x) * 2 if {
    is_string(x)
}

process(x) := 0 if {
    not is_number(x)
    not is_string(x)
}
```

**æ¨¡å¼3: ç±»å‹å·¥å…·å‡½æ•°**ï¼š

```rego
# ç±»å‹æ£€æŸ¥è¾…åŠ©å‡½æ•°
is_valid_user(user) if {
    is_object(user)
    is_string(user.id)
    is_string(user.name)
    is_array(user.roles)
}

is_valid_request(req) if {
    is_object(req)
    is_string(req.method)
    is_string(req.path)
}
```

---

## é™„å½•Aï¼šç±»å‹å½¢å¼åŒ–å®šä¹‰

**ç±»å‹è¯­æ³•**ï¼š

```text
Types:
  Ï„ ::= Null                       # Nullç±»å‹
      | Boolean                    # Booleanç±»å‹
      | Number                     # Numberç±»å‹
      | String                     # Stringç±»å‹
      | Array(Ï„)                   # æ•°ç»„ç±»å‹
      | Object(String, Ï„)          # å¯¹è±¡ç±»å‹
      | Set(Ï„)                     # é›†åˆç±»å‹
      | Ï„â‚ | Ï„â‚‚                    # è”åˆç±»å‹
      | Any                        # é¡¶ç±»å‹
```

**ç±»å‹åˆ¤æ–­**ï¼š

```text
Î“ âŠ¢ e : Ï„

ç¯å¢ƒÎ“ä¸­ï¼Œè¡¨è¾¾å¼eçš„ç±»å‹ä¸ºÏ„
```

**ç±»å‹è§„åˆ™**ï¼š

```text
[T-Null]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ null : Null

[T-Bool]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ true : Boolean
Î“ âŠ¢ false : Boolean

[T-Num]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ n : Number

[T-Str]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ "s" : String

[T-Array]
Î“ âŠ¢ eâ‚ : Ï„  ...  Î“ âŠ¢ eâ‚™ : Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ [eâ‚, ..., eâ‚™] : Array(Ï„)

[T-Object]
Î“ âŠ¢ vâ‚ : Ï„  ...  Î“ âŠ¢ vâ‚™ : Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ {kâ‚: vâ‚, ..., kâ‚™: vâ‚™} : Object(String, Ï„)

[T-Set]
Î“ âŠ¢ eâ‚ : Ï„  ...  Î“ âŠ¢ eâ‚™ : Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ {eâ‚, ..., eâ‚™} : Set(Ï„)

[T-Add]
Î“ âŠ¢ eâ‚ : Number  Î“ âŠ¢ eâ‚‚ : Number
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ eâ‚ + eâ‚‚ : Number

[T-Concat]
Î“ âŠ¢ eâ‚ : String  Î“ âŠ¢ eâ‚‚ : String
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ concat(eâ‚, [eâ‚‚]) : String
```

---

## é™„å½•Bï¼šç±»å‹æ£€æŸ¥ç®—æ³•

**ç±»å‹æ¨æ–­ç®—æ³•**ï¼š

```python
def infer_type(expr, env):
    """æ¨æ–­è¡¨è¾¾å¼çš„ç±»å‹"""
    match expr:
        case Literal(value):
            return typeof(value)
        
        case Variable(name):
            return env.lookup(name)
        
        case Array(elements):
            elem_types = [infer_type(e, env) for e in elements]
            unified = unify_types(elem_types)
            return ArrayType(unified)
        
        case Object(pairs):
            val_types = [infer_type(v, env) for k, v in pairs]
            unified = unify_types(val_types)
            return ObjectType(StringType(), unified)
        
        case BinaryOp(op, left, right):
            left_type = infer_type(left, env)
            right_type = infer_type(right, env)
            return check_binary_op(op, left_type, right_type)

def unify_types(types):
    """ç»Ÿä¸€å¤šä¸ªç±»å‹"""
    if len(types) == 0:
        return AnyType()
    if all(t == types[0] for t in types):
        return types[0]
    return UnionType(types)

def check_binary_op(op, left_type, right_type):
    """æ£€æŸ¥äºŒå…ƒæ“ä½œç¬¦çš„ç±»å‹"""
    if op in ['+', '-', '*', '/', '%']:
        if left_type == NumberType() and right_type == NumberType():
            return NumberType()
        else:
            raise TypeError(f"Expected numbers, got {left_type} and {right_type}")
    
    if op in ['==', '!=', '<', '>', '<=', '>=']:
        if left_type == right_type:
            return BooleanType()
        else:
            raise TypeError(f"Cannot compare {left_type} and {right_type}")
    
    # ... å…¶ä»–æ“ä½œç¬¦
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [Regoè¯­æ³•è§„èŒƒ](./02.1-Regoè¯­æ³•è§„èŒƒ.md)
- [å†…ç½®å‡½æ•°åº“](./02.3-å†…ç½®å‡½æ•°åº“.md)
- [Regoå½¢å¼åŒ–è¯­ä¹‰](../06-å½¢å¼åŒ–è¯æ˜/06.2-Regoå½¢å¼åŒ–è¯­ä¹‰.md)

**å‚è€ƒèµ„æº**ï¼š

- Type System: <https://www.openpolicyagent.org/docs/latest/policy-language/#typing>
- Built-in Functions: <https://www.openpolicyagent.org/docs/latest/policy-reference/>
