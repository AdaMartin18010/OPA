# Rego 语法规范（Rego Syntax Specification）

> **更新日期**: 2025年10月20日  
> **规范版本**: Rego v1.0（语法冻结）  
> **权威来源**: <https://www.openpolicyagent.org/docs/latest/policy-language/>

---

## 目录

- [Rego 语法规范（Rego Syntax Specification）](#rego-语法规范rego-syntax-specification)
  - [目录](#目录)
  - [1. 语法概述](#1-语法概述)
    - [1.1 设计原则](#11-设计原则)
    - [1.2 基本语法模式](#12-基本语法模式)
    - [1.3 语法层次结构](#13-语法层次结构)
  - [2. 词法结构](#2-词法结构)
    - [2.1 注释（Comments）](#21-注释comments)
    - [2.2 标识符（Identifiers）](#22-标识符identifiers)
    - [2.3 字面量（Literals）](#23-字面量literals)
      - [2.3.1 布尔字面量](#231-布尔字面量)
      - [2.3.2 数值字面量](#232-数值字面量)
      - [2.3.3 字符串字面量](#233-字符串字面量)
      - [2.3.4 空值字面量](#234-空值字面量)
    - [2.4 分隔符（Delimiters）](#24-分隔符delimiters)
  - [3. 语法结构](#3-语法结构)
    - [3.1 模块结构](#31-模块结构)
    - [3.2 包声明（Package）](#32-包声明package)
    - [3.3 导入（Import）](#33-导入import)
  - [4. 数据类型](#4-数据类型)
    - [4.1 标量类型](#41-标量类型)
      - [4.1.1 Boolean（布尔）](#411-boolean布尔)
      - [4.1.2 Number（数值）](#412-number数值)
      - [4.1.3 String（字符串）](#413-string字符串)
      - [4.1.4 Null（空值）](#414-null空值)
    - [4.2 复合类型](#42-复合类型)
      - [4.2.1 Array（数组）](#421-array数组)
      - [4.2.2 Object（对象）](#422-object对象)
      - [4.2.3 Set（集合）](#423-set集合)
  - [5. 运算符](#5-运算符)
    - [5.1 统一运算符（Unification）](#51-统一运算符unification)
    - [5.2 赋值运算符（Assignment）](#52-赋值运算符assignment)
    - [5.3 比较运算符](#53-比较运算符)
    - [5.4 逻辑运算符](#54-逻辑运算符)
    - [5.5 算术运算符](#55-算术运算符)
    - [5.6 集合运算符](#56-集合运算符)
    - [5.7 成员运算符](#57-成员运算符)
  - [6. 规则定义](#6-规则定义)
    - [6.1 完全规则（Complete Rules）](#61-完全规则complete-rules)
    - [6.2 部分规则（Partial Rules）](#62-部分规则partial-rules)
      - [6.2.1 生成对象](#621-生成对象)
      - [6.2.2 生成集合](#622-生成集合)
    - [6.3 多值规则](#63-多值规则)
    - [6.4 函数规则](#64-函数规则)
  - [7. 模块化](#7-模块化)
    - [7.1 规则引用](#71-规则引用)
    - [7.2 跨包引用](#72-跨包引用)
    - [7.3 分层策略](#73-分层策略)
  - [8. 保留关键字](#8-保留关键字)
    - [8.1 当前关键字（v1.0）](#81-当前关键字v10)
    - [8.2 未来关键字（需显式导入）](#82-未来关键字需显式导入)
    - [8.3 保留但未使用](#83-保留但未使用)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 命名约定](#91-命名约定)
    - [9.2 代码组织](#92-代码组织)
    - [9.3 注释规范](#93-注释规范)
    - [9.4 性能考虑](#94-性能考虑)
    - [9.5 测试驱动](#95-测试驱动)
  - [附录 A: 完整语法图](#附录-a-完整语法图)
    - [EBNF表示](#ebnf表示)
  - [附录 B: 运算符优先级](#附录-b-运算符优先级)
  - [附录 C: 语法糖与等价形式](#附录-c-语法糖与等价形式)
  - [参考资源](#参考资源)

---

## 1. 语法概述

### 1.1 设计原则

Rego语言遵循以下核心设计原则：

1. **声明式**：描述"什么"而非"如何"
2. **无副作用**：纯函数式，无全局状态修改
3. **可组合**：规则可以相互引用和组合
4. **数据驱动**：策略与数据分离
5. **类Datalog**：基于逻辑编程范式

### 1.2 基本语法模式

```rego
# 最简单的规则
allow := true

# 带条件的规则
allow if {
    input.user == "admin"
}

# 多条件规则
allow if {
    input.method == "GET"
    input.path == "/public"
}

# 带参数的规则
can_access(user, resource) if {
    user.role == "admin"
    resource.public == true
}
```

### 1.3 语法层次结构

```text
Module (模块)
  ├── Package (包声明)
  ├── Imports (导入)
  └── Rules (规则集)
        ├── Head (规则头)
        └── Body (规则体)
              └── Expressions (表达式序列)
```

---

## 2. 词法结构

### 2.1 注释（Comments）

```rego
# 单行注释

# 多行注释通过连续的单行注释实现
# 第二行
# 第三行
```

**注意**: Rego **不支持** `/* ... */` 多行注释。

### 2.2 标识符（Identifiers）

**语法**:

```text
identifier ::= [a-zA-Z_][a-zA-Z0-9_]*
```

**规则**:

- 必须以字母或下划线开头
- 可包含字母、数字、下划线
- 大小写敏感
- 不能是保留关键字

**示例**:

```rego
# 有效标识符
allow
user_name
isAdmin
my_rule_123
_private

# 无效标识符
123user      # 不能以数字开头
my-rule      # 不能包含连字符
if           # 保留关键字
```

### 2.3 字面量（Literals）

#### 2.3.1 布尔字面量

```rego
true
false
```

#### 2.3.2 数值字面量

```rego
# 整数
42
0
-17
1000000

# 浮点数
3.14
-0.5
2.99e8        # 科学计数法: 2.99 × 10^8
1.0e-6        # 0.000001
```

#### 2.3.3 字符串字面量

```rego
# 双引号字符串
"hello"
"Hello, World!"
""            # 空字符串

# 转义序列
"line1\nline2"              # 换行
"tab\there"                 # 制表符
"quote: \"hello\""          # 双引号
"backslash: \\"             # 反斜杠
"unicode: \u4e2d\u6587"     # Unicode

# 原始字符串（使用反引号）
`raw string with \n (不转义)`
`可以跨
多行`
```

#### 2.3.4 空值字面量

```rego
null
```

### 2.4 分隔符（Delimiters）

| 符号 | 名称 | 用途 |
|------|------|------|
| `{` `}` | 花括号 | 对象、集合、规则体 |
| `[` `]` | 方括号 | 数组、索引 |
| `(` `)` | 圆括号 | 函数调用、分组 |
| `,` | 逗号 | 分隔元素 |
| `;` | 分号 | 表达式连接（AND） |
| `.` | 点号 | 对象访问 |
| `:` | 冒号 | 对象键值对 |
| `\|` | 管道 | 推导式、选择（OR） |

---

## 3. 语法结构

### 3.1 模块结构

```rego
# 包声明（必需）
package my.policy.name

# 导入（可选）
import data.users
import data.roles as role_data
import future.keywords.if
import future.keywords.contains

# 规则定义（核心）
allow if {
    # 规则体
}

helper_rule := "value"
```

### 3.2 包声明（Package）

**语法**:

```text
package <path>
```

**规则**:

- 必须是模块的第一条语句
- 路径用点号分隔
- 定义策略的命名空间

**示例**:

```rego
package kubernetes.admission
package api.authz.v1
package example.rbac
```

### 3.3 导入（Import）

**语法**:

```text
import <path> [as <alias>]
```

**示例**:

```rego
# 导入整个路径
import data.users

# 使用别名
import data.users as user_data
import input.request as req

# 导入未来关键字（推荐）
import future.keywords.if
import future.keywords.in
import future.keywords.every
import future.keywords.contains
```

**内置路径**:

- `data`: 外部数据
- `input`: 查询输入
- `future.keywords.*`: 未来语法特性

---

## 4. 数据类型

### 4.1 标量类型

#### 4.1.1 Boolean（布尔）

```rego
is_admin := true
is_public := false
```

#### 4.1.2 Number（数值）

```rego
count := 42
ratio := 3.14
large := 1e6
```

**特性**:

- IEEE 754 双精度浮点数
- 整数在范围内精确表示
- 支持 `+Inf`, `-Inf`, `NaN`

#### 4.1.3 String（字符串）

```rego
name := "Alice"
message := "Hello, World!"
empty := ""
```

**特性**:

- UTF-8 编码
- 不可变
- 支持Unicode

#### 4.1.4 Null（空值）

```rego
optional_field := null
```

### 4.2 复合类型

#### 4.2.1 Array（数组）

```rego
# 数组字面量
numbers := [1, 2, 3, 4, 5]
mixed := [1, "two", true, null]
nested := [[1, 2], [3, 4]]
empty := []

# 数组访问
first := numbers[0]        # 索引从0开始
last := numbers[4]

# 数组操作
length := count(numbers)   # 5
contains := 3 in numbers   # true (使用 future.keywords)
```

**特性**:

- 有序集合
- 零索引
- 可包含不同类型元素
- 不可变（每次操作返回新数组）

#### 4.2.2 Object（对象）

```rego
# 对象字面量
user := {
    "name": "Alice",
    "age": 30,
    "roles": ["admin", "user"]
}

# 嵌套对象
config := {
    "database": {
        "host": "localhost",
        "port": 5432
    }
}

# 对象访问
name := user.name           # "Alice"
name := user["name"]        # 等价
host := config.database.host  # "localhost"

# 动态键
key := "name"
value := user[key]          # "Alice"
```

**特性**:

- 键值对集合
- 键必须是字符串
- 值可以是任意类型
- 无序（但实现通常保持顺序）

#### 4.2.3 Set（集合）

```rego
# 集合字面量
roles := {"admin", "user", "viewer"}
empty_set := set()

# 集合操作
is_member := "admin" in roles     # true
union := roles | {"guest"}        # 并集
intersection := roles & {"admin", "guest"}  # 交集
difference := roles - {"viewer"}  # 差集

# 集合推导
admin_users := {u | u := data.users[_]; u.role == "admin"}
```

**特性**:

- 无序、无重复元素
- 支持集合运算
- 高效成员检查

---

## 5. 运算符

### 5.1 统一运算符（Unification）

```rego
# = （统一）
x = 5           # 将 x 绑定到 5
[x, 2] = [1, 2] # x 绑定到 1（模式匹配）

# 对象统一
{"a": x, "b": 2} = {"a": 1, "b": 2}  # x = 1
```

**语义**: 双向模式匹配，可绑定变量。

### 5.2 赋值运算符（Assignment）

```rego
# := （局部赋值）
x := 5          # 将右侧值赋给 x
y := x + 10     # y = 15
```

**语义**: 单向赋值，右侧必须可求值。

### 5.3 比较运算符

```rego
# == （相等）
5 == 5          # true
"a" == "b"      # false

# != （不等）
5 != 3          # true

# < （小于）
3 < 5           # true

# <= （小于等于）
5 <= 5          # true

# > （大于）
5 > 3           # true

# >= （大于等于）
5 >= 5          # true
```

### 5.4 逻辑运算符

```rego
# ; 或换行 （AND）
allow if {
    input.user == "admin"
    input.method == "GET"
}
# 等价于
allow if { input.user == "admin"; input.method == "GET" }

# 多个规则定义 （OR）
allow if { input.user == "admin" }
allow if { input.method == "GET"; input.path == "/public" }

# not （否定）
deny if {
    not allow
}
```

### 5.5 算术运算符

```rego
sum := 10 + 5       # 15
diff := 10 - 5      # 5
product := 10 * 5   # 50
quotient := 10 / 5  # 2.0
remainder := 10 % 3 # 1

# 负数
negative := -5
```

### 5.6 集合运算符

```rego
# | （并集）
set1 := {1, 2, 3}
set2 := {3, 4, 5}
union := set1 | set2  # {1, 2, 3, 4, 5}

# & （交集）
intersection := set1 & set2  # {3}

# - （差集）
difference := set1 - set2    # {1, 2}
```

### 5.7 成员运算符

```rego
import future.keywords.in

# in （成员检查）
3 in [1, 2, 3]           # true
"key" in {"key": "value"}  # true
5 in {1, 2, 3}           # false
```

---

## 6. 规则定义

### 6.1 完全规则（Complete Rules）

**语法**:

```rego
<name> := <value> if {
    <body>
}
```

**特性**: 规则求值返回单一值。

**示例**:

```rego
# 简单规则
is_admin := true if {
    input.user.role == "admin"
}

# 计算规则
max_score := 100

user_score := score if {
    score := input.score * 2
}

# 默认规则
default allow := false
allow := true if {
    input.user == "admin"
}
```

### 6.2 部分规则（Partial Rules）

#### 6.2.1 生成对象

**语法**:

```rego
<name>[<key>] := <value> if {
    <body>
}
```

**示例**:

```rego
# 生成用户映射
user_map[user.id] := user if {
    user := data.users[_]
}

# 结果: {"user1": {...}, "user2": {...}}
```

#### 6.2.2 生成集合

**语法**:

```rego
<name> contains <element> if {
    <body>
}
```

**示例**:

```rego
import future.keywords.contains

# 收集所有管理员
admins contains user.name if {
    user := data.users[_]
    user.role == "admin"
}

# 结果: {"alice", "bob"}
```

### 6.3 多值规则

```rego
# 多个规则定义（OR语义）
allow if {
    input.user.role == "admin"
}

allow if {
    input.method == "GET"
    input.path == "/public"
}

# 任一规则满足，allow = true
```

### 6.4 函数规则

```rego
# 带参数的规则
has_permission(user, resource, action) if {
    permission := data.permissions[_]
    permission.user == user
    permission.resource == resource
    permission.action == action
}

# 调用
allowed if {
    has_permission(input.user, input.resource, "read")
}
```

---

## 7. 模块化

### 7.1 规则引用

```rego
package example

# 定义规则
is_admin if {
    input.user.role == "admin"
}

# 引用规则
allow if {
    is_admin  # 调用同一包内的规则
}
```

### 7.2 跨包引用

```rego
# 文件1: authz/users.rego
package authz.users

admins := {"alice", "bob"}

# 文件2: authz/policies.rego
package authz.policies

import data.authz.users

allow if {
    input.user in users.admins
}
```

### 7.3 分层策略

```text
策略目录结构
├── kubernetes/
│   ├── admission/
│   │   ├── pods.rego
│   │   └── services.rego
│   └── rbac/
│       └── roles.rego
└── common/
    └── utils.rego
```

**引用**:

```rego
package kubernetes.admission.pods

import data.common.utils
import data.kubernetes.rbac.roles

deny[msg] if {
    not roles.can_create_pod(input.user)
    msg := utils.format_error("unauthorized")
}
```

---

## 8. 保留关键字

### 8.1 当前关键字（v1.0）

```text
package
import
as
default
else
with
null
true
false
not
some
```

### 8.2 未来关键字（需显式导入）

```rego
import future.keywords.if       # 推荐使用
import future.keywords.in
import future.keywords.every
import future.keywords.contains
```

**使用示例**:

```rego
import future.keywords.if
import future.keywords.in

# 旧语法（不推荐）
allow {
    input.user == "admin"
}

# 新语法（推荐）
allow if {
    input.user in data.admins
}
```

### 8.3 保留但未使用

```text
while
for
break
continue
return
```

**注意**: 这些关键字保留供未来使用，不能作为标识符。

---

## 9. 最佳实践

### 9.1 命名约定

```rego
# 规则名：蛇形命名
allow_admin_access := true
user_permissions[id] := perms

# 常量：大写蛇形
MAX_RETRIES := 3
DEFAULT_TIMEOUT := 30

# 辅助规则：动词开头
is_admin if { ... }
has_permission(user, action) if { ... }
can_access_resource(resource) if { ... }
```

### 9.2 代码组织

```rego
# 1. 包声明
package example.policy

# 2. 导入
import data.users
import future.keywords.if
import future.keywords.in

# 3. 常量定义
DEFAULT_ROLE := "user"
ADMIN_ROLE := "admin"

# 4. 主要规则
allow if {
    is_admin
}

# 5. 辅助规则
is_admin if {
    input.user.role == ADMIN_ROLE
}
```

### 9.3 注释规范

```rego
# METADATA
# title: 管理员访问策略
# description: 控制管理员对资源的访问权限
# authors:
# - alice@example.com
# scope: package

package example.admin

# 允许管理员访问所有资源
#
# 此规则检查用户是否具有管理员角色。
# 如果是，则授予完全访问权限。
#
# 输入要求:
#   - input.user.role: 用户角色（字符串）
#
# 返回: true 如果允许访问，否则 undefined
allow if {
    input.user.role == "admin"
}
```

### 9.4 性能考虑

```rego
# ✅ 好：提前过滤
allow if {
    input.method == "GET"  # 快速检查
    expensive_check()      # 仅在需要时调用
}

# ❌ 差：昂贵操作在前
allow if {
    expensive_check()      # 总是执行
    input.method == "GET"
}

# ✅ 好：使用索引
user := data.users[input.user_id]  # O(1) 查找

# ❌ 差：线性搜索
user := u if {
    u := data.users[_]
    u.id == input.user_id  # O(n) 查找
}
```

### 9.5 测试驱动

```rego
# policy.rego
package example

allow if {
    input.user.role == "admin"
}

# policy_test.rego
package example

test_admin_allowed if {
    allow with input as {"user": {"role": "admin"}}
}

test_user_denied if {
    not allow with input as {"user": {"role": "user"}}
}
```

---

## 附录 A: 完整语法图

### EBNF表示

```ebnf
Module     ::= Package Import* Rule*
Package    ::= 'package' Ref
Import     ::= 'import' Ref ('as' Var)?
Rule       ::= RuleHead ('if')? RuleBody
RuleHead   ::= Var (':=' Term)? | Var '[' Term ']' (':=' Term)?
RuleBody   ::= '{' Expr* '}'
Expr       ::= Term | Expr 'and' Expr | Expr 'or' Expr | 'not' Expr
Term       ::= Scalar | Composite | Ref | Var | Call
Scalar     ::= String | Number | Bool | Null
Composite  ::= Array | Object | Set
Array      ::= '[' (Term (',' Term)*)? ']'
Object     ::= '{' (Pair (',' Pair)*)? '}'
Set        ::= '{' (Term (',' Term)*)? '}'
Pair       ::= (String | Var) ':' Term
Ref        ::= (Var | '[' Term ']' | '.' Var)+
Call       ::= Var '(' (Term (',' Term)*)? ')'
```

---

## 附录 B: 运算符优先级

| 优先级 | 运算符 | 结合性 |
|--------|--------|--------|
| 1（最高）| `()` `[]` `.` | 左 |
| 2 | `-`（负数）`not` | 右 |
| 3 | `*` `/` `%` | 左 |
| 4 | `+` `-` | 左 |
| 5 | `\|` `&` | 左 |
| 6 | `==` `!=` `<` `<=` `>` `>=` | 左 |
| 7 | `=` `:=` | 右 |
| 8 | `;`（AND） | 左 |
| 9（最低）| 多规则（OR） | - |

---

## 附录 C: 语法糖与等价形式

| 语法糖 | 等价形式 | 说明 |
|--------|---------|------|
| `x := 1` | `x = 1` | 在某些上下文中等价 |
| `a; b` | `a` 换行 `b` | 表达式连接 |
| `[x \| p]` | 数组推导 | 生成数组 |
| `{x \| p}` | 集合推导 | 生成集合 |
| `{k: v \| p}` | 对象推导 | 生成对象 |

---

## 参考资源

1. **官方文档**: <https://www.openpolicyagent.org/docs/latest/policy-language/>
2. **Rego Playground**: <https://play.openpolicyagent.org/>
3. **语法高亮**: <https://github.com/open-policy-agent/opa/tree/main/misc>
4. **LSP服务器**: <https://github.com/open-policy-agent/opa/tree/main/ast>

---

**下一篇**: [02.2-语义模型](./02.2-语义模型.md)  
**相关**: [06.2-Rego形式化语义](../06-形式化证明/06.2-Rego形式化语义.md)
