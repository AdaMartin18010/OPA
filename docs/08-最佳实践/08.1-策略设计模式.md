# 策略设计模式（Policy Design Patterns）

> **更新日期**: 2025年10月20日  
> **适用**: OPA v0.60+ / Rego v1.0  
> **目标**: 可维护、可测试、高性能的策略

---

## 目录

- [策略设计模式（Policy Design Patterns）](#策略设计模式policy-design-patterns)
  - [目录](#目录)
  - [1. 设计原则](#1-设计原则)
    - [1.1 SOLID原则在Rego中的应用](#11-solid原则在rego中的应用)
      - [1.1.1 单一职责原则（Single Responsibility）](#111-单一职责原则single-responsibility)
      - [1.1.2 开闭原则（Open-Closed）](#112-开闭原则open-closed)
      - [1.1.3 依赖倒置原则（Dependency Inversion）](#113-依赖倒置原则dependency-inversion)
    - [1.2 DRY原则（Don't Repeat Yourself）](#12-dry原则dont-repeat-yourself)
    - [1.3 清晰命名](#13-清晰命名)
  - [2. 结构化模式](#2-结构化模式)
    - [2.1 分层架构模式](#21-分层架构模式)
    - [2.2 策略组合模式](#22-策略组合模式)
      - [2.2.1 "AND"组合（全部满足）](#221-and组合全部满足)
      - [2.2.2 "OR"组合（任一满足）](#222-or组合任一满足)
      - [2.2.3 优先级组合](#223-优先级组合)
    - [2.3 命名空间模式](#23-命名空间模式)
    - [2.4 模板模式](#24-模板模式)
  - [3. 决策模式](#3-决策模式)
    - [3.1 默认拒绝模式（Default Deny）](#31-默认拒绝模式default-deny)
    - [3.2 明确拒绝模式（Explicit Deny）](#32-明确拒绝模式explicit-deny)
    - [3.3 审计模式（Audit Mode）](#33-审计模式audit-mode)
    - [3.4 渐进式迁移模式](#34-渐进式迁移模式)
  - [4. 数据模式](#4-数据模式)
    - [4.1 数据访问封装](#41-数据访问封装)
    - [4.2 数据验证模式](#42-数据验证模式)
    - [4.3 数据规范化模式](#43-数据规范化模式)
    - [4.4 数据投影模式](#44-数据投影模式)
  - [5. 反模式（Anti-Patterns）](#5-反模式anti-patterns)
    - [5.1 ❌ 魔法数字/字符串](#51--魔法数字字符串)
    - [5.2 ❌ 过深嵌套](#52--过深嵌套)
    - [5.3 ❌ 不安全的变量](#53--不安全的变量)
    - [5.4 ❌ 副作用](#54--副作用)
    - [5.5 ❌ 过度优化](#55--过度优化)
  - [6. 重构技巧](#6-重构技巧)
    - [6.1 提取辅助规则](#61-提取辅助规则)
    - [6.2 合并重复条件](#62-合并重复条件)
    - [6.3 使用集合推导简化](#63-使用集合推导简化)
    - [6.4 策略版本化](#64-策略版本化)
  - [附录: 设计检查清单](#附录-设计检查清单)
    - [代码质量检查](#代码质量检查)
    - [性能检查](#性能检查)
    - [测试检查](#测试检查)
    - [安全检查](#安全检查)

---

## 1. 设计原则

### 1.1 SOLID原则在Rego中的应用

#### 1.1.1 单一职责原则（Single Responsibility）

**原则**: 每个规则只做一件事。

**❌ 反例**:

```rego
allow if {
    # 混杂了认证、授权、审计逻辑
    user := data.users[input.user_id]
    user.active == true
    user.email_verified == true
    some role in user.roles
    data.roles[role].permissions[_] == input.action
    log_access(user, input.action)  # 副作用！
}
```

**✅ 正例**:

```rego
# 1. 认证检查
is_authenticated if {
    user := data.users[input.user_id]
    user.active == true
    user.email_verified == true
}

# 2. 授权检查
has_permission if {
    some role in user_roles
    data.roles[role].permissions[_] == input.action
}

# 3. 主决策
allow if {
    is_authenticated
    has_permission
}
```

---

#### 1.1.2 开闭原则（Open-Closed）

**原则**: 对扩展开放，对修改封闭。

**✅ 示例**:

```rego
# 基础规则（不修改）
allow if {
    some rule in allow_rules
    rule
}

# 扩展规则（添加新规则）
allow_rules contains is_admin
allow_rules contains is_resource_owner
allow_rules contains is_delegated

# 具体实现
is_admin if { "admin" in user_roles }
is_resource_owner if { resource.owner == input.user }
is_delegated if { has_delegation }
```

---

#### 1.1.3 依赖倒置原则（Dependency Inversion）

**原则**: 依赖抽象而非具体实现。

**✅ 示例**:

```rego
# 抽象接口
allow if {
    authenticate()
    authorize()
}

# 具体实现可替换
authenticate := jwt_auth if {
    input.auth_type == "jwt"
}

authenticate := api_key_auth if {
    input.auth_type == "api_key"
}

authorize := rbac_authz if {
    data.authz_mode == "rbac"
}

authorize := abac_authz if {
    data.authz_mode == "abac"
}
```

---

### 1.2 DRY原则（Don't Repeat Yourself）

**❌ 反例**（重复代码）:

```rego
allow_read if {
    user := data.users[input.user]
    user.department == "engineering"
    user.active == true
}

allow_write if {
    user := data.users[input.user]
    user.department == "engineering"
    user.active == true
    user.level >= 3
}
```

**✅ 正例**（抽取公共逻辑）:

```rego
is_engineering_user if {
    user := data.users[input.user]
    user.department == "engineering"
    user.active == true
}

allow_read if {
    is_engineering_user
}

allow_write if {
    is_engineering_user
    user := data.users[input.user]
    user.level >= 3
}
```

---

### 1.3 清晰命名

**规则命名约定**:

```rego
# 布尔值：is_/has_/can_/should_
is_authenticated
has_permission
can_access
should_audit

# 集合：复数名词
user_roles
allowed_actions
admin_users

# 辅助函数：动词开头
get_user_info
check_quota
validate_token
```

---

## 2. 结构化模式

### 2.1 分层架构模式

**结构**:

```text
策略分层
├── 接口层 (Interface Layer)
│   └── allow, deny (对外接口)
├── 业务层 (Business Layer)
│   └── 业务规则
├── 逻辑层 (Logic Layer)
│   └── 通用逻辑
└── 数据层 (Data Layer)
    └── 数据访问
```

**实现**:

```rego
# ========== 接口层 ==========
package api.authz

allow if {
    not deny
    some rule in allow_rules
    rule
}

deny contains msg if {
    some rule in deny_rules
    msg := rule
}

# ========== 业务层 ==========
allow_rules contains business_rule_1
allow_rules contains business_rule_2

business_rule_1 if {
    # 使用逻辑层
    is_admin
    within_quota
}

# ========== 逻辑层 ==========
is_admin if {
    # 使用数据层
    "admin" in get_user_roles
}

within_quota if {
    current_usage < get_quota_limit
}

# ========== 数据层 ==========
get_user_roles := data.users[input.user].roles

get_quota_limit := data.quotas[input.user].limit
```

---

### 2.2 策略组合模式

**场景**: 多个独立策略的组合。

#### 2.2.1 "AND"组合（全部满足）

```rego
allow if {
    policy_a
    policy_b
    policy_c
}

policy_a if { ... }
policy_b if { ... }
policy_c if { ... }
```

#### 2.2.2 "OR"组合（任一满足）

```rego
allow if { policy_a }
allow if { policy_b }
allow if { policy_c }
```

#### 2.2.3 优先级组合

```rego
# 优先级：deny > allow > default
decision := "deny" if { explicit_deny }
decision := "allow" if { explicit_allow }
decision := "default" if { true }

final_allow if {
    decision == "allow"
}
```

---

### 2.3 命名空间模式

**目的**: 避免命名冲突，组织策略。

**结构**:

```text
data
├── api
│   ├── v1
│   │   └── authz
│   └── v2
│       └── authz
├── kubernetes
│   ├── admission
│   └── rbac
└── common
    └── utils
```

**实现**:

```rego
# 文件: api/v1/authz.rego
package api.v1.authz
allow if { ... }

# 文件: api/v2/authz.rego
package api.v2.authz
allow if { ... }

# 使用
import data.api.v1.authz as authz_v1
import data.api.v2.authz as authz_v2

allow if {
    authz_v1.allow
}
```

---

### 2.4 模板模式

**场景**: 可复用的策略骨架。

```rego
# 模板函数
resource_access_template(resource_type, required_action) := allowed if {
    # 1. 获取资源
    resource := data.resources[resource_type][input.resource_id]
    
    # 2. 检查权限
    user := data.users[input.user]
    required_action in user.permissions[resource_type]
    
    # 3. 检查资源状态
    resource.active == true
    
    # 4. 返回结果
    allowed := true
}

# 实例化模板
allow_document_read := resource_access_template("document", "read")
allow_project_write := resource_access_template("project", "write")
```

---

## 3. 决策模式

### 3.1 默认拒绝模式（Default Deny）

**原则**: 默认拒绝，显式允许。

**✅ 推荐**:

```rego
# 默认结果: undefined (隐式拒绝)
allow if {
    explicit_allow_rule_1
}

allow if {
    explicit_allow_rule_2
}

# 应用层处理
if opa_result.allow {
    // 允许
} else {
    // 拒绝（默认）
}
```

---

### 3.2 明确拒绝模式（Explicit Deny）

**场景**: 需要区分"未定义"和"明确拒绝"。

```rego
# 明确允许
allow := true if {
    is_admin
}

# 明确拒绝
deny contains "user is blacklisted" if {
    input.user in data.blacklist
}

deny contains "resource is locked" if {
    resource := data.resources[input.resource_id]
    resource.locked == true
}

# 最终决策
final_decision := "deny" if {
    count(deny) > 0
}

final_decision := "allow" if {
    allow
    count(deny) == 0
}

final_decision := "undefined" if {
    not allow
    count(deny) == 0
}
```

---

### 3.3 审计模式（Audit Mode）

**目的**: 记录违规但不阻止。

```rego
# 正常策略
violations contains msg if {
    not has_required_label
    msg := "missing required label"
}

violations contains msg if {
    resource_too_large
    msg := "resource exceeds size limit"
}

# 审计模式
audit_mode := data.config.audit_mode

# 根据模式决定是否拒绝
deny contains msg if {
    not audit_mode
    some msg in violations
}

# 总是记录违规（用于审计）
warnings := violations
```

---

### 3.4 渐进式迁移模式

**场景**: 从旧策略逐步迁移到新策略。

```rego
# 新策略
allow_v2 if {
    # 新逻辑
}

# 旧策略（兼容）
allow_v1 if {
    # 旧逻辑
}

# 迁移配置
migration_enabled := data.config.v2_migration

# 决策逻辑
allow if {
    migration_enabled
    allow_v2
}

allow if {
    not migration_enabled
    allow_v1
}

# 记录差异（用于验证迁移正确性）
migration_diff := {
    "v1": allow_v1,
    "v2": allow_v2,
    "consistent": allow_v1 == allow_v2
}
```

---

## 4. 数据模式

### 4.1 数据访问封装

**原则**: 通过函数访问数据，便于修改数据结构。

**❌ 直接访问**:

```rego
allow if {
    user := data.users[input.user_id]
    "admin" in user.roles
}
```

**✅ 封装访问**:

```rego
get_user(user_id) := user if {
    user := data.users[user_id]
}

get_user_roles(user_id) := roles if {
    user := get_user(user_id)
    roles := user.roles
}

allow if {
    "admin" in get_user_roles(input.user_id)
}
```

**优势**: 数据结构变化时只需修改封装函数。

---

### 4.2 数据验证模式

**目的**: 确保输入数据完整性。

```rego
# 验证规则
validate_input contains msg if {
    not input.user_id
    msg := "missing user_id"
}

validate_input contains msg if {
    not input.action
    msg := "missing action"
}

validate_input contains msg if {
    not input.resource_id
    msg := "missing resource_id"
}

# 主决策（先验证）
allow if {
    count(validate_input) == 0  # 验证通过
    # 正常授权逻辑
    ...
}

# 返回验证错误
errors := validate_input if {
    count(validate_input) > 0
}
```

---

### 4.3 数据规范化模式

**目的**: 统一数据格式。

```rego
# 规范化用户输入
normalized_input := {
    "user_id": lower(input.user_id),      # 统一小写
    "action": upper(input.action),        # 统一大写
    "resource": trim_space(input.resource), # 去除空格
    "timestamp": time.now_ns()            # 添加时间戳
}

# 使用规范化数据
allow if {
    normalized_input.user_id in data.allowed_users
}
```

---

### 4.4 数据投影模式

**目的**: 只暴露必要的数据字段。

```rego
# 完整用户数据
full_user := data.users[input.user_id]

# 投影：只暴露必要字段
user_info := {
    "id": full_user.id,
    "roles": full_user.roles,
    "department": full_user.department
    # 不暴露: email, phone, address
}

# 使用投影数据
allow if {
    "admin" in user_info.roles
}
```

---

## 5. 反模式（Anti-Patterns）

### 5.1 ❌ 魔法数字/字符串

**问题**:

```rego
allow if {
    input.level > 5        # 5是什么？
    input.role == "adm"    # 拼写错误？
}
```

**解决**:

```rego
MIN_ADMIN_LEVEL := 5
ADMIN_ROLE := "admin"

allow if {
    input.level > MIN_ADMIN_LEVEL
    input.role == ADMIN_ROLE
}
```

---

### 5.2 ❌ 过深嵌套

**问题**:

```rego
allow if {
    user := data.users[input.user]
    user.active == true
    some role in user.roles
    role_def := data.roles[role]
    some perm in role_def.permissions
    perm.action == input.action
    some resource_pattern in perm.resources
    glob.match(resource_pattern, [], input.resource)
}
```

**解决**（提取辅助规则）:

```rego
allow if {
    is_active_user
    has_matching_permission
}

is_active_user if {
    user := data.users[input.user]
    user.active == true
}

has_matching_permission if {
    some role in user_roles
    role_has_permission(role, input.action, input.resource)
}

role_has_permission(role, action, resource) if {
    some perm in data.roles[role].permissions
    perm.action == action
    some pattern in perm.resources
    glob.match(pattern, [], resource)
}
```

---

### 5.3 ❌ 不安全的变量

**问题**:

```rego
allow if {
    user := data.users[_]  # 不安全：user未约束
    user.admin == true
}
```

**解决**:

```rego
allow if {
    # 方式1：明确绑定
    user := data.users[input.user_id]
    user.admin == true
}

allow if {
    # 方式2：使用some
    some user_id in object.keys(data.users)
    user := data.users[user_id]
    user.admin == true
}
```

---

### 5.4 ❌ 副作用

**问题**: Rego是纯函数式，不应有副作用。

```rego
# ❌ 错误：尝试修改全局状态
allow if {
    # data.audit_log[_] := {"user": input.user}  # 不允许！
    ...
}
```

**解决**: 通过Decision Logs或返回值处理审计。

```rego
# ✅ 正确：返回审计信息
audit_event := {
    "user": input.user,
    "action": input.action,
    "allowed": allow,
    "timestamp": time.now_ns()
}
```

---

### 5.5 ❌ 过度优化

**问题**: 过早优化影响可读性。

```rego
# ❌ 过度优化：难以理解
allow if {
    [true | x := input.users[_]; y := data.perms[x]; z := y[_]; z == input.act][0]
}
```

**解决**: 优先保证可读性。

```rego
# ✅ 清晰可读
allow if {
    some user in input.users
    some perm in data.perms[user]
    perm == input.action
}
```

---

## 6. 重构技巧

### 6.1 提取辅助规则

**重构前**:

```rego
allow if {
    user := data.users[input.user]
    user.active == true
    user.email_verified == true
    "admin" in user.roles
}

allow if {
    user := data.users[input.user]
    user.active == true
    user.email_verified == true
    resource := data.resources[input.resource]
    resource.owner == input.user
}
```

**重构后**:

```rego
is_valid_user if {
    user := data.users[input.user]
    user.active == true
    user.email_verified == true
}

allow if {
    is_valid_user
    "admin" in user.roles
}

allow if {
    is_valid_user
    is_resource_owner
}
```

---

### 6.2 合并重复条件

**重构前**:

```rego
allow if {
    input.method == "GET"
    input.path == "/api/public"
}

allow if {
    input.method == "POST"
    input.path == "/api/public"
}
```

**重构后**:

```rego
allow if {
    input.method in ["GET", "POST"]
    input.path == "/api/public"
}
```

---

### 6.3 使用集合推导简化

**重构前**:

```rego
admin_users := users if {
    users := [u | 
        some user_id in object.keys(data.users)
        u := data.users[user_id]
        u.role == "admin"
    ]
}
```

**重构后**:

```rego
admin_users := [u | 
    u := data.users[_]
    u.role == "admin"
]
```

---

### 6.4 策略版本化

**目的**: 支持多版本共存。

```rego
# v1/policy.rego
package authz.v1
allow if { ... }

# v2/policy.rego
package authz.v2
allow if { ... }

# 路由
package authz

import data.authz.v1
import data.authz.v2

allow if {
    input.api_version == "v1"
    v1.allow
}

allow if {
    input.api_version == "v2"
    v2.allow
}
```

---

## 附录: 设计检查清单

### 代码质量检查

- [ ] 规则命名清晰、一致
- [ ] 避免魔法数字/字符串
- [ ] 提取公共逻辑
- [ ] 嵌套深度 < 3层
- [ ] 单个文件 < 300行
- [ ] 单个规则 < 20行

### 性能检查

- [ ] 使用索引访问 (`data.x[id]`)
- [ ] 避免全表扫描 (`data.x[_]`)
- [ ] 提前失败（快速路径）
- [ ] 缓存计算结果
- [ ] 启用部分求值

### 测试检查

- [ ] 覆盖率 > 80%
- [ ] 测试边界情况
- [ ] 测试错误输入
- [ ] 性能基准测试
- [ ] 集成测试

### 安全检查

- [ ] 默认拒绝
- [ ] 输入验证
- [ ] 防止注入攻击
- [ ] 敏感数据脱敏
- [ ] 审计日志

---

**下一篇**: [08.2-性能优化](./08.2-性能优化.md)  
**相关**: [02.1-Rego语法规范](../02-语言模型/02.1-Rego语法规范.md)
