# 性能优化指南（Performance Optimization Guide）

> **更新日期**: 2025年10月21日  
> **目标**: P99 < 10ms, 吞吐 > 10k req/s  
> **方法**: 策略优化、架构优化、系统优化  
> **参考**: <https://www.openpolicyagent.org/docs/latest/policy-performance/>

---

## 1. 性能目标

### 1.1 性能基准

```text
场景: 生产环境RBAC策略

性能目标:
  P50延迟:  < 1ms
  P99延迟:  < 10ms
  吞吐量:   > 10,000 req/s
  CPU使用:  < 50%
  内存占用: < 500MB
```

### 1.2 测量方法

**基准测试**：

```bash
# OPA bench
opa bench policy.rego \
    -d data.json \
    -i input.json \
    --count 10000

# 输出
+----------------+---------+---------+---------+
| Metric         | Min     | Avg     | Max     |
+----------------+---------+---------+---------+
| Time (ns)      | 50000   | 100000  | 500000  |
| Memory (bytes) | 1024    | 2048    | 4096    |
+----------------+---------+---------+---------+
```

---

## 2. 策略层优化

### 2.1 避免反模式

**❌ 反模式1: 全表扫描**

```rego
# 慢: O(n)
user_by_email(email) := user if {
    some user in data.users
    user.email == email
}

# 快: O(1)
user_by_email(email) := data.users_by_email[email]
```

**❌ 反模式2: 笛卡尔积**

```rego
# 慢: O(n²)
conflicts := [[u1, u2] |
    some u1 in data.users
    some u2 in data.users
    u1.team == u2.team
]

# 快: O(n)
by_team := {team: users |
    some user in data.users
    team := user.team
    users := [u | some u in data.users; u.team == team]
}
```

**❌ 反模式3: 重复计算**

```rego
# 慢: 多次计算
allow if {
    count(input.permissions) > 5
    count(input.permissions) < 20
}

# 快: 缓存结果
perm_count := count(input.permissions)
allow if {
    perm_count > 5
    perm_count < 20
}
```

### 2.2 最佳实践

**✅ 使用集合操作**

```rego
# 集合交集
allowed := user_permissions & required_permissions

# 集合包含
allow if {
    "admin" in input.user.roles
}
```

**✅ 提前退出**

```rego
allow if {
    # 快速检查在前
    input.method == "GET"
    
    # 昂贵操作在后
    user := data.users[input.user_id]
    check_permissions(user)
}
```

**✅ 索引访问**

```rego
# 直接索引
user := data.users[input.user_id]
role := data.roles[user.role_id]

# 避免搜索
# ❌ some user in data.users; user.id == input.user_id
```

---

## 3. 数据层优化

### 3.1 数据结构优化

**对象化数组**：

```json
// ❌ 数组 - 需要搜索
{
  "users": [
    {"id": "u1", "name": "alice"},
    {"id": "u2", "name": "bob"}
  ]
}

// ✅ 对象 - 直接索引
{
  "users": {
    "u1": {"name": "alice"},
    "u2": {"name": "bob"}
  }
}
```

**预计算索引**：

```json
{
  "users": [...],
  "indexes": {
    "by_email": {
      "alice@example.com": "u1",
      "bob@example.com": "u2"
    },
    "by_role": {
      "admin": ["u1"],
      "user": ["u2"]
    }
  }
}
```

### 3.2 数据分片

**按访问模式分片**：

```text
原始: 单一大JSON (10MB)
  ├── 加载慢
  ├── 内存占用高
  └── 更新成本大

优化: 按模块分片
  ├── users.json (2MB)
  ├── roles.json (1MB)
  ├── permissions.json (3MB)
  └── resources.json (4MB)

效果:
  ✅ 按需加载
  ✅ 内存友好
  ✅ 更新粒度细
```

---

## 4. 编译器优化

### 4.1 部分求值

**场景**: 数据变化慢，查询变化快

```bash
# 部分求值
opa build \
    --target wasm \
    --partial \
    --unknowns input \
    policy/ data/

# 效果:
#   策略大小: 10MB → 100KB (100x)
#   求值延迟: 5ms → 0.1ms (50x)
```

### 4.2 编译优化级别

```bash
# 级别0: 无优化（调试）
opa build --optimize=0 policy/

# 级别1: 标准优化（默认）
opa build --optimize=1 policy/

# 级别2: 激进优化（生产）
opa build --optimize=2 policy/

# 对比:
#   级别0: 编译5s, 执行10ms
#   级别1: 编译10s, 执行2ms
#   级别2: 编译30s, 执行0.5ms
```

---

## 5. 运行时优化

### 5.1 缓存配置

**启用缓存**：

```yaml
# config.yaml
caching:
  inter_query_builtin_cache:
    max_size_bytes: 10485760  # 10MB
```

**受益函数**：

```rego
# HTTP请求缓存
response := http.send({
    "method": "GET",
    "url": "https://api.example.com/data"
})

# JWT解码缓存
[header, payload, sig] := io.jwt.decode(input.token)

# 正则缓存
regex.match(`^[a-z]+$`, input.name)
```

### 5.2 连接池

**Go应用**：

```go
// 复用OPA实例
var opaPool = sync.Pool{
    New: func() interface{} {
        opa, _ := rego.New(
            rego.Query("data.authz.allow"),
            rego.Load([]string{"policy.rego"}, nil),
        ).PrepareForEval(context.Background())
        return opa
    },
}

func authorize(ctx context.Context, input map[string]interface{}) (bool, error) {
    pq := opaPool.Get().(rego.PreparedEvalQuery)
    defer opaPool.Put(pq)
    
    rs, err := pq.Eval(ctx, rego.EvalInput(input))
    if err != nil {
        return false, err
    }
    return rs.Allowed(), nil
}
```

### 5.3 批量求值

**批量API**：

```bash
# 批量请求
curl -X POST http://localhost:8181/v1/data/authz/allow \
  -d '{
    "inputs": [
      {"user": "alice", "resource": "doc1"},
      {"user": "bob", "resource": "doc2"}
    ]
  }'

# 性能提升: 3-5x
```

---

## 6. 部署优化

### 6.1 Sidecar模式

**优势**：

```text
1. 低延迟
   └── 本地调用，无网络开销

2. 高吞吐
   └── 每服务独立实例

3. 资源隔离
   └── 故障不扩散

配置:
  - CPU: 100m request, 500m limit
  - Memory: 128Mi request, 512Mi limit
```

**Kubernetes配置**：

```yaml
apiVersion: v1
kind: Pod
spec:
  containers:
    - name: app
      image: my-app:latest
    
    - name: opa
      image: openpolicyagent/opa:latest
      args:
        - "run"
        - "--server"
        - "--addr=localhost:8181"
        - "/policies/policy.wasm"
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
        limits:
          cpu: 500m
          memory: 512Mi
```

### 6.2 WASM部署

**优势**：

```text
1. 更小
   └── Bundle: 10MB → 100KB

2. 更快
   └── 冷启动: 500ms → 10ms

3. 可移植
   └── 浏览器、边缘、服务器
```

**使用场景**：

```text
✅ 边缘计算（CDN）
✅ 浏览器端授权
✅ Serverless函数
✅ IoT设备
```

---

## 7. 监控与调优

### 7.1 性能剖析

**CPU Profiling**：

```bash
# 启用profiling
curl http://localhost:8181/debug/pprof/profile?seconds=30 > cpu.prof

# 分析
go tool pprof cpu.prof
(pprof) top10
(pprof) web
```

**内存Profiling**：

```bash
curl http://localhost:8181/debug/pprof/heap > mem.prof
go tool pprof mem.prof
(pprof) top10
(pprof) list <function>
```

### 7.2 关键指标

**Prometheus Metrics**：

```promql
# 求值延迟P99
histogram_quantile(0.99,
  rate(opa_http_request_duration_seconds_bucket[5m])
)

# 吞吐量
rate(opa_http_request_total[5m])

# 错误率
rate(opa_http_request_total{code=~"5.."}[5m]) /
rate(opa_http_request_total[5m])

# 内存使用
go_memstats_alloc_bytes
```

### 7.3 告警规则

```yaml
groups:
  - name: opa_performance
    rules:
      - alert: OPAHighLatency
        expr: histogram_quantile(0.99, opa_http_request_duration_seconds_bucket) > 0.01
        for: 5m
        annotations:
          summary: "OPA P99延迟 > 10ms"
      
      - alert: OPALowThroughput
        expr: rate(opa_http_request_total[5m]) < 1000
        for: 5m
        annotations:
          summary: "OPA吞吐量 < 1000 req/s"
```

---

## 8. 实战案例

### 8.1 大规模RBAC

**场景**: 10,000用户, 1,000角色, 100,000权限

**优化前**：

```rego
# P99: 50ms
allow if {
    some role in input.user.roles
    some perm in data.role_permissions[role]
    perm.resource == input.resource
    perm.action == input.action
}
```

**优化后**：

```rego
# 1. 预计算用户权限
user_perms := {p |
    some role in input.user.roles
    some p in data.role_permissions[role]
}

# 2. 使用集合操作
required := {input.resource, input.action}
allow if {
    some perm in user_perms
    {perm.resource, perm.action} == required
}

# P99: 0.5ms (100x提升)
```

### 8.2 实时日志过滤

**场景**: 过滤1M条日志

**优化策略**：

```rego
# 1. 布隆过滤器预筛选
suspicious_ips := bloom_filter_from_set(data.blacklist)

filtered_logs := [log |
    some log in input.logs
    bloom_filter.may_contain(suspicious_ips, log.ip)  # 快速否定
    exact_check(log)  # 精确检查
]

# 2. 位图索引
logs_by_level := {
    "ERROR": roaring.bitmap([1, 5, 10, ...]),
    "WARN": roaring.bitmap([2, 3, 8, ...])
}

error_logs := [input.logs[i] |
    some i in roaring.to_array(logs_by_level["ERROR"])
]

# 性能: 5s → 50ms (100x提升)
```

---

## 9. 优化清单

### 9.1 策略层

```text
□ 避免全表扫描
□ 避免笛卡尔积
□ 避免重复计算
□ 使用集合操作
□ 提前退出
□ 缓存昂贵计算
□ 使用索引访问
□ 简化规则逻辑
```

### 9.2 数据层

```text
□ 对象化数组
□ 预计算索引
□ 数据分片
□ 扁平化嵌套
□ 移除冗余数据
□ 压缩数据
```

### 9.3 部署层

```text
□ 启用部分求值
□ 使用WASM（边缘）
□ Sidecar模式（K8s）
□ 启用缓存
□ 连接池/实例复用
□ 资源配额合理
□ 多副本高可用
```

### 9.4 监控层

```text
□ 性能指标收集
□ 日志记录
□ 告警配置
□ 定期基准测试
□ 热点分析
□ 瓶颈识别
```

---

## 10. 快速诊断

**性能问题决策树**：

```text
性能慢？
├─ 延迟高？
│  ├─ 策略复杂？→ 简化规则，优化算法
│  ├─ 数据大？→ 索引，分片，部分求值
│  └─ 网络慢？→ Sidecar模式，WASM
│
├─ 吞吐低？
│  ├─ CPU瓶颈？→ 增加副本，优化算法
│  ├─ 内存不足？→ 优化数据结构，分片
│  └─ GC频繁？→ 调整GOGC，增加内存
│
└─ 内存高？
   ├─ 数据大？→ 分片，按需加载
   ├─ 缓存大？→ 调整缓存大小
   └─ 泄漏？→ Profiling，修复代码
```

---

**相关文档**：

- [性能基准与度量](../01-技术规范/01.4-性能基准与度量.md)
- [索引与优化](../03-实现架构/03.5-索引与优化.md)
- [部分求值技术](../03-实现架构/03.6-部分求值技术.md)

**参考资源**：

- Performance Tips: <https://www.openpolicyagent.org/docs/latest/policy-performance/>
- Go Performance: <https://go.dev/doc/diagnostics>

