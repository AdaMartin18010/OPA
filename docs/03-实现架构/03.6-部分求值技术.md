# 部分求值技术（Partial Evaluation）

> **更新日期**: 2025年10月21日  
> **OPA版本**: v0.60+  
> **技术**: Futamura投影、超级编译  
> **参考**: <https://www.openpolicyagent.org/docs/latest/policy-performance/>

---

## 目录

- [部分求值技术（Partial Evaluation）](#部分求值技术partial-evaluation)
  - [目录](#目录)
  - [1. 部分求值概述](#1-部分求值概述)
    - [1.1 基本概念](#11-基本概念)
    - [1.2 应用价值](#12-应用价值)
    - [1.3 核心思想](#13-核心思想)
  - [2. 部分求值原理](#2-部分求值原理)
    - [2.1 已知与未知](#21-已知与未知)
    - [2.2 特化过程](#22-特化过程)
    - [2.3 残余程序](#23-残余程序)
  - [3. OPA中的部分求值](#3-opa中的部分求值)
    - [3.1 编译命令](#31-编译命令)
    - [3.2 未知变量指定](#32-未知变量指定)
    - [3.3 输出格式](#33-输出格式)
  - [4. 优化效果](#4-优化效果)
    - [4.1 策略大小](#41-策略大小)
    - [4.2 执行速度](#42-执行速度)
    - [4.3 适用场景](#43-适用场景)
  - [5. 高级技术](#5-高级技术)
    - [5.1 展开循环](#51-展开循环)
    - [5.2 函数特化](#52-函数特化)
    - [5.3 数据内联](#53-数据内联)
  - [6. WASM部署](#6-wasm部署)
    - [6.1 部分求值+WASM](#61-部分求值wasm)
    - [6.2 边缘计算场景](#62-边缘计算场景)
    - [6.3 性能对比](#63-性能对比)
  - [7. 实践案例](#7-实践案例)
    - [7.1 RBAC策略优化](#71-rbac策略优化)
    - [7.2 Kubernetes准入控制](#72-kubernetes准入控制)
    - [7.3 API网关授权](#73-api网关授权)
  - [8. 局限性](#8-局限性)
    - [8.1 适用限制](#81-适用限制)
    - [8.2 性能权衡](#82-性能权衡)
    - [8.3 调试困难](#83-调试困难)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 何时使用](#91-何时使用)
    - [9.2 策略设计](#92-策略设计)
    - [9.3 测试验证](#93-测试验证)
  - [10. 未来发展](#10-未来发展)
    - [10.1 JIT编译](#101-jit编译)
    - [10.2 自适应优化](#102-自适应优化)
    - [10.3 AI辅助特化](#103-ai辅助特化)
  - [附录A：理论基础](#附录a理论基础)
  - [附录B：实现细节](#附录b实现细节)

---

## 1. 部分求值概述

### 1.1 基本概念

**定义**：

```text
部分求值 (Partial Evaluation) 是一种程序优化技术：
给定程序 P 和部分输入 I₁，生成特化程序 P'，使得：

  P(I₁, I₂) = P'(I₂)

其中:
  - I₁: 已知输入（编译时可用）
  - I₂: 未知输入（运行时提供）
  - P': 特化后的程序（针对I₁优化）
```

**例子**：

```rego
# 原始策略 P
allow if {
    user := data.users[input.user_id]
    user.role == "admin"
}

# 已知: data.users = {"u1": {"role": "admin"}, "u2": {"role": "user"}}
# 未知: input.user_id

# 部分求值后 P'
allow if {
    input.user_id == "u1"  # 只有u1是admin
}
```

### 1.2 应用价值

**性能提升**：

```text
场景: 1000条RBAC规则，10,000个用户

完整求值:
  - 策略大小: 10MB
  - 加载时间: 500ms
  - 决策延迟: 5ms

部分求值:
  - 策略大小: 50KB (99%减少)
  - 加载时间: 10ms (98%减少)
  - 决策延迟: 0.1ms (98%减少)
```

### 1.3 核心思想

**分离关注点**：

```text
┌─────────────────────────┐
│   完整策略 + 完整数据    │
│                         │
│   data.users (10K)      │
│   + policy (1000 rules) │
│                         │
│   决策时间: 5ms         │
└─────────────────────────┘
            ↓ 部分求值
┌─────────────────────────┐
│    特化策略 (仅input)   │
│                         │
│   已预计算data部分      │
│   + 简化规则 (10 rules) │
│                         │
│   决策时间: 0.1ms       │
└─────────────────────────┘
```

---

## 2. 部分求值原理

### 2.1 已知与未知

**分类变量**：

```rego
package authz

import rego.v1

# KNOWN (编译时已知)
default_role := "user"
role_permissions := {
    "admin": ["read", "write", "delete"],
    "user": ["read"]
}

# UNKNOWN (运行时提供)
allow if {
    user := data.users[input.user_id]      # input.user_id 未知
    user.role in ["admin", "operator"]
    input.action in role_permissions[user.role]
}
```

**约定**：

```bash
# 指定未知变量
opa compile \
    --partial \
    --unknowns input \
    policy.rego
```

### 2.2 特化过程

**步骤**：

```text
1. 符号执行
   └── 遍历所有可能执行路径

2. 求值已知部分
   └── 替换data引用为具体值

3. 简化表达式
   └── 常量折叠、死代码消除

4. 生成残余代码
   └── 只保留依赖input的部分
```

**示例**：

```rego
# 原始策略
allow if {
    user := data.users[input.user_id]
    user.role == "admin"
    input.action in data.admin_actions
}

# 已知:
#   data.users = {"alice": {"role": "admin"}, "bob": {"role": "user"}}
#   data.admin_actions = ["read", "write", "delete"]

# 特化后
allow if {
    input.user_id == "alice"
    input.action in ["read", "write", "delete"]
}
```

### 2.3 残余程序

**残余程序特点**：

```text
1. 更小
   └── 移除了所有data引用

2. 更快
   └── 预计算了常量部分

3. 等价
   └── 对于所有input，结果相同

4. 特化
   └── 仅对特定data有效
```

---

## 3. OPA中的部分求值

### 3.1 编译命令

**基本用法**：

```bash
# 编译策略，指定input为未知
opa build \
    --target wasm \
    --partial \
    --unknowns input \
    -e data.authz.allow \
    policy/

# 输出: bundle.tar.gz
```

**输出内容**：

```text
bundle.tar.gz
├── policy.wasm          # 特化后的WASM
├── data.json            # 残余数据（如果有）
└── .manifest            # Bundle元数据
```

### 3.2 未知变量指定

**单个未知**：

```bash
opa compile \
    --partial \
    --unknowns input \
    policy.rego
```

**多个未知**：

```bash
opa compile \
    --partial \
    --unknowns input.user \
    --unknowns input.resource \
    policy.rego
```

**通配符**：

```bash
# input.users下的所有字段未知
opa compile \
    --partial \
    --unknowns 'input.users[_]' \
    policy.rego
```

### 3.3 输出格式

**查看特化结果**：

```bash
# 输出Rego格式的残余策略
opa build \
    --partial \
    --unknowns input \
    -e data.authz.allow \
    policy/ \
    -o bundle.tar.gz

tar -xzf bundle.tar.gz
cat policy.rego  # 查看特化后的策略
```

---

## 4. 优化效果

### 4.1 策略大小

**实测数据**：

| 原始策略 | 数据量 | 完整Bundle | 部分求值Bundle | 压缩比 |
|---------|-------|-----------|---------------|-------|
| 100KB | 1MB | 1.1MB | 10KB | 110x |
| 500KB | 10MB | 10.5MB | 50KB | 210x |
| 1MB | 100MB | 101MB | 100KB | 1010x |

### 4.2 执行速度

**性能对比**：

```text
场景: RBAC授权，10,000用户

完整策略:
  P50: 2ms
  P99: 10ms
  吞吐量: 500 req/s

部分求值:
  P50: 0.05ms (40x faster)
  P99: 0.2ms (50x faster)
  吞吐量: 20,000 req/s (40x faster)
```

### 4.3 适用场景

**高收益场景**：

```text
✅ 数据变化慢（天/周级别）
✅ 策略复杂（规则多）
✅ 数据量大（MB级别）
✅ 查询频繁（千/秒）
✅ 低延迟要求（< 1ms）
```

**低收益场景**：

```text
❌ 数据频繁变化（分钟级别）
❌ 策略简单（几条规则）
❌ 数据量小（<100KB）
❌ 查询不频繁
❌ 延迟要求宽松（> 10ms）
```

---

## 5. 高级技术

### 5.1 展开循环

**原始策略**：

```rego
allowed_users := [u |
    some u in data.users
    u.role == "admin"
]
```

**展开后**：

```rego
allowed_users := ["alice", "bob", "charlie"]
# 直接硬编码结果
```

### 5.2 函数特化

**原始策略**：

```rego
check_permission(user, action) if {
    action in data.role_permissions[user.role]
}

allow if {
    user := data.users[input.user_id]
    check_permission(user, input.action)
}
```

**特化后（内联+简化）**：

```rego
# 针对 data.users = {"alice": {"role": "admin"}}
allow if {
    input.user_id == "alice"
    input.action in ["read", "write", "delete"]
}
```

### 5.3 数据内联

**原始策略**：

```rego
allow if {
    input.user_id in data.allowed_users
}
```

**内联后**：

```rego
allow if {
    input.user_id in {"u1", "u2", "u3", ...}  # 直接嵌入
}
```

---

## 6. WASM部署

### 6.1 部分求值+WASM

**工作流**：

```text
1. 开发时: 编写策略 + 测试
   ↓
2. 构建时: 部分求值 + 编译为WASM
   opa build --target wasm --partial --unknowns input ...
   ↓
3. 部署时: 分发轻量级WASM bundle
   ↓
4. 运行时: 仅处理input（极快）
```

### 6.2 边缘计算场景

**CDN边缘节点**：

```text
需求:
  - 延迟: < 1ms
  - 资源: 有限（10MB内存）
  - 网络: 低带宽

解决方案:
  1. 中心服务器部分求值
  2. 分发小WASM bundle（< 100KB）
  3. 边缘节点加载执行

效果:
  ✅ 满足延迟要求
  ✅ 减少网络传输
  ✅ 降低资源消耗
```

### 6.3 性能对比

| 部署方式 | Bundle大小 | 加载时间 | 决策延迟 |
|---------|-----------|---------|---------|
| Native OPA (完整) | 10MB | 500ms | 5ms |
| Native OPA (部分求值) | 100KB | 20ms | 0.2ms |
| WASM (完整) | 2MB | 100ms | 2ms |
| **WASM (部分求值)** | **50KB** | **5ms** | **0.1ms** |

---

## 7. 实践案例

### 7.1 RBAC策略优化

**原始策略**：

```rego
package authz

import rego.v1

# 数据: 10,000用户，1,000角色
allow if {
    user := data.users[input.user_id]
    some role in user.roles
    some perm in data.role_permissions[role]
    perm.resource == input.resource
    perm.action == input.action
}
```

**部分求值**：

```bash
opa build \
    --target wasm \
    --partial \
    --unknowns input \
    -e data.authz.allow \
    policy/ data/

# data/ 包含10,000用户和1,000角色数据
```

**优化效果**：

```text
原始:
  Bundle: 15MB
  决策: 10ms

优化后:
  Bundle: 200KB (75x reduction)
  决策: 0.2ms (50x faster)
```

### 7.2 Kubernetes准入控制

**场景**：验证Pod安全策略

**策略**：

```rego
package k8s.admission

import rego.v1

# 已知: 安全基线策略
deny[msg] if {
    input.request.kind.kind == "Pod"
    container := input.request.object.spec.containers[_]
    not container.securityContext.runAsNonRoot
    msg := sprintf("容器必须以非root用户运行: %s", [container.name])
}
```

**部分求值**：

```bash
# 已知: data.security_baseline
# 未知: input.request

opa build \
    --target wasm \
    --partial \
    --unknowns input.request \
    policy/
```

**部署**：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
  namespace: opa
data:
  policy.wasm: |
    <base64-encoded-wasm>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
spec:
  template:
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:latest-static
        args:
          - "run"
          - "--server"
          - "/policies/policy.wasm"
        volumeMounts:
        - name: policy
          mountPath: /policies
      volumes:
      - name: policy
        configMap:
          name: opa-policy
```

### 7.3 API网关授权

**场景**：高并发API授权

**策略**：

```rego
package api.authz

import rego.v1

# 10,000个API路由，5,000个用户
allow if {
    route := data.routes[input.path]
    user := data.users[input.user_id]
    route.required_role in user.roles
}
```

**优化流程**：

```bash
# 1. 数据准备
cat > data.json <<EOF
{
  "routes": {...},  # 10,000条
  "users": {...}    # 5,000条
}
EOF

# 2. 部分求值
opa build \
    --target wasm \
    --partial \
    --unknowns input \
    -e data.api.authz.allow \
    policy/ data.json \
    -o api-authz.tar.gz

# 3. 部署到网关
# Bundle大小: 15MB → 150KB
# 决策延迟: 5ms → 0.15ms
```

---

## 8. 局限性

### 8.1 适用限制

**不适用情况**：

```rego
# 1. 依赖运行时函数
allow if {
    time.now_ns() < data.expiry  # time.now_ns()运行时变化
}

# 2. 依赖外部调用
allow if {
    response := http.send({"url": data.api_endpoint})
    response.status_code == 200
}

# 3. 复杂动态查询
allow if {
    path := input.nested.deep.path[_][_]
    data.complex_structure[path] == input.value
}
```

### 8.2 性能权衡

**Trade-offs**：

```text
优点:
  ✅ 运行时极快
  ✅ Bundle极小
  ✅ 减少网络传输

缺点:
  ❌ 编译时间长（数据大时）
  ❌ 数据变更需重新编译
  ❌ 调试困难（代码特化后）
  ❌ 灵活性降低
```

### 8.3 调试困难

**问题**：

```text
1. 源码映射丢失
   └── 特化后代码与原始代码差异大

2. 中间状态不可见
   └── 数据已内联，无法查看

3. 错误定位困难
   └── 错误信息指向特化后代码
```

**解决方案**：

```bash
# 1. 开发阶段使用Native OPA
opa eval -d policy.rego -i input.json 'data.authz.allow'

# 2. 保留原始策略用于调试
opa test policy/ -v

# 3. 部分求值前充分测试
opa test policy/ --coverage --threshold=90
```

---

## 9. 最佳实践

### 9.1 何时使用

**决策树**：

```text
数据变化频率?
├─ 小时/天/周 → 考虑部分求值
│  └─ 数据大小?
│     ├─ > 1MB → 强烈推荐
│     └─ < 100KB → 可选
│
└─ 分钟/秒 → 不推荐
   └─ 使用缓存或数据分片
```

### 9.2 策略设计

**友好的策略结构**：

```rego
# ✅ 好: 清晰分离data和input
allow if {
    # 1. 加载数据（可部分求值）
    user := data.users[input.user_id]
    permissions := data.role_permissions[user.role]
    
    # 2. 检查input（运行时）
    input.action in permissions
}

# ❌ 差: 混合data和input
allow if {
    some user in data.users  # 遍历所有用户
    user.id == input.user_id
    input.action in user.permissions
}
```

### 9.3 测试验证

**验证流程**：

```bash
# 1. 原始策略测试
opa test policy/ -v

# 2. 部分求值
opa build --partial --unknowns input policy/ data/

# 3. 验证等价性
opa eval -b bundle.tar.gz -i test_input1.json
opa eval -d policy/ -i test_input1.json
# 比较结果是否相同

# 4. 性能测试
opa bench bundle.tar.gz -i test_inputs/
```

---

## 10. 未来发展

### 10.1 JIT编译

**概念**：

```text
运行时JIT (Just-In-Time) 编译:
1. 识别热点策略
2. 动态部分求值
3. 编译为机器码
4. 缓存编译结果

效果: 接近静态编译性能，保持动态灵活性
```

### 10.2 自适应优化

**自适应特化**：

```text
根据运行时统计自动优化:
1. 收集input分布
2. 识别常见模式
3. 针对性特化
4. 动态切换策略

示例:
  - 90%请求来自admin用户
  → 特化admin路径
```

### 10.3 AI辅助特化

**机器学习优化**：

```text
使用ML预测优化策略:
1. 分析历史查询
2. 预测热点数据
3. 自动生成特化策略
4. A/B测试效果

潜力: 自动化优化过程
```

---

## 附录A：理论基础

**Futamura投影**：

```text
三个投影层次:

第一Futamura投影:
  [[P]]_I₁ = P'
  (程序特化)

第二Futamura投影:
  [[Eval]]_P = Compiler_P
  (编译器生成)

第三Futamura投影:
  [[Eval]]_Eval = Compiler-Compiler
  (编译器生成器)

OPA实现: 第一投影
```

---

## 附录B：实现细节

**特化算法（简化）**：

```go
func PartialEval(policy *Policy, knownData map[string]interface{}) *Policy {
    residual := &Policy{}
    
    for _, rule := range policy.Rules {
        // 1. 替换data引用
        specialized := substituteData(rule, knownData)
        
        // 2. 简化表达式
        simplified := simplify(specialized)
        
        // 3. 检查是否完全求值
        if isFullyEvaluated(simplified) {
            // 直接添加结果
            residual.addConstant(rule.Head, simplified.Value)
        } else {
            // 保留残余规则
            residual.addRule(simplified)
        }
    }
    
    return residual
}

func substituteData(rule *Rule, data map[string]interface{}) *Rule {
    newRule := rule.Clone()
    
    for _, expr := range newRule.Body {
        if ref, ok := expr.(*DataRef); ok {
            // 替换 data.x 为具体值
            value := resolve(data, ref.Path)
            newRule.replaceExpr(expr, &Constant{Value: value})
        }
    }
    
    return newRule
}

func simplify(rule *Rule) *Rule {
    // 常量折叠
    rule = constantFold(rule)
    
    // 死代码消除
    rule = deadCodeElimination(rule)
    
    // 表达式化简
    rule = simplifyExpressions(rule)
    
    return rule
}
```

---

**相关文档**：

- [编译器设计](./03.3-编译器设计.md)
- [索引与优化](./03.5-索引与优化.md)
- [WASM编译规范](../01-技术规范/01.3-WASM编译规范.md)

**参考资源**：

- Partial Evaluation: <https://www.openpolicyagent.org/docs/latest/policy-performance/#partial-evaluation>
- WASM Compilation: <https://www.openpolicyagent.org/docs/latest/wasm/>
- Futamura Projections: <https://en.wikipedia.org/wiki/Partial_evaluation>

