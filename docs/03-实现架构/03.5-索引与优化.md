# 索引与优化（Indexing and Optimization）

> **更新日期**: 2025年10月21日  
> **OPA版本**: v0.60+  
> **参考**: <https://www.openpolicyagent.org/docs/latest/policy-performance/>

---

## 目录

- [索引与优化（Indexing and Optimization）](#索引与优化indexing-and-optimization)
  - [目录](#目录)
  - [1. 索引概述](#1-索引概述)
    - [1.1 为什么需要索引](#11-为什么需要索引)
    - [1.2 索引类型](#12-索引类型)
    - [1.3 索引收益](#13-索引收益)
  - [2. 自动索引](#2-自动索引)
    - [2.1 索引触发条件](#21-索引触发条件)
    - [2.2 索引构建](#22-索引构建)
    - [2.3 索引使用](#23-索引使用)
  - [3. 手动索引优化](#3-手动索引优化)
    - [3.1 数据结构重组](#31-数据结构重组)
    - [3.2 预计算索引](#32-预计算索引)
    - [3.3 哈希表优化](#33-哈希表优化)
  - [4. 查询优化](#4-查询优化)
    - [4.1 查询重写](#41-查询重写)
    - [4.2 谓词下推](#42-谓词下推)
    - [4.3 连接顺序优化](#43-连接顺序优化)
  - [5. 编译优化](#5-编译优化)
    - [5.1 常量折叠](#51-常量折叠)
    - [5.2 死代码消除](#52-死代码消除)
    - [5.3 规则内联](#53-规则内联)
  - [6. 运行时优化](#6-运行时优化)
    - [6.1 缓存机制](#61-缓存机制)
    - [6.2 惰性求值](#62-惰性求值)
    - [6.3 短路求值](#63-短路求值)
  - [7. 数据结构优化](#7-数据结构优化)
    - [7.1 Trie树](#71-trie树)
    - [7.2 布隆过滤器](#72-布隆过滤器)
    - [7.3 位图索引](#73-位图索引)
  - [8. 性能分析](#8-性能分析)
    - [8.1 性能剖析工具](#81-性能剖析工具)
    - [8.2 热点识别](#82-热点识别)
    - [8.3 瓶颈分析](#83-瓶颈分析)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 策略设计原则](#91-策略设计原则)
    - [9.2 数据组织原则](#92-数据组织原则)
    - [9.3 测试与验证](#93-测试与验证)
  - [10. 案例研究](#10-案例研究)
    - [10.1 大规模RBAC优化](#101-大规模rbac优化)
    - [10.2 日志过滤优化](#102-日志过滤优化)
    - [10.3 实时策略决策](#103-实时策略决策)
  - [附录A：性能基准](#附录a性能基准)
  - [附录B：优化清单](#附录b优化清单)

---

## 1. 索引概述

### 1.1 为什么需要索引

**性能问题**：

```rego
# ❌ 线性扫描 O(n) - 10,000个用户，每次查询10ms
user_by_email(email) := user if {
    some user in data.users
    user.email == email
}

# ✅ 索引访问 O(1) - 10,000个用户，每次查询0.001ms
user_by_email(email) := data.users_by_email[email]
```

**性能对比**：

| 数据量 | 无索引 | 有索引 | 加速比 |
|-------|-------|-------|-------|
| 100 | 0.1ms | 0.001ms | 100x |
| 1,000 | 1ms | 0.001ms | 1000x |
| 10,000 | 10ms | 0.001ms | 10000x |
| 100,000 | 100ms | 0.001ms | 100000x |

### 1.2 索引类型

**索引分类**：

```text
1. 哈希索引 (Hash Index)
   └── O(1)平均查找时间
   └── 适用于等值查询

2. B-Tree索引
   └── O(log n)查找时间
   └── 支持范围查询

3. Trie索引
   └── O(k)查找时间（k=键长度）
   └── 适用于前缀匹配

4. 位图索引 (Bitmap Index)
   └── 适用于低基数列
   └── 空间高效
```

### 1.3 索引收益

**场景分析**：

```text
高收益场景:
✅ 大数据集（> 1000条）
✅ 频繁查询
✅ 等值查找
✅ 数据变更少

低收益场景:
❌ 小数据集（< 100条）
❌ 全表扫描
❌ 数据频繁变更
❌ 复杂条件查询
```

---

## 2. 自动索引

### 2.1 索引触发条件

**OPA自动索引模式**：

```rego
# 模式1: data.collection[_].field == constant
users_named_alice := [u | 
    some u in data.users
    u.name == "alice"
]
# OPA自动构建: name → user 索引

# 模式2: data.collection[variable]
user := data.users[input.user_id]
# OPA自动构建: id → user 索引（如果users是对象）

# 模式3: constant in data.collection[_].field
admins := [u | 
    some u in data.users
    "admin" in u.roles
]
# OPA可能构建: role → users 倒排索引
```

### 2.2 索引构建

**内部实现（简化）**：

```go
type Index struct {
    Path      []string          // 索引路径
    KeyFunc   func(interface{}) interface{}  // 提取键
    Index     map[interface{}][]*Value       // 索引映射
}

func BuildIndex(data []interface{}, keyPath []string) *Index {
    index := &Index{
        Path:  keyPath,
        Index: make(map[interface{}][]*Value),
    }
    
    for _, item := range data {
        key := extractKey(item, keyPath)
        index.Index[key] = append(index.Index[key], item)
    }
    
    return index
}
```

### 2.3 索引使用

**查询改写**：

```text
原始查询:
  user in data.users
  user.email == "alice@example.com"

索引改写:
  candidates = INDEX_LOOKUP(users, email, "alice@example.com")
  user in candidates
```

---

## 3. 手动索引优化

### 3.1 数据结构重组

**优化前**：

```json
{
  "users": [
    {"id": "u1", "email": "alice@example.com", "role": "admin"},
    {"id": "u2", "email": "bob@example.com", "role": "user"}
  ]
}
```

**优化后（添加索引）**：

```json
{
  "users": [...],
  "users_by_id": {
    "u1": {"email": "alice@example.com", "role": "admin"},
    "u2": {"email": "bob@example.com", "role": "user"}
  },
  "users_by_email": {
    "alice@example.com": {"id": "u1", "role": "admin"},
    "bob@example.com": {"id": "u2", "role": "user"}
  },
  "users_by_role": {
    "admin": [{"id": "u1", "email": "alice@example.com"}],
    "user": [{"id": "u2", "email": "bob@example.com"}]
  }
}
```

### 3.2 预计算索引

**在Bundle构建时预计算**：

```python
# build_bundle.py
import json

def build_indexes(users):
    indexes = {
        "by_id": {},
        "by_email": {},
        "by_role": {}
    }
    
    for user in users:
        # ID索引
        indexes["by_id"][user["id"]] = user
        
        # Email索引
        indexes["by_email"][user["email"]] = user
        
        # Role索引（倒排）
        role = user["role"]
        if role not in indexes["by_role"]:
            indexes["by_role"][role] = []
        indexes["by_role"][role].append(user)
    
    return indexes

# 生成data.json
users = load_users()
data = {
    "users": users,
    "indexes": build_indexes(users)
}

with open("data.json", "w") as f:
    json.dump(data, f)
```

### 3.3 哈希表优化

**使用对象而非数组**：

```rego
# ❌ 慢: 数组存储 O(n)
users := [
    {"id": "u1", ...},
    {"id": "u2", ...}
]

user_by_id(id) := user if {
    some user in users
    user.id == id
}

# ✅ 快: 对象存储 O(1)
users := {
    "u1": {...},
    "u2": {...}
}

user_by_id(id) := users[id]
```

---

## 4. 查询优化

### 4.1 查询重写

**规则重写器**：

```rego
# 原始策略
admins := [u |
    some u in data.users
    u.role == "admin"
    u.active == true
]

# 优化后（如果active用户远少于total）
admins := [u |
    some u in data.active_users  # 先过滤active
    u.role == "admin"
]
```

### 4.2 谓词下推

**过滤条件提前**：

```rego
# ❌ 低效: 先笛卡尔积再过滤
conflicts := [[u1, u2] |
    some u1 in data.users
    some u2 in data.users
    u1.team == u2.team
    u1.id != u2.id
]

# ✅ 高效: 按team分组后处理
team_members := {team: users |
    some user in data.users
    team := user.team
    users := [u | some u in data.users; u.team == team]
}

conflicts := [[u1, u2] |
    some team, members in team_members
    some u1 in members
    some u2 in members
    u1.id < u2.id  # 避免重复
]
```

### 4.3 连接顺序优化

**选择性估算**：

```rego
# 假设:
#   - 10,000 users
#   - 100 admins
#   - 50 active sessions

# ❌ 差: 先大表连接
result := [r |
    some u in data.users           # 10,000
    some s in data.sessions        # 50
    u.id == s.user_id
    u.role == "admin"              # 过滤到100
]
# 复杂度: 10,000 × 50 = 500,000

# ✅ 好: 先过滤小表
result := [r |
    some s in data.sessions        # 50
    some u in data.users           # 查询50次
    u.id == s.user_id
    u.role == "admin"
]
# 复杂度: 50 + 50 = 100
```

---

## 5. 编译优化

### 5.1 常量折叠

```rego
# 优化前
max_age := 30 + 20 - 10

# 优化后（编译时计算）
max_age := 40
```

### 5.2 死代码消除

```rego
# 优化前
allow if {
    false
    input.user == "admin"  # 永远不会执行
}

# 优化后（整个规则删除）
# (无代码)
```

### 5.3 规则内联

```rego
# 优化前
is_admin if {
    input.user.role == "admin"
}

allow if {
    is_admin
}

# 优化后（内联）
allow if {
    input.user.role == "admin"
}
```

---

## 6. 运行时优化

### 6.1 缓存机制

**结果缓存**：

```yaml
# config.yaml
caching:
  inter_query_builtin_cache:
    max_size_bytes: 10485760  # 10MB
```

**受益函数**：

- `http.send`: 缓存HTTP响应
- `io.jwt.decode`: 缓存JWT解析
- `crypto.*`: 缓存加密操作

### 6.2 惰性求值

**延迟计算**：

```rego
# 惰性集合推导
expensive_set := {x |
    some item in data.large_collection
    x := expensive_function(item)
}

# 只有在访问时才计算
result := count(expensive_set)  # 此时才执行推导
```

### 6.3 短路求值

**AND短路**：

```rego
allow if {
    cheap_check      # 快速检查
    expensive_check  # 只有cheap_check成功才执行
}

cheap_check if {
    input.method == "GET"
}

expensive_check if {
    http.send({"method": "POST", "url": "..."}).status_code == 200
}
```

---

## 7. 数据结构优化

### 7.1 Trie树

**前缀匹配优化**：

```go
// 实现路径前缀查找
type Trie struct {
    children map[string]*Trie
    value    interface{}
    isEnd    bool
}

func (t *Trie) Insert(path []string, value interface{}) {
    node := t
    for _, segment := range path {
        if node.children[segment] == nil {
            node.children[segment] = &Trie{
                children: make(map[string]*Trie),
            }
        }
        node = node.children[segment]
    }
    node.value = value
    node.isEnd = true
}

func (t *Trie) Search(path []string) interface{} {
    node := t
    for _, segment := range path {
        if node.children[segment] == nil {
            return nil
        }
        node = node.children[segment]
    }
    if node.isEnd {
        return node.value
    }
    return nil
}
```

### 7.2 布隆过滤器

**快速否定查询**：

```go
// 检查元素可能存在
type BloomFilter struct {
    bits []bool
    k    int  // 哈希函数数量
}

func (bf *BloomFilter) MayContain(key string) bool {
    for i := 0; i < bf.k; i++ {
        h := hash(key, i)
        if !bf.bits[h%len(bf.bits)] {
            return false  // 确定不存在
        }
    }
    return true  // 可能存在
}
```

### 7.3 位图索引

**低基数列优化**：

```go
// 性别、状态等低基数字段
type BitmapIndex struct {
    bitmaps map[string]*roaring.Bitmap
}

func (bi *BitmapIndex) Add(value string, id uint32) {
    if bi.bitmaps[value] == nil {
        bi.bitmaps[value] = roaring.New()
    }
    bi.bitmaps[value].Add(id)
}

func (bi *BitmapIndex) Query(value string) []uint32 {
    if bitmap := bi.bitmaps[value]; bitmap != nil {
        return bitmap.ToArray()
    }
    return []uint32{}
}
```

---

## 8. 性能分析

### 8.1 性能剖析工具

**OPA Profiler**：

```bash
# 启用profiling
opa eval -d policy.rego 'data.authz.allow' \
    -i input.json \
    --profile

# CPU profiling
opa eval --profile --profile-sort totaltime ...

# 内存profiling
opa eval --profile --profile-sort allocspace ...
```

### 8.2 热点识别

**profile输出**：

```text
+----------+----------+----------+---------+
| LOCATION | NUMGEN   | TOTAL    | PERCENT |
+----------+----------+----------+---------+
| data.authz.expensive_rule | 10000 | 450ms | 90% |
| data.authz.cheap_rule     | 10000 | 50ms  | 10% |
+----------+----------+----------+---------+
```

### 8.3 瓶颈分析

**分析维度**：

```text
1. 时间复杂度
   └── 检查循环嵌套深度

2. 空间复杂度
   └── 检查中间集合大小

3. I/O操作
   └── 检查http.send频率

4. 数据访问模式
   └── 检查扫描vs索引
```

---

## 9. 最佳实践

### 9.1 策略设计原则

**DO's**:

```rego
# ✅ 使用集合操作而非循环
allowed_actions := user_permissions & requested_permissions

# ✅ 提前退出
allow if {
    input.method == "GET"  # 快速检查
    expensive_validation   # 只在需要时执行
}

# ✅ 缓存昂贵计算
user_permissions := data.roles[input.user.role].permissions

allow if {
    input.action in user_permissions  # 复用缓存
}
```

**DON'Ts**:

```rego
# ❌ 避免笛卡尔积
conflicts := [[x, y] |
    some x in large_set1
    some y in large_set2
    condition(x, y)
]

# ❌ 避免深层嵌套循环
result := [item |
    some a in data.set1
    some b in data.set2
    some c in data.set3
    some d in data.set4
    condition(a, b, c, d)
]
```

### 9.2 数据组织原则

**原则**：

```text
1. 预计算索引
   └── 在Bundle构建时创建

2. 扁平化结构
   └── 避免深度嵌套

3. 规范化vs反规范化
   └── 根据查询模式选择

4. 合理分片
   └── 按访问模式拆分大对象
```

### 9.3 测试与验证

**性能测试**：

```bash
# Benchmark测试
opa test policy/ --bench

# 负载测试
hey -n 100000 -c 100 \
  -m POST \
  -H "Content-Type: application/json" \
  -d @input.json \
  http://localhost:8181/v1/data/authz/allow
```

---

## 10. 案例研究

### 10.1 大规模RBAC优化

**场景**: 10,000用户，1,000角色，100,000权限

**优化前**：

```rego
# O(n×m×k) 复杂度
allow if {
    some role in input.user.roles
    some perm in data.role_permissions[role]
    perm.resource == input.resource
    perm.action == input.action
}
# 性能: 50ms/决策
```

**优化后**：

```rego
# 预计算用户权限
user_perms := {concat(":", [p.resource, p.action]) |
    some role in input.user.roles
    some p in data.role_permissions[role]
}

# O(1) 查找
allow if {
    concat(":", [input.resource, input.action]) in user_perms
}
# 性能: 0.5ms/决策 (100x提升)
```

### 10.2 日志过滤优化

**场景**: 过滤100万条日志

**优化策略**：

```rego
# 1. 使用位图索引
logs_by_level := {
    "ERROR": bitmap([1, 5, 10, ...]),
    "INFO":  bitmap([2, 3, 4, ...])
}

# 2. 布隆过滤器预筛选
filtered_logs := [log |
    some log in data.logs
    bloom_filter.may_contain(log.id)  # 快速排除
    expensive_condition(log)           # 精确检查
]
```

### 10.3 实时策略决策

**要求**: P99 < 1ms

**优化技术**：

```text
1. 部分求值
   └── 预编译data部分

2. WASM编译
   └── 接近原生性能

3. 缓存
   └── 缓存频繁查询

4. 连接池
   └── 复用OPA实例

结果: P50=0.2ms, P99=0.8ms ✅
```

---

## 附录A：性能基准

**标准测试场景**：

| 场景 | 数据规模 | 无优化 | 优化后 | 提升 |
|------|---------|-------|-------|------|
| 简单RBAC | 100用户 | 0.5ms | 0.1ms | 5x |
| 复杂RBAC | 10K用户 | 50ms | 0.5ms | 100x |
| 日志过滤 | 1M条 | 5s | 50ms | 100x |
| 图遍历 | 10K节点 | 200ms | 10ms | 20x |

---

## 附录B：优化清单

**编译时优化**:

- [ ] 启用部分求值 (`--optimize`)
- [ ] 移除未使用规则
- [ ] 内联小函数
- [ ] 常量折叠

**数据优化**:

- [ ] 预计算索引
- [ ] 对象化数组（ID→Object）
- [ ] 扁平化深层嵌套
- [ ] 分片大对象

**策略优化**:

- [ ] 提前退出条件
- [ ] 集合操作代替循环
- [ ] 避免笛卡尔积
- [ ] 缓存昂贵计算

**运行时优化**:

- [ ] 启用缓存
- [ ] 使用WASM编译
- [ ] 连接池/实例复用
- [ ] 监控热点

---

**相关文档**：

- [Top-Down求值器](./03.4-Top-Down求值器.md)
- [部分求值技术](./03.6-部分求值技术.md)
- [性能基准与度量](../01-技术规范/01.4-性能基准与度量.md)

**参考资源**：

- Performance Documentation: <https://www.openpolicyagent.org/docs/latest/policy-performance/>
- Best Practices: <https://www.openpolicyagent.org/docs/latest/faq/>
