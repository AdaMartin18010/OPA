# AST与IR（Abstract Syntax Tree and Intermediate Representation）

> **更新日期**: 2025年10月21日  
> **OPA版本**: v0.60+  
> **实现语言**: Go  
> **参考**: <https://github.com/open-policy-agent/opa>

---

## 目录

- [AST与IR（Abstract Syntax Tree and Intermediate Representation）](#ast与irabstract-syntax-tree-and-intermediate-representation)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 编译流程](#11-编译流程)
    - [1.2 AST的作用](#12-ast的作用)
    - [1.3 IR的作用](#13-ir的作用)
  - [2. AST结构](#2-ast结构)
    - [2.1 节点类型](#21-节点类型)
    - [2.2 AST表示](#22-ast表示)
    - [2.3 位置信息](#23-位置信息)
  - [3. AST构建](#3-ast构建)
    - [3.1 解析器输出](#31-解析器输出)
    - [3.2 AST遍历](#32-ast遍历)
    - [3.3 AST转换](#33-ast转换)
  - [4. 中间表示（IR）](#4-中间表示ir)
    - [4.1 IR设计目标](#41-ir设计目标)
    - [4.2 IR结构](#42-ir结构)
    - [4.3 IR指令集](#43-ir指令集)
  - [5. AST到IR转换](#5-ast到ir转换)
    - [5.1 规则转换](#51-规则转换)
    - [5.2 表达式转换](#52-表达式转换)
    - [5.3 推导转换](#53-推导转换)
  - [6. 类型注解](#6-类型注解)
    - [6.1 类型推断](#61-类型推断)
    - [6.2 类型标注](#62-类型标注)
    - [6.3 类型检查](#63-类型检查)
  - [7. 优化](#7-优化)
    - [7.1 常量折叠](#71-常量折叠)
    - [7.2 死代码消除](#72-死代码消除)
    - [7.3 内联展开](#73-内联展开)
  - [8. IR执行](#8-ir执行)
    - [8.1 解释执行](#81-解释执行)
    - [8.2 JIT编译](#82-jit编译)
    - [8.3 WASM生成](#83-wasm生成)
  - [9. 调试支持](#9-调试支持)
    - [9.1 AST可视化](#91-ast可视化)
    - [9.2 IR调试](#92-ir调试)
    - [9.3 源码映射](#93-源码映射)
  - [10. 实现细节](#10-实现细节)
    - [10.1 Go数据结构](#101-go数据结构)
    - [10.2 内存管理](#102-内存管理)
    - [10.3 性能考虑](#103-性能考虑)
  - [附录A：完整AST示例](#附录a完整ast示例)
  - [附录B：IR指令参考](#附录bir指令参考)

---

## 1. 概述

### 1.1 编译流程

**完整编译管道**：

```text
Rego源码
    ↓
┌─────────────────┐
│  词法分析器      │ → Token流
│  (Lexer)        │
└────────┬────────┘
         ↓
┌─────────────────┐
│  语法分析器      │ → AST (抽象语法树)
│  (Parser)       │
└────────┬────────┘
         ↓
┌─────────────────┐
│  语义分析        │ → 类型注解AST
│  (Type Checker) │
└────────┬────────┘
         ↓
┌─────────────────┐
│  IR生成          │ → IR (中间表示)
│  (IR Builder)   │
└────────┬────────┘
         ↓
┌─────────────────┐
│  优化器          │ → 优化后IR
│  (Optimizer)    │
└────────┬────────┘
         ↓
┌─────────────────┐
│  代码生成        │ → 字节码/WASM/原生代码
│  (Code Gen)     │
└─────────────────┘
```

### 1.2 AST的作用

**AST（Abstract Syntax Tree）核心价值**：

```text
1. 结构化表示
   ├── 消除语法细节（空格、注释）
   ├── 保留语义结构
   └── 易于程序分析

2. 工具基础
   ├── 代码格式化 (opa fmt)
   ├── 静态分析 (opa check)
   ├── 代码生成
   └── IDE支持

3. 编译基础
   ├── 类型检查
   ├── 优化
   └── IR生成
```

### 1.3 IR的作用

**IR（Intermediate Representation）核心价值**：

```text
1. 平台无关
   ├── 统一的抽象层
   ├── 多后端支持（解释器、WASM、JIT）
   └── 便于优化

2. 优化友好
   ├── 简化的指令集
   ├── 显式控制流
   └── 易于分析

3. 执行高效
   ├── 接近机器码
   ├── 减少解释开销
   └── 支持JIT编译
```

---

## 2. AST结构

### 2.1 节点类型

**AST节点层次**：

```text
Node (所有节点基类)
│
├── Statement
│   ├── Package
│   ├── Import
│   ├── Rule
│   └── Comment
│
├── Term
│   ├── Var (变量)
│   ├── Scalar
│   │   ├── Null
│   │   ├── Boolean
│   │   ├── Number
│   │   └── String
│   ├── Array
│   ├── Object
│   ├── Set
│   ├── Ref (引用)
│   └── Call (函数调用)
│
└── Expr (表达式)
    ├── Equality (=)
    ├── Assignment (:=)
    ├── Comparison (==, !=, <, >)
    ├── Term
    └── SomeDecl (some)
```

### 2.2 AST表示

**示例Rego代码**：

```rego
package authz

import rego.v1

default allow := false

allow if {
    input.user.role == "admin"
}
```

**对应AST（简化JSON）**：

```json
{
  "type": "Module",
  "package": {
    "type": "Package",
    "path": ["authz"]
  },
  "imports": [
    {
      "type": "Import",
      "path": ["rego", "v1"]
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "default": true,
      "head": {
        "name": "allow",
        "value": {
          "type": "Boolean",
          "value": false
        }
      }
    },
    {
      "type": "Rule",
      "head": {
        "name": "allow"
      },
      "body": [
        {
          "type": "Expr",
          "terms": [
            {
              "type": "Comparison",
              "operator": "==",
              "operands": [
                {
                  "type": "Ref",
                  "value": [
                    {"type": "Var", "value": "input"},
                    {"type": "String", "value": "user"},
                    {"type": "String", "value": "role"}
                  ]
                },
                {
                  "type": "String",
                  "value": "admin"
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

### 2.3 位置信息

**Location元数据**：

```go
type Location struct {
    File string    // 文件路径
    Row  int       // 行号（从1开始）
    Col  int       // 列号（从1开始）
    Text []byte    // 源代码文本
}
```

**用途**：

```text
1. 错误报告
   └── 精确指出错误位置

2. IDE支持
   ├── 跳转到定义
   ├── 重命名
   └── 代码补全

3. 调试
   ├── 断点设置
   └── 堆栈追踪
```

---

## 3. AST构建

### 3.1 解析器输出

**解析过程**：

```go
// 简化的解析器接口
package ast

func ParseModule(filename string, source []byte) (*Module, error) {
    // 1. 词法分析
    lexer := NewLexer(source)
    tokens := lexer.Tokenize()
    
    // 2. 语法分析
    parser := NewParser(tokens)
    module := parser.ParseModule()
    
    // 3. 设置位置信息
    module.Location = &Location{
        File: filename,
        Row:  1,
        Col:  1,
        Text: source,
    }
    
    return module, nil
}
```

### 3.2 AST遍历

**Visitor模式**：

```go
// AST访问者接口
type Visitor interface {
    Visit(node Node) (w Visitor)
}

// 遍历AST
func Walk(v Visitor, node Node) {
    if v = v.Visit(node); v == nil {
        return
    }
    
    switch n := node.(type) {
    case *Module:
        Walk(v, n.Package)
        for _, imp := range n.Imports {
            Walk(v, imp)
        }
        for _, rule := range n.Rules {
            Walk(v, rule)
        }
    case *Rule:
        Walk(v, n.Head)
        for _, expr := range n.Body {
            Walk(v, expr)
        }
    // ... 其他节点类型
    }
}
```

**使用示例**：

```go
// 收集所有变量名
type VarCollector struct {
    Vars []string
}

func (vc *VarCollector) Visit(node Node) Visitor {
    if v, ok := node.(*Var); ok {
        vc.Vars = append(vc.Vars, string(v.Value))
    }
    return vc
}

// 使用
collector := &VarCollector{}
Walk(collector, module)
fmt.Println("变量:", collector.Vars)
```

### 3.3 AST转换

**常见转换**：

```go
// 1. 变量重命名
type Renamer struct {
    Old string
    New string
}

func (r *Renamer) Visit(node Node) Visitor {
    if v, ok := node.(*Var); ok {
        if string(v.Value) == r.Old {
            v.Value = Var(r.New)
        }
    }
    return r
}

// 2. 常量折叠
type ConstantFolder struct{}

func (cf *ConstantFolder) Visit(node Node) Visitor {
    if call, ok := node.(*Call); ok {
        // 如果所有参数都是常量，求值函数调用
        if allConstants(call.Args) {
            result := evaluate(call)
            return result
        }
    }
    return cf
}
```

---

## 4. 中间表示（IR）

### 4.1 IR设计目标

**设计原则**：

```text
1. 简洁性
   └── 指令集小而精

2. 可优化性
   ├── SSA形式（Static Single Assignment）
   └── 显式控制流

3. 可移植性
   └── 平台无关的抽象

4. 高效性
   └── 接近机器表示
```

### 4.2 IR结构

**IR模块结构**：

```text
IR Module
├── Functions
│   ├── Name
│   ├── Parameters
│   ├── Blocks
│   │   ├── Label
│   │   └── Instructions
│   └── Return Type
│
├── Data Segments
│   └── Static Data
│
└── Metadata
    ├── Source Mapping
    └── Type Information
```

### 4.3 IR指令集

**核心指令**：

```text
数据操作:
  - Load     # 加载变量/常量
  - Store    # 存储值
  - Move     # 移动数据

算术运算:
  - Add, Sub, Mul, Div, Mod
  - Neg      # 取负

比较运算:
  - Eq, Neq, Lt, Lte, Gt, Gte

逻辑运算:
  - And, Or, Not

控制流:
  - Jump     # 无条件跳转
  - Branch   # 条件跳转
  - Call     # 函数调用
  - Return   # 返回

数据结构:
  - MakeArray
  - MakeObject
  - MakeSet
  - ArrayIndex
  - ObjectGet
  - SetContains

统一:
  - Unify    # 统一两个值
  - Scan     # 遍历集合
```

---

## 5. AST到IR转换

### 5.1 规则转换

**Rego规则**：

```rego
allow if {
    input.user.role == "admin"
    input.action in ["read", "write"]
}
```

**IR（伪代码）**：

```text
function data.authz.allow():
  block entry:
    %1 = load input
    %2 = get %1["user"]
    %3 = get %2["role"]
    %4 = eq %3, "admin"
    branch %4, check_action, fail
  
  block check_action:
    %5 = load input
    %6 = get %5["action"]
    %7 = make_set ["read", "write"]
    %8 = set_contains %7, %6
    branch %8, success, fail
  
  block success:
    return true
  
  block fail:
    return undefined
```

### 5.2 表达式转换

**复杂表达式**：

```rego
result := x + y * 2
```

**IR**：

```text
%1 = load y
%2 = mul %1, 2
%3 = load x
%4 = add %3, %2
store result, %4
```

### 5.3 推导转换

**数组推导**：

```rego
squares := [x * x | some x in [1, 2, 3]]
```

**IR（伪代码）**：

```text
%1 = make_array []
%2 = make_array [1, 2, 3]
%iter = scan %2

loop:
  %x = next %iter
  branch_exhausted %iter, done
  %sq = mul %x, %x
  append %1, %sq
  jump loop

done:
  store squares, %1
```

---

## 6. 类型注解

### 6.1 类型推断

**Hindley-Milner风格类型推断**：

```text
规则:
1. 字面量类型是确定的
   10 : number
   "hello" : string

2. 变量类型通过使用推断
   x = 10  →  x : number

3. 函数类型通过签名推断
   count(arr) → arr : array, result : number

4. 统一约束类型
   x = y, x : number  →  y : number
```

**实现**：

```go
type TypeInfer struct {
    env map[string]Type  // 环境
}

func (ti *TypeInfer) Infer(node Node) Type {
    switch n := node.(type) {
    case *Number:
        return TypeNumber
    case *String:
        return TypeString
    case *Var:
        return ti.env[n.Value]
    case *Call:
        // 根据函数签名推断
        return ti.inferCall(n)
    }
}
```

### 6.2 类型标注

**AST中的类型信息**：

```go
type Expr struct {
    // ... 其他字段
    
    // 类型注解
    TypeAnnotation Type
}

type Type interface {
    String() string
}

type SimpleType string

const (
    TypeNumber  SimpleType = "number"
    TypeString  SimpleType = "string"
    TypeBoolean SimpleType = "boolean"
    TypeNull    SimpleType = "null"
    TypeAny     SimpleType = "any"
)

type ArrayType struct {
    ElementType Type
}

type ObjectType struct {
    KeyType   Type
    ValueType Type
}
```

### 6.3 类型检查

**类型检查器**：

```go
type TypeChecker struct {
    errors []error
}

func (tc *TypeChecker) Check(module *Module) error {
    for _, rule := range module.Rules {
        tc.checkRule(rule)
    }
    if len(tc.errors) > 0 {
        return fmt.Errorf("类型错误: %v", tc.errors)
    }
    return nil
}

func (tc *TypeChecker) checkRule(rule *Rule) {
    // 检查规则头类型
    headType := tc.inferType(rule.Head.Value)
    
    // 检查规则体
    for _, expr := range rule.Body {
        exprType := tc.inferType(expr)
        if exprType != TypeBoolean {
            tc.errors = append(tc.errors, 
                fmt.Errorf("表达式必须返回布尔值"))
        }
    }
}
```

---

## 7. 优化

### 7.1 常量折叠

**优化前**：

```rego
x := 1 + 2 * 3
```

**IR（优化前）**：

```text
%1 = load 2
%2 = load 3
%3 = mul %1, %2
%4 = load 1
%5 = add %4, %3
store x, %5
```

**IR（优化后）**：

```text
store x, 7
```

**实现**：

```go
func ConstantFold(instr Instruction) Instruction {
    switch i := instr.(type) {
    case *Add:
        if IsConst(i.Left) && IsConst(i.Right) {
            return &Const{
                Value: i.Left.Value() + i.Right.Value(),
            }
        }
    case *Mul:
        if IsConst(i.Left) && IsConst(i.Right) {
            return &Const{
                Value: i.Left.Value() * i.Right.Value(),
            }
        }
    }
    return instr
}
```

### 7.2 死代码消除

**优化前**：

```rego
allow if {
    true
    false  # 永远失败，后续代码无效
    input.user == "admin"
}
```

**IR（优化后）**：

```text
function allow():
  return undefined  # 直接返回失败
```

### 7.3 内联展开

**优化前**：

```rego
is_admin if {
    input.user.role == "admin"
}

allow if {
    is_admin
}
```

**优化后（内联）**：

```rego
allow if {
    input.user.role == "admin"
}
```

---

## 8. IR执行

### 8.1 解释执行

**IR解释器**：

```go
type Interpreter struct {
    stack []Value
    env   map[string]Value
}

func (interp *Interpreter) Execute(ir *IR) (Value, error) {
    for _, instr := range ir.Instructions {
        if err := interp.executeInstruction(instr); err != nil {
            return nil, err
        }
    }
    return interp.stack[len(interp.stack)-1], nil
}

func (interp *Interpreter) executeInstruction(instr Instruction) error {
    switch i := instr.(type) {
    case *Load:
        val := interp.env[i.Name]
        interp.stack = append(interp.stack, val)
    case *Add:
        b := interp.pop()
        a := interp.pop()
        interp.push(a + b)
    case *Call:
        args := interp.popN(i.ArgCount)
        result := i.Function(args...)
        interp.push(result)
    }
    return nil
}
```

### 8.2 JIT编译

**动态编译（概念）**：

```text
JIT Compilation Pipeline:
1. 识别热点代码（频繁执行的IR）
2. 编译为本地机器码
3. 缓存编译结果
4. 后续执行直接使用机器码

优势:
- 消除解释开销
- 接近C/C++性能
- 运行时优化
```

### 8.3 WASM生成

**IR到WASM转换**：

```text
IR Instruction      → WASM Instruction
─────────────────────────────────────
Load var            → local.get $var
Store var, val      → local.set $var
Add a, b            → i32.add
Mul a, b            → i32.mul
Call func           → call $func
Branch cond, label  → br_if $label
Return val          → return
```

---

## 9. 调试支持

### 9.1 AST可视化

**opa parse命令**：

```bash
# 解析并输出AST（JSON格式）
opa parse policy.rego --format json

# 美化输出
opa parse policy.rego --format json | jq .
```

**输出示例**：

```json
{
  "package": {
    "path": [{"type": "var", "value": "authz"}]
  },
  "rules": [
    {
      "head": {"name": "allow"},
      "body": [
        {
          "terms": [
            {"type": "ref", "value": [
              {"type": "var", "value": "input"},
              {"type": "string", "value": "user"}
            ]},
            {"type": "string", "value": "admin"}
          ]
        }
      ]
    }
  ]
}
```

### 9.2 IR调试

**打印IR**：

```bash
# 编译并输出IR
opa build policy.rego --debug
```

### 9.3 源码映射

**Source Map结构**：

```json
{
  "version": 3,
  "sources": ["policy.rego"],
  "mappings": [
    {
      "ir_offset": 0,
      "source_file": "policy.rego",
      "source_line": 5,
      "source_column": 1
    }
  ]
}
```

**用途**：

- 错误堆栈映射回源代码
- 调试器断点设置
- 性能分析

---

## 10. 实现细节

### 10.1 Go数据结构

**核心AST结构**：

```go
// github.com/open-policy-agent/opa/ast/ast.go

type Module struct {
    Package  *Package
    Imports  []*Import
    Rules    []*Rule
    Comments []*Comment
}

type Rule struct {
    Default  bool
    Head     *Head
    Body     Body
    Else     *Rule
    Location *Location
}

type Term struct {
    Value    Value
    Location *Location
}

type Value interface {
    Compare(other Value) int
    IsGround() bool
    String() string
}

// 具体Value类型
type (
    Null    string
    Boolean bool
    Number  json.Number
    String  string
    Var     string
    Ref     []*Term
    Array   []*Term
    Object  [][2]*Term
    Set     []*Term
)
```

### 10.2 内存管理

**内存优化策略**：

```text
1. 共享不可变数据
   └── AST节点尽可能共享

2. 对象池
   └── 复用频繁分配的小对象

3. Copy-on-Write
   └── 转换时尽可能避免拷贝

4. 延迟计算
   └── 只在需要时生成IR
```

### 10.3 性能考虑

**关键路径优化**：

```go
// 缓存编译结果
type CompilerCache struct {
    cache sync.Map  // 线程安全
}

func (cc *CompilerCache) GetOrCompile(
    source string,
) (*IR, error) {
    if cached, ok := cc.cache.Load(source); ok {
        return cached.(*IR), nil
    }
    
    ir, err := Compile(source)
    if err != nil {
        return nil, err
    }
    
    cc.cache.Store(source, ir)
    return ir, nil
}
```

---

## 附录A：完整AST示例

**Rego代码**：

```rego
package example

import rego.v1

users := {
    "alice": {"role": "admin"},
    "bob": {"role": "user"}
}

allow if {
    user := users[input.name]
    user.role == "admin"
}
```

**完整AST（JSON，简化）**：

```json
{
  "package": {
    "path": [{"type": "var", "value": "example"}],
    "location": {"row": 1, "col": 1}
  },
  "imports": [
    {
      "path": [
        {"type": "var", "value": "rego"},
        {"type": "string", "value": "v1"}
      ],
      "location": {"row": 3, "col": 1}
    }
  ],
  "rules": [
    {
      "head": {
        "name": "users",
        "value": {
          "type": "object",
          "value": [
            [
              {"type": "string", "value": "alice"},
              {
                "type": "object",
                "value": [
                  [
                    {"type": "string", "value": "role"},
                    {"type": "string", "value": "admin"}
                  ]
                ]
              }
            ],
            [
              {"type": "string", "value": "bob"},
              {
                "type": "object",
                "value": [
                  [
                    {"type": "string", "value": "role"},
                    {"type": "string", "value": "user"}
                  ]
                ]
              }
            ]
          ]
        }
      },
      "location": {"row": 5, "col": 1}
    },
    {
      "head": {"name": "allow"},
      "body": [
        {
          "terms": [
            {"type": "var", "value": "user"},
            {"type": "ref", "value": [
              {"type": "var", "value": "users"},
              {"type": "ref", "value": [
                {"type": "var", "value": "input"},
                {"type": "string", "value": "name"}
              ]}
            ]}
          ],
          "location": {"row": 10, "col": 5}
        },
        {
          "terms": [
            {"type": "ref", "value": [
              {"type": "var", "value": "user"},
              {"type": "string", "value": "role"}
            ]},
            {"type": "string", "value": "admin"}
          ],
          "location": {"row": 11, "col": 5}
        }
      ],
      "location": {"row": 9, "col": 1}
    }
  ]
}
```

---

## 附录B：IR指令参考

**完整指令集（伪代码）**：

```text
# 数据操作
LoadConst    dst, value           # 加载常量
LoadVar      dst, name             # 加载变量
StoreVar     name, src             # 存储变量
Move         dst, src              # 移动数据

# 算术运算
Add          dst, a, b             # dst = a + b
Sub          dst, a, b             # dst = a - b
Mul          dst, a, b             # dst = a * b
Div          dst, a, b             # dst = a / b
Mod          dst, a, b             # dst = a % b
Neg          dst, a                # dst = -a

# 比较运算
Eq           dst, a, b             # dst = (a == b)
Neq          dst, a, b             # dst = (a != b)
Lt           dst, a, b             # dst = (a < b)
Lte          dst, a, b             # dst = (a <= b)
Gt           dst, a, b             # dst = (a > b)
Gte          dst, a, b             # dst = (a >= b)

# 逻辑运算
And          dst, a, b             # dst = a && b
Or           dst, a, b             # dst = a || b
Not          dst, a                # dst = !a

# 控制流
Label        name                  # 标签
Jump         label                 # 无条件跳转
Branch       cond, label           # 条件跳转
BranchNot    cond, label           # 条件跳转（取反）
Call         dst, func, args...    # 函数调用
Return       value                 # 返回

# 数据结构
MakeArray    dst, elements...      # 创建数组
MakeObject   dst, kvpairs...       # 创建对象
MakeSet      dst, elements...      # 创建集合
ArrayGet     dst, array, index     # 数组访问
ObjectGet    dst, object, key      # 对象访问
SetContains  dst, set, element     # 集合包含检查

# 统一
Unify        a, b                  # 统一a和b
Scan         iter, collection      # 创建迭代器
Next         dst, iter             # 迭代下一个
IsExhausted  dst, iter             # 检查迭代器是否耗尽

# 调试
Trace        message               # 输出调试信息
Assert       condition             # 断言
```

---

**相关文档**：

- [词法分析与语法解析](./03.1-词法分析与语法解析.md)
- [编译器设计](./03.3-编译器设计.md)
- [Top-Down求值器](./03.4-Top-Down求值器.md)

**参考资源**：

- OPA源码: <https://github.com/open-policy-agent/opa>
- AST包文档: <https://pkg.go.dev/github.com/open-policy-agent/opa/ast>
- IR设计文档: <https://github.com/open-policy-agent/opa/blob/main/docs/devel/ir.md>
