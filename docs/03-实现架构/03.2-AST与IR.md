# ASTä¸IRï¼ˆAbstract Syntax Tree and Intermediate Representationï¼‰

> **é€‚ç”¨ç‰ˆæœ¬**: OPA v0.42+ (Rego v1 AST) | æ¨è v0.68+  
> **å®ç°è¯­è¨€**: Go 1.20+  
> **æºç **: `github.com/open-policy-agent/opa/ast` & `ir`åŒ…  
> **æœ€åéªŒè¯**: 2025-10-21  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²éªŒè¯  
> **å‚è€ƒ**: <https://github.com/open-policy-agent/opa>

---

## ğŸ”¬ æŠ€æœ¯æ–‡æ¡£è¯´æ˜

> **æœ¬æ–‡æ¡£é€‚åˆ**:
>
> - âœ… OPAæ ¸å¿ƒå¼€å‘è€…å’Œè´¡çŒ®è€…
> - âœ… éœ€è¦æ·±åº¦å®šåˆ¶OPAçš„ä¼ä¸šç”¨æˆ·
> - âœ… ç¼–è¯‘åŸç†å’Œè¯­è¨€è®¾è®¡çˆ±å¥½è€…
> - âš ï¸ é«˜åº¦æŠ€æœ¯æ€§ï¼Œæ™®é€šç”¨æˆ·æ— éœ€æ·±å…¥ç ”ç©¶
>
> **å®è·µä»·å€¼**:
>
> - ç†è§£ASTç»“æ„æœ‰åŠ©äºç¼–å†™ASTæ“ä½œå·¥å…·
> - IRçŸ¥è¯†å¯¹ç†è§£WASMç¼–è¯‘è‡³å…³é‡è¦
> - å¯¹è°ƒè¯•å¤æ‚ç­–ç•¥é—®é¢˜æœ‰å¸®åŠ©
>
> ç›¸å…³: [ç¼–è¯‘å™¨è®¾è®¡](03.3-ç¼–è¯‘å™¨è®¾è®¡.md) | [WASMç¼–è¯‘](../01-æŠ€æœ¯è§„èŒƒ/01.3-WASMç¼–è¯‘è§„èŒƒ.md)

---

## ç›®å½•

- [ASTä¸IRï¼ˆAbstract Syntax Tree and Intermediate Representationï¼‰](#astä¸irabstract-syntax-tree-and-intermediate-representation)
  - [ğŸ”¬ æŠ€æœ¯æ–‡æ¡£è¯´æ˜](#-æŠ€æœ¯æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ç¼–è¯‘æµç¨‹](#11-ç¼–è¯‘æµç¨‹)
    - [1.2 ASTçš„ä½œç”¨](#12-astçš„ä½œç”¨)
    - [1.3 IRçš„ä½œç”¨](#13-irçš„ä½œç”¨)
  - [2. ASTç»“æ„](#2-astç»“æ„)
    - [2.1 èŠ‚ç‚¹ç±»å‹](#21-èŠ‚ç‚¹ç±»å‹)
    - [2.2 ASTè¡¨ç¤º](#22-astè¡¨ç¤º)
    - [2.3 ä½ç½®ä¿¡æ¯](#23-ä½ç½®ä¿¡æ¯)
  - [3. ASTæ„å»º](#3-astæ„å»º)
    - [3.1 è§£æå™¨è¾“å‡º](#31-è§£æå™¨è¾“å‡º)
    - [3.2 ASTéå†](#32-astéå†)
    - [3.3 ASTè½¬æ¢](#33-astè½¬æ¢)
  - [4. ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰](#4-ä¸­é—´è¡¨ç¤ºir)
    - [4.1 IRè®¾è®¡ç›®æ ‡](#41-irè®¾è®¡ç›®æ ‡)
    - [4.2 IRç»“æ„](#42-irç»“æ„)
    - [4.3 IRæŒ‡ä»¤é›†](#43-iræŒ‡ä»¤é›†)
  - [5. ASTåˆ°IRè½¬æ¢](#5-aståˆ°irè½¬æ¢)
    - [5.1 è§„åˆ™è½¬æ¢](#51-è§„åˆ™è½¬æ¢)
    - [5.2 è¡¨è¾¾å¼è½¬æ¢](#52-è¡¨è¾¾å¼è½¬æ¢)
    - [5.3 æ¨å¯¼è½¬æ¢](#53-æ¨å¯¼è½¬æ¢)
  - [6. ç±»å‹æ³¨è§£](#6-ç±»å‹æ³¨è§£)
    - [6.1 ç±»å‹æ¨æ–­](#61-ç±»å‹æ¨æ–­)
    - [6.2 ç±»å‹æ ‡æ³¨](#62-ç±»å‹æ ‡æ³¨)
    - [6.3 ç±»å‹æ£€æŸ¥](#63-ç±»å‹æ£€æŸ¥)
  - [7. ä¼˜åŒ–](#7-ä¼˜åŒ–)
    - [7.1 å¸¸é‡æŠ˜å ](#71-å¸¸é‡æŠ˜å )
    - [7.2 æ­»ä»£ç æ¶ˆé™¤](#72-æ­»ä»£ç æ¶ˆé™¤)
    - [7.3 å†…è”å±•å¼€](#73-å†…è”å±•å¼€)
  - [8. IRæ‰§è¡Œ](#8-iræ‰§è¡Œ)
    - [8.1 è§£é‡Šæ‰§è¡Œ](#81-è§£é‡Šæ‰§è¡Œ)
    - [8.2 JITç¼–è¯‘](#82-jitç¼–è¯‘)
    - [8.3 WASMç”Ÿæˆ](#83-wasmç”Ÿæˆ)
  - [9. è°ƒè¯•æ”¯æŒ](#9-è°ƒè¯•æ”¯æŒ)
    - [9.1 ASTå¯è§†åŒ–](#91-astå¯è§†åŒ–)
    - [9.2 IRè°ƒè¯•](#92-irè°ƒè¯•)
    - [9.3 æºç æ˜ å°„](#93-æºç æ˜ å°„)
  - [10. å®ç°ç»†èŠ‚](#10-å®ç°ç»†èŠ‚)
    - [10.1 Goæ•°æ®ç»“æ„](#101-goæ•°æ®ç»“æ„)
    - [10.2 å†…å­˜ç®¡ç†](#102-å†…å­˜ç®¡ç†)
    - [10.3 æ€§èƒ½è€ƒè™‘](#103-æ€§èƒ½è€ƒè™‘)
  - [é™„å½•Aï¼šå®Œæ•´ASTç¤ºä¾‹](#é™„å½•aå®Œæ•´astç¤ºä¾‹)
  - [é™„å½•Bï¼šIRæŒ‡ä»¤å‚è€ƒ](#é™„å½•biræŒ‡ä»¤å‚è€ƒ)

---

## 1. æ¦‚è¿°

### 1.1 ç¼–è¯‘æµç¨‹

**å®Œæ•´ç¼–è¯‘ç®¡é“**ï¼š

```text
Regoæºç 
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¯æ³•åˆ†æå™¨      â”‚ â†’ Tokenæµ
â”‚  (Lexer)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¯­æ³•åˆ†æå™¨      â”‚ â†’ AST (æŠ½è±¡è¯­æ³•æ ‘)
â”‚  (Parser)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¯­ä¹‰åˆ†æ        â”‚ â†’ ç±»å‹æ³¨è§£AST
â”‚  (Type Checker) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IRç”Ÿæˆ          â”‚ â†’ IR (ä¸­é—´è¡¨ç¤º)
â”‚  (IR Builder)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼˜åŒ–å™¨          â”‚ â†’ ä¼˜åŒ–åIR
â”‚  (Optimizer)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä»£ç ç”Ÿæˆ        â”‚ â†’ å­—èŠ‚ç /WASM/åŸç”Ÿä»£ç 
â”‚  (Code Gen)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ASTçš„ä½œç”¨

**ASTï¼ˆAbstract Syntax Treeï¼‰æ ¸å¿ƒä»·å€¼**ï¼š

```text
1. ç»“æ„åŒ–è¡¨ç¤º
   â”œâ”€â”€ æ¶ˆé™¤è¯­æ³•ç»†èŠ‚ï¼ˆç©ºæ ¼ã€æ³¨é‡Šï¼‰
   â”œâ”€â”€ ä¿ç•™è¯­ä¹‰ç»“æ„
   â””â”€â”€ æ˜“äºç¨‹åºåˆ†æ

2. å·¥å…·åŸºç¡€
   â”œâ”€â”€ ä»£ç æ ¼å¼åŒ– (opa fmt)
   â”œâ”€â”€ é™æ€åˆ†æ (opa check)
   â”œâ”€â”€ ä»£ç ç”Ÿæˆ
   â””â”€â”€ IDEæ”¯æŒ

3. ç¼–è¯‘åŸºç¡€
   â”œâ”€â”€ ç±»å‹æ£€æŸ¥
   â”œâ”€â”€ ä¼˜åŒ–
   â””â”€â”€ IRç”Ÿæˆ
```

### 1.3 IRçš„ä½œç”¨

**IRï¼ˆIntermediate Representationï¼‰æ ¸å¿ƒä»·å€¼**ï¼š

```text
1. å¹³å°æ— å…³
   â”œâ”€â”€ ç»Ÿä¸€çš„æŠ½è±¡å±‚
   â”œâ”€â”€ å¤šåç«¯æ”¯æŒï¼ˆè§£é‡Šå™¨ã€WASMã€JITï¼‰
   â””â”€â”€ ä¾¿äºä¼˜åŒ–

2. ä¼˜åŒ–å‹å¥½
   â”œâ”€â”€ ç®€åŒ–çš„æŒ‡ä»¤é›†
   â”œâ”€â”€ æ˜¾å¼æ§åˆ¶æµ
   â””â”€â”€ æ˜“äºåˆ†æ

3. æ‰§è¡Œé«˜æ•ˆ
   â”œâ”€â”€ æ¥è¿‘æœºå™¨ç 
   â”œâ”€â”€ å‡å°‘è§£é‡Šå¼€é”€
   â””â”€â”€ æ”¯æŒJITç¼–è¯‘
```

---

## 2. ASTç»“æ„

### 2.1 èŠ‚ç‚¹ç±»å‹

**ASTèŠ‚ç‚¹å±‚æ¬¡**ï¼š

```text
Node (æ‰€æœ‰èŠ‚ç‚¹åŸºç±»)
â”‚
â”œâ”€â”€ Statement
â”‚   â”œâ”€â”€ Package
â”‚   â”œâ”€â”€ Import
â”‚   â”œâ”€â”€ Rule
â”‚   â””â”€â”€ Comment
â”‚
â”œâ”€â”€ Term
â”‚   â”œâ”€â”€ Var (å˜é‡)
â”‚   â”œâ”€â”€ Scalar
â”‚   â”‚   â”œâ”€â”€ Null
â”‚   â”‚   â”œâ”€â”€ Boolean
â”‚   â”‚   â”œâ”€â”€ Number
â”‚   â”‚   â””â”€â”€ String
â”‚   â”œâ”€â”€ Array
â”‚   â”œâ”€â”€ Object
â”‚   â”œâ”€â”€ Set
â”‚   â”œâ”€â”€ Ref (å¼•ç”¨)
â”‚   â””â”€â”€ Call (å‡½æ•°è°ƒç”¨)
â”‚
â””â”€â”€ Expr (è¡¨è¾¾å¼)
    â”œâ”€â”€ Equality (=)
    â”œâ”€â”€ Assignment (:=)
    â”œâ”€â”€ Comparison (==, !=, <, >)
    â”œâ”€â”€ Term
    â””â”€â”€ SomeDecl (some)
```

### 2.2 ASTè¡¨ç¤º

**ç¤ºä¾‹Regoä»£ç **ï¼š

```rego
package authz

import rego.v1

default allow := false

allow if {
    input.user.role == "admin"
}
```

**å¯¹åº”ASTï¼ˆç®€åŒ–JSONï¼‰**ï¼š

```json
{
  "type": "Module",
  "package": {
    "type": "Package",
    "path": ["authz"]
  },
  "imports": [
    {
      "type": "Import",
      "path": ["rego", "v1"]
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "default": true,
      "head": {
        "name": "allow",
        "value": {
          "type": "Boolean",
          "value": false
        }
      }
    },
    {
      "type": "Rule",
      "head": {
        "name": "allow"
      },
      "body": [
        {
          "type": "Expr",
          "terms": [
            {
              "type": "Comparison",
              "operator": "==",
              "operands": [
                {
                  "type": "Ref",
                  "value": [
                    {"type": "Var", "value": "input"},
                    {"type": "String", "value": "user"},
                    {"type": "String", "value": "role"}
                  ]
                },
                {
                  "type": "String",
                  "value": "admin"
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

### 2.3 ä½ç½®ä¿¡æ¯

**Locationå…ƒæ•°æ®**ï¼š

```go
type Location struct {
    File string    // æ–‡ä»¶è·¯å¾„
    Row  int       // è¡Œå·ï¼ˆä»1å¼€å§‹ï¼‰
    Col  int       // åˆ—å·ï¼ˆä»1å¼€å§‹ï¼‰
    Text []byte    // æºä»£ç æ–‡æœ¬
}
```

**ç”¨é€”**ï¼š

```text
1. é”™è¯¯æŠ¥å‘Š
   â””â”€â”€ ç²¾ç¡®æŒ‡å‡ºé”™è¯¯ä½ç½®

2. IDEæ”¯æŒ
   â”œâ”€â”€ è·³è½¬åˆ°å®šä¹‰
   â”œâ”€â”€ é‡å‘½å
   â””â”€â”€ ä»£ç è¡¥å…¨

3. è°ƒè¯•
   â”œâ”€â”€ æ–­ç‚¹è®¾ç½®
   â””â”€â”€ å †æ ˆè¿½è¸ª
```

---

## 3. ASTæ„å»º

### 3.1 è§£æå™¨è¾“å‡º

**è§£æè¿‡ç¨‹**ï¼š

```go
// ç®€åŒ–çš„è§£æå™¨æ¥å£
package ast

func ParseModule(filename string, source []byte) (*Module, error) {
    // 1. è¯æ³•åˆ†æ
    lexer := NewLexer(source)
    tokens := lexer.Tokenize()
    
    // 2. è¯­æ³•åˆ†æ
    parser := NewParser(tokens)
    module := parser.ParseModule()
    
    // 3. è®¾ç½®ä½ç½®ä¿¡æ¯
    module.Location = &Location{
        File: filename,
        Row:  1,
        Col:  1,
        Text: source,
    }
    
    return module, nil
}
```

### 3.2 ASTéå†

**Visitoræ¨¡å¼**ï¼š

```go
// ASTè®¿é—®è€…æ¥å£
type Visitor interface {
    Visit(node Node) (w Visitor)
}

// éå†AST
func Walk(v Visitor, node Node) {
    if v = v.Visit(node); v == nil {
        return
    }
    
    switch n := node.(type) {
    case *Module:
        Walk(v, n.Package)
        for _, imp := range n.Imports {
            Walk(v, imp)
        }
        for _, rule := range n.Rules {
            Walk(v, rule)
        }
    case *Rule:
        Walk(v, n.Head)
        for _, expr := range n.Body {
            Walk(v, expr)
        }
    // ... å…¶ä»–èŠ‚ç‚¹ç±»å‹
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```go
// æ”¶é›†æ‰€æœ‰å˜é‡å
type VarCollector struct {
    Vars []string
}

func (vc *VarCollector) Visit(node Node) Visitor {
    if v, ok := node.(*Var); ok {
        vc.Vars = append(vc.Vars, string(v.Value))
    }
    return vc
}

// ä½¿ç”¨
collector := &VarCollector{}
Walk(collector, module)
fmt.Println("å˜é‡:", collector.Vars)
```

### 3.3 ASTè½¬æ¢

**å¸¸è§è½¬æ¢**ï¼š

```go
// 1. å˜é‡é‡å‘½å
type Renamer struct {
    Old string
    New string
}

func (r *Renamer) Visit(node Node) Visitor {
    if v, ok := node.(*Var); ok {
        if string(v.Value) == r.Old {
            v.Value = Var(r.New)
        }
    }
    return r
}

// 2. å¸¸é‡æŠ˜å 
type ConstantFolder struct{}

func (cf *ConstantFolder) Visit(node Node) Visitor {
    if call, ok := node.(*Call); ok {
        // å¦‚æœæ‰€æœ‰å‚æ•°éƒ½æ˜¯å¸¸é‡ï¼Œæ±‚å€¼å‡½æ•°è°ƒç”¨
        if allConstants(call.Args) {
            result := evaluate(call)
            return result
        }
    }
    return cf
}
```

---

## 4. ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰

### 4.1 IRè®¾è®¡ç›®æ ‡

**è®¾è®¡åŸåˆ™**ï¼š

```text
1. ç®€æ´æ€§
   â””â”€â”€ æŒ‡ä»¤é›†å°è€Œç²¾

2. å¯ä¼˜åŒ–æ€§
   â”œâ”€â”€ SSAå½¢å¼ï¼ˆStatic Single Assignmentï¼‰
   â””â”€â”€ æ˜¾å¼æ§åˆ¶æµ

3. å¯ç§»æ¤æ€§
   â””â”€â”€ å¹³å°æ— å…³çš„æŠ½è±¡

4. é«˜æ•ˆæ€§
   â””â”€â”€ æ¥è¿‘æœºå™¨è¡¨ç¤º
```

### 4.2 IRç»“æ„

**IRæ¨¡å—ç»“æ„**ï¼š

```text
IR Module
â”œâ”€â”€ Functions
â”‚   â”œâ”€â”€ Name
â”‚   â”œâ”€â”€ Parameters
â”‚   â”œâ”€â”€ Blocks
â”‚   â”‚   â”œâ”€â”€ Label
â”‚   â”‚   â””â”€â”€ Instructions
â”‚   â””â”€â”€ Return Type
â”‚
â”œâ”€â”€ Data Segments
â”‚   â””â”€â”€ Static Data
â”‚
â””â”€â”€ Metadata
    â”œâ”€â”€ Source Mapping
    â””â”€â”€ Type Information
```

### 4.3 IRæŒ‡ä»¤é›†

**æ ¸å¿ƒæŒ‡ä»¤**ï¼š

```text
æ•°æ®æ“ä½œ:
  - Load     # åŠ è½½å˜é‡/å¸¸é‡
  - Store    # å­˜å‚¨å€¼
  - Move     # ç§»åŠ¨æ•°æ®

ç®—æœ¯è¿ç®—:
  - Add, Sub, Mul, Div, Mod
  - Neg      # å–è´Ÿ

æ¯”è¾ƒè¿ç®—:
  - Eq, Neq, Lt, Lte, Gt, Gte

é€»è¾‘è¿ç®—:
  - And, Or, Not

æ§åˆ¶æµ:
  - Jump     # æ— æ¡ä»¶è·³è½¬
  - Branch   # æ¡ä»¶è·³è½¬
  - Call     # å‡½æ•°è°ƒç”¨
  - Return   # è¿”å›

æ•°æ®ç»“æ„:
  - MakeArray
  - MakeObject
  - MakeSet
  - ArrayIndex
  - ObjectGet
  - SetContains

ç»Ÿä¸€:
  - Unify    # ç»Ÿä¸€ä¸¤ä¸ªå€¼
  - Scan     # éå†é›†åˆ
```

---

## 5. ASTåˆ°IRè½¬æ¢

### 5.1 è§„åˆ™è½¬æ¢

**Regoè§„åˆ™**ï¼š

```rego
allow if {
    input.user.role == "admin"
    input.action in ["read", "write"]
}
```

**IRï¼ˆä¼ªä»£ç ï¼‰**ï¼š

```text
function data.authz.allow():
  block entry:
    %1 = load input
    %2 = get %1["user"]
    %3 = get %2["role"]
    %4 = eq %3, "admin"
    branch %4, check_action, fail
  
  block check_action:
    %5 = load input
    %6 = get %5["action"]
    %7 = make_set ["read", "write"]
    %8 = set_contains %7, %6
    branch %8, success, fail
  
  block success:
    return true
  
  block fail:
    return undefined
```

### 5.2 è¡¨è¾¾å¼è½¬æ¢

**å¤æ‚è¡¨è¾¾å¼**ï¼š

```rego
result := x + y * 2
```

**IR**ï¼š

```text
%1 = load y
%2 = mul %1, 2
%3 = load x
%4 = add %3, %2
store result, %4
```

### 5.3 æ¨å¯¼è½¬æ¢

**æ•°ç»„æ¨å¯¼**ï¼š

```rego
squares := [x * x | some x in [1, 2, 3]]
```

**IRï¼ˆä¼ªä»£ç ï¼‰**ï¼š

```text
%1 = make_array []
%2 = make_array [1, 2, 3]
%iter = scan %2

loop:
  %x = next %iter
  branch_exhausted %iter, done
  %sq = mul %x, %x
  append %1, %sq
  jump loop

done:
  store squares, %1
```

---

## 6. ç±»å‹æ³¨è§£

### 6.1 ç±»å‹æ¨æ–­

**Hindley-Milneré£æ ¼ç±»å‹æ¨æ–­**ï¼š

```text
è§„åˆ™:
1. å­—é¢é‡ç±»å‹æ˜¯ç¡®å®šçš„
   10 : number
   "hello" : string

2. å˜é‡ç±»å‹é€šè¿‡ä½¿ç”¨æ¨æ–­
   x = 10  â†’  x : number

3. å‡½æ•°ç±»å‹é€šè¿‡ç­¾åæ¨æ–­
   count(arr) â†’ arr : array, result : number

4. ç»Ÿä¸€çº¦æŸç±»å‹
   x = y, x : number  â†’  y : number
```

**å®ç°**ï¼š

```go
type TypeInfer struct {
    env map[string]Type  // ç¯å¢ƒ
}

func (ti *TypeInfer) Infer(node Node) Type {
    switch n := node.(type) {
    case *Number:
        return TypeNumber
    case *String:
        return TypeString
    case *Var:
        return ti.env[n.Value]
    case *Call:
        // æ ¹æ®å‡½æ•°ç­¾åæ¨æ–­
        return ti.inferCall(n)
    }
}
```

### 6.2 ç±»å‹æ ‡æ³¨

**ASTä¸­çš„ç±»å‹ä¿¡æ¯**ï¼š

```go
type Expr struct {
    // ... å…¶ä»–å­—æ®µ
    
    // ç±»å‹æ³¨è§£
    TypeAnnotation Type
}

type Type interface {
    String() string
}

type SimpleType string

const (
    TypeNumber  SimpleType = "number"
    TypeString  SimpleType = "string"
    TypeBoolean SimpleType = "boolean"
    TypeNull    SimpleType = "null"
    TypeAny     SimpleType = "any"
)

type ArrayType struct {
    ElementType Type
}

type ObjectType struct {
    KeyType   Type
    ValueType Type
}
```

### 6.3 ç±»å‹æ£€æŸ¥

**ç±»å‹æ£€æŸ¥å™¨**ï¼š

```go
type TypeChecker struct {
    errors []error
}

func (tc *TypeChecker) Check(module *Module) error {
    for _, rule := range module.Rules {
        tc.checkRule(rule)
    }
    if len(tc.errors) > 0 {
        return fmt.Errorf("ç±»å‹é”™è¯¯: %v", tc.errors)
    }
    return nil
}

func (tc *TypeChecker) checkRule(rule *Rule) {
    // æ£€æŸ¥è§„åˆ™å¤´ç±»å‹
    headType := tc.inferType(rule.Head.Value)
    
    // æ£€æŸ¥è§„åˆ™ä½“
    for _, expr := range rule.Body {
        exprType := tc.inferType(expr)
        if exprType != TypeBoolean {
            tc.errors = append(tc.errors, 
                fmt.Errorf("è¡¨è¾¾å¼å¿…é¡»è¿”å›å¸ƒå°”å€¼"))
        }
    }
}
```

---

## 7. ä¼˜åŒ–

### 7.1 å¸¸é‡æŠ˜å 

**ä¼˜åŒ–å‰**ï¼š

```rego
x := 1 + 2 * 3
```

**IRï¼ˆä¼˜åŒ–å‰ï¼‰**ï¼š

```text
%1 = load 2
%2 = load 3
%3 = mul %1, %2
%4 = load 1
%5 = add %4, %3
store x, %5
```

**IRï¼ˆä¼˜åŒ–åï¼‰**ï¼š

```text
store x, 7
```

**å®ç°**ï¼š

```go
func ConstantFold(instr Instruction) Instruction {
    switch i := instr.(type) {
    case *Add:
        if IsConst(i.Left) && IsConst(i.Right) {
            return &Const{
                Value: i.Left.Value() + i.Right.Value(),
            }
        }
    case *Mul:
        if IsConst(i.Left) && IsConst(i.Right) {
            return &Const{
                Value: i.Left.Value() * i.Right.Value(),
            }
        }
    }
    return instr
}
```

### 7.2 æ­»ä»£ç æ¶ˆé™¤

**ä¼˜åŒ–å‰**ï¼š

```rego
allow if {
    true
    false  # æ°¸è¿œå¤±è´¥ï¼Œåç»­ä»£ç æ— æ•ˆ
    input.user == "admin"
}
```

**IRï¼ˆä¼˜åŒ–åï¼‰**ï¼š

```text
function allow():
  return undefined  # ç›´æ¥è¿”å›å¤±è´¥
```

### 7.3 å†…è”å±•å¼€

**ä¼˜åŒ–å‰**ï¼š

```rego
is_admin if {
    input.user.role == "admin"
}

allow if {
    is_admin
}
```

**ä¼˜åŒ–åï¼ˆå†…è”ï¼‰**ï¼š

```rego
allow if {
    input.user.role == "admin"
}
```

---

## 8. IRæ‰§è¡Œ

### 8.1 è§£é‡Šæ‰§è¡Œ

**IRè§£é‡Šå™¨**ï¼š

```go
type Interpreter struct {
    stack []Value
    env   map[string]Value
}

func (interp *Interpreter) Execute(ir *IR) (Value, error) {
    for _, instr := range ir.Instructions {
        if err := interp.executeInstruction(instr); err != nil {
            return nil, err
        }
    }
    return interp.stack[len(interp.stack)-1], nil
}

func (interp *Interpreter) executeInstruction(instr Instruction) error {
    switch i := instr.(type) {
    case *Load:
        val := interp.env[i.Name]
        interp.stack = append(interp.stack, val)
    case *Add:
        b := interp.pop()
        a := interp.pop()
        interp.push(a + b)
    case *Call:
        args := interp.popN(i.ArgCount)
        result := i.Function(args...)
        interp.push(result)
    }
    return nil
}
```

### 8.2 JITç¼–è¯‘

**åŠ¨æ€ç¼–è¯‘ï¼ˆæ¦‚å¿µï¼‰**ï¼š

```text
JIT Compilation Pipeline:
1. è¯†åˆ«çƒ­ç‚¹ä»£ç ï¼ˆé¢‘ç¹æ‰§è¡Œçš„IRï¼‰
2. ç¼–è¯‘ä¸ºæœ¬åœ°æœºå™¨ç 
3. ç¼“å­˜ç¼–è¯‘ç»“æœ
4. åç»­æ‰§è¡Œç›´æ¥ä½¿ç”¨æœºå™¨ç 

ä¼˜åŠ¿:
- æ¶ˆé™¤è§£é‡Šå¼€é”€
- æ¥è¿‘C/C++æ€§èƒ½
- è¿è¡Œæ—¶ä¼˜åŒ–
```

### 8.3 WASMç”Ÿæˆ

**IRåˆ°WASMè½¬æ¢**ï¼š

```text
IR Instruction      â†’ WASM Instruction
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Load var            â†’ local.get $var
Store var, val      â†’ local.set $var
Add a, b            â†’ i32.add
Mul a, b            â†’ i32.mul
Call func           â†’ call $func
Branch cond, label  â†’ br_if $label
Return val          â†’ return
```

---

## 9. è°ƒè¯•æ”¯æŒ

### 9.1 ASTå¯è§†åŒ–

**opa parseå‘½ä»¤**ï¼š

```bash
# è§£æå¹¶è¾“å‡ºASTï¼ˆJSONæ ¼å¼ï¼‰
opa parse policy.rego --format json

# ç¾åŒ–è¾“å‡º
opa parse policy.rego --format json | jq .
```

**è¾“å‡ºç¤ºä¾‹**ï¼š

```json
{
  "package": {
    "path": [{"type": "var", "value": "authz"}]
  },
  "rules": [
    {
      "head": {"name": "allow"},
      "body": [
        {
          "terms": [
            {"type": "ref", "value": [
              {"type": "var", "value": "input"},
              {"type": "string", "value": "user"}
            ]},
            {"type": "string", "value": "admin"}
          ]
        }
      ]
    }
  ]
}
```

### 9.2 IRè°ƒè¯•

**æ‰“å°IR**ï¼š

```bash
# ç¼–è¯‘å¹¶è¾“å‡ºIR
opa build policy.rego --debug
```

### 9.3 æºç æ˜ å°„

**Source Mapç»“æ„**ï¼š

```json
{
  "version": 3,
  "sources": ["policy.rego"],
  "mappings": [
    {
      "ir_offset": 0,
      "source_file": "policy.rego",
      "source_line": 5,
      "source_column": 1
    }
  ]
}
```

**ç”¨é€”**ï¼š

- é”™è¯¯å †æ ˆæ˜ å°„å›æºä»£ç 
- è°ƒè¯•å™¨æ–­ç‚¹è®¾ç½®
- æ€§èƒ½åˆ†æ

---

## 10. å®ç°ç»†èŠ‚

### 10.1 Goæ•°æ®ç»“æ„

**æ ¸å¿ƒASTç»“æ„**ï¼š

```go
// github.com/open-policy-agent/opa/ast/ast.go

type Module struct {
    Package  *Package
    Imports  []*Import
    Rules    []*Rule
    Comments []*Comment
}

type Rule struct {
    Default  bool
    Head     *Head
    Body     Body
    Else     *Rule
    Location *Location
}

type Term struct {
    Value    Value
    Location *Location
}

type Value interface {
    Compare(other Value) int
    IsGround() bool
    String() string
}

// å…·ä½“Valueç±»å‹
type (
    Null    string
    Boolean bool
    Number  json.Number
    String  string
    Var     string
    Ref     []*Term
    Array   []*Term
    Object  [][2]*Term
    Set     []*Term
)
```

### 10.2 å†…å­˜ç®¡ç†

**å†…å­˜ä¼˜åŒ–ç­–ç•¥**ï¼š

```text
1. å…±äº«ä¸å¯å˜æ•°æ®
   â””â”€â”€ ASTèŠ‚ç‚¹å°½å¯èƒ½å…±äº«

2. å¯¹è±¡æ± 
   â””â”€â”€ å¤ç”¨é¢‘ç¹åˆ†é…çš„å°å¯¹è±¡

3. Copy-on-Write
   â””â”€â”€ è½¬æ¢æ—¶å°½å¯èƒ½é¿å…æ‹·è´

4. å»¶è¿Ÿè®¡ç®—
   â””â”€â”€ åªåœ¨éœ€è¦æ—¶ç”ŸæˆIR
```

### 10.3 æ€§èƒ½è€ƒè™‘

**å…³é”®è·¯å¾„ä¼˜åŒ–**ï¼š

```go
// ç¼“å­˜ç¼–è¯‘ç»“æœ
type CompilerCache struct {
    cache sync.Map  // çº¿ç¨‹å®‰å…¨
}

func (cc *CompilerCache) GetOrCompile(
    source string,
) (*IR, error) {
    if cached, ok := cc.cache.Load(source); ok {
        return cached.(*IR), nil
    }
    
    ir, err := Compile(source)
    if err != nil {
        return nil, err
    }
    
    cc.cache.Store(source, ir)
    return ir, nil
}
```

---

## é™„å½•Aï¼šå®Œæ•´ASTç¤ºä¾‹

**Regoä»£ç **ï¼š

```rego
package example

import rego.v1

users := {
    "alice": {"role": "admin"},
    "bob": {"role": "user"}
}

allow if {
    user := users[input.name]
    user.role == "admin"
}
```

**å®Œæ•´ASTï¼ˆJSONï¼Œç®€åŒ–ï¼‰**ï¼š

```json
{
  "package": {
    "path": [{"type": "var", "value": "example"}],
    "location": {"row": 1, "col": 1}
  },
  "imports": [
    {
      "path": [
        {"type": "var", "value": "rego"},
        {"type": "string", "value": "v1"}
      ],
      "location": {"row": 3, "col": 1}
    }
  ],
  "rules": [
    {
      "head": {
        "name": "users",
        "value": {
          "type": "object",
          "value": [
            [
              {"type": "string", "value": "alice"},
              {
                "type": "object",
                "value": [
                  [
                    {"type": "string", "value": "role"},
                    {"type": "string", "value": "admin"}
                  ]
                ]
              }
            ],
            [
              {"type": "string", "value": "bob"},
              {
                "type": "object",
                "value": [
                  [
                    {"type": "string", "value": "role"},
                    {"type": "string", "value": "user"}
                  ]
                ]
              }
            ]
          ]
        }
      },
      "location": {"row": 5, "col": 1}
    },
    {
      "head": {"name": "allow"},
      "body": [
        {
          "terms": [
            {"type": "var", "value": "user"},
            {"type": "ref", "value": [
              {"type": "var", "value": "users"},
              {"type": "ref", "value": [
                {"type": "var", "value": "input"},
                {"type": "string", "value": "name"}
              ]}
            ]}
          ],
          "location": {"row": 10, "col": 5}
        },
        {
          "terms": [
            {"type": "ref", "value": [
              {"type": "var", "value": "user"},
              {"type": "string", "value": "role"}
            ]},
            {"type": "string", "value": "admin"}
          ],
          "location": {"row": 11, "col": 5}
        }
      ],
      "location": {"row": 9, "col": 1}
    }
  ]
}
```

---

## é™„å½•Bï¼šIRæŒ‡ä»¤å‚è€ƒ

**å®Œæ•´æŒ‡ä»¤é›†ï¼ˆä¼ªä»£ç ï¼‰**ï¼š

```text
# æ•°æ®æ“ä½œ
LoadConst    dst, value           # åŠ è½½å¸¸é‡
LoadVar      dst, name             # åŠ è½½å˜é‡
StoreVar     name, src             # å­˜å‚¨å˜é‡
Move         dst, src              # ç§»åŠ¨æ•°æ®

# ç®—æœ¯è¿ç®—
Add          dst, a, b             # dst = a + b
Sub          dst, a, b             # dst = a - b
Mul          dst, a, b             # dst = a * b
Div          dst, a, b             # dst = a / b
Mod          dst, a, b             # dst = a % b
Neg          dst, a                # dst = -a

# æ¯”è¾ƒè¿ç®—
Eq           dst, a, b             # dst = (a == b)
Neq          dst, a, b             # dst = (a != b)
Lt           dst, a, b             # dst = (a < b)
Lte          dst, a, b             # dst = (a <= b)
Gt           dst, a, b             # dst = (a > b)
Gte          dst, a, b             # dst = (a >= b)

# é€»è¾‘è¿ç®—
And          dst, a, b             # dst = a && b
Or           dst, a, b             # dst = a || b
Not          dst, a                # dst = !a

# æ§åˆ¶æµ
Label        name                  # æ ‡ç­¾
Jump         label                 # æ— æ¡ä»¶è·³è½¬
Branch       cond, label           # æ¡ä»¶è·³è½¬
BranchNot    cond, label           # æ¡ä»¶è·³è½¬ï¼ˆå–åï¼‰
Call         dst, func, args...    # å‡½æ•°è°ƒç”¨
Return       value                 # è¿”å›

# æ•°æ®ç»“æ„
MakeArray    dst, elements...      # åˆ›å»ºæ•°ç»„
MakeObject   dst, kvpairs...       # åˆ›å»ºå¯¹è±¡
MakeSet      dst, elements...      # åˆ›å»ºé›†åˆ
ArrayGet     dst, array, index     # æ•°ç»„è®¿é—®
ObjectGet    dst, object, key      # å¯¹è±¡è®¿é—®
SetContains  dst, set, element     # é›†åˆåŒ…å«æ£€æŸ¥

# ç»Ÿä¸€
Unify        a, b                  # ç»Ÿä¸€aå’Œb
Scan         iter, collection      # åˆ›å»ºè¿­ä»£å™¨
Next         dst, iter             # è¿­ä»£ä¸‹ä¸€ä¸ª
IsExhausted  dst, iter             # æ£€æŸ¥è¿­ä»£å™¨æ˜¯å¦è€—å°½

# è°ƒè¯•
Trace        message               # è¾“å‡ºè°ƒè¯•ä¿¡æ¯
Assert       condition             # æ–­è¨€
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [è¯æ³•åˆ†æä¸è¯­æ³•è§£æ](./03.1-è¯æ³•åˆ†æä¸è¯­æ³•è§£æ.md)
- [ç¼–è¯‘å™¨è®¾è®¡](./03.3-ç¼–è¯‘å™¨è®¾è®¡.md)
- [Top-Downæ±‚å€¼å™¨](./03.4-Top-Downæ±‚å€¼å™¨.md)

**å‚è€ƒèµ„æº**ï¼š

- OPAæºç : <https://github.com/open-policy-agent/opa>
- ASTåŒ…æ–‡æ¡£: <https://pkg.go.dev/github.com/open-policy-agent/opa/ast>
- IRè®¾è®¡æ–‡æ¡£: <https://github.com/open-policy-agent/opa/blob/main/docs/devel/ir.md>
