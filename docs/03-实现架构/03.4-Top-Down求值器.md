# Top-Down æ±‚å€¼å™¨ï¼ˆTop-Down Evaluatorï¼‰

> **é€‚ç”¨ç‰ˆæœ¬**: OPA v0.55+  
> **å®ç°è¯­è¨€**: Go 1.20+  
> **æ ¸å¿ƒç®—æ³•**: SLD-Resolution + Backtracking  
> **æœ€åéªŒè¯**: 2025-10-21  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²éªŒè¯

---

## ğŸ“– é˜…è¯»æç¤º

> **æœ¬æ–‡æ¡£å†…å®¹**:
> 
> - âœ… æ·±å…¥ç†è§£OPAå†…éƒ¨å·¥ä½œåŸç†
> - âœ… é€‚åˆå¯¹ç¼–è¯‘åŸç†ã€é€»è¾‘ç¼–ç¨‹æœ‰åŸºç¡€çš„è¯»è€…
> - âœ… å¸®åŠ©ä¼˜åŒ–ç­–ç•¥æ€§èƒ½å’Œè°ƒè¯•å¤æ‚é—®é¢˜
> - âš ï¸ ç†è®ºæ€§è¾ƒå¼ºï¼Œåˆå­¦è€…å¯å…ˆå­¦ä¹ [Regoè¯­æ³•](../02-è¯­è¨€æ¨¡å‹/02.1-Regoè¯­æ³•è§„èŒƒ.md)
> 
> **æ€§èƒ½ç›¸å…³**:
> - ç†è§£æ±‚å€¼è¿‡ç¨‹æœ‰åŠ©äºç¼–å†™é«˜æ€§èƒ½ç­–ç•¥
> - é¿å…å¯¼è‡´å¤§é‡å›æº¯çš„è§„åˆ™æ¨¡å¼
> - åˆç†ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–
> 
> å®è·µåº”ç”¨: [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../08-æœ€ä½³å®è·µ/08.2-æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md) | [éƒ¨åˆ†æ±‚å€¼æŠ€æœ¯](03.6-éƒ¨åˆ†æ±‚å€¼æŠ€æœ¯.md)

---

## ç›®å½•

- [Top-Down æ±‚å€¼å™¨ï¼ˆTop-Down Evaluatorï¼‰](#top-down-æ±‚å€¼å™¨top-down-evaluator)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ±‚å€¼å™¨æ¦‚è¿°](#1-æ±‚å€¼å™¨æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯Top-Downæ±‚å€¼](#11-ä»€ä¹ˆæ˜¯top-downæ±‚å€¼)
    - [1.2 ç®—æ³•åŸºç¡€](#12-ç®—æ³•åŸºç¡€)
    - [1.3 æ±‚å€¼å™¨æ¶æ„](#13-æ±‚å€¼å™¨æ¶æ„)
  - [2. æ ¸å¿ƒç®—æ³•](#2-æ ¸å¿ƒç®—æ³•)
    - [2.1 ä¸»æ±‚å€¼å¾ªç¯](#21-ä¸»æ±‚å€¼å¾ªç¯)
    - [2.2 ç»Ÿä¸€ç®—æ³•ï¼ˆUnificationï¼‰](#22-ç»Ÿä¸€ç®—æ³•unification)
    - [2.3 å›æº¯æœºåˆ¶ï¼ˆBacktrackingï¼‰](#23-å›æº¯æœºåˆ¶backtracking)
  - [3. æ±‚å€¼è¿‡ç¨‹](#3-æ±‚å€¼è¿‡ç¨‹)
    - [3.1 å®Œæ•´ç¤ºä¾‹](#31-å®Œæ•´ç¤ºä¾‹)
    - [3.2 æ±‚å€¼æ­¥éª¤](#32-æ±‚å€¼æ­¥éª¤)
    - [3.3 æ‰§è¡Œè·Ÿè¸ªï¼ˆTraceï¼‰](#33-æ‰§è¡Œè·Ÿè¸ªtrace)
  - [4. ä¼˜åŒ–æŠ€æœ¯](#4-ä¼˜åŒ–æŠ€æœ¯)
    - [4.1 ç´¢å¼•ï¼ˆIndexingï¼‰](#41-ç´¢å¼•indexing)
    - [4.2 çŸ­è·¯æ±‚å€¼ï¼ˆShort-Circuitï¼‰](#42-çŸ­è·¯æ±‚å€¼short-circuit)
    - [4.3 å°¾è°ƒç”¨ä¼˜åŒ–ï¼ˆTail Call Optimizationï¼‰](#43-å°¾è°ƒç”¨ä¼˜åŒ–tail-call-optimization)
    - [4.4 ç¼“å­˜ï¼ˆCachingï¼‰](#44-ç¼“å­˜caching)
  - [5. å®ç°ç»†èŠ‚](#5-å®ç°ç»†èŠ‚)
    - [5.1 Goå®ç°ï¼ˆç®€åŒ–ï¼‰](#51-goå®ç°ç®€åŒ–)
    - [5.2 æ•°æ®ç»“æ„](#52-æ•°æ®ç»“æ„)
  - [6. æ€§èƒ½åˆ†æ](#6-æ€§èƒ½åˆ†æ)
    - [6.1 æ—¶é—´å¤æ‚åº¦](#61-æ—¶é—´å¤æ‚åº¦)
    - [6.2 ç©ºé—´å¤æ‚åº¦](#62-ç©ºé—´å¤æ‚åº¦)
    - [6.3 åŸºå‡†æµ‹è¯•](#63-åŸºå‡†æµ‹è¯•)
  - [é™„å½•: è°ƒè¯•æŠ€å·§](#é™„å½•-è°ƒè¯•æŠ€å·§)
    - [A.1 å¯ç”¨è¯¦ç»†æ—¥å¿—](#a1-å¯ç”¨è¯¦ç»†æ—¥å¿—)
    - [A.2 ä½¿ç”¨REPL](#a2-ä½¿ç”¨repl)
    - [A.3 æ€§èƒ½åˆ†æ](#a3-æ€§èƒ½åˆ†æ)

---

## 1. æ±‚å€¼å™¨æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯Top-Downæ±‚å€¼

**å®šä¹‰**: ä»æŸ¥è¯¢ç›®æ ‡å¼€å§‹ï¼Œé€’å½’åœ°åˆ†è§£æˆå­ç›®æ ‡ï¼Œç›´åˆ°æ‰€æœ‰ç›®æ ‡éƒ½è¢«æ»¡è¶³æˆ–å¤±è´¥ã€‚

**å¯¹æ¯”Bottom-Up**:

| ç»´åº¦ | Top-Down | Bottom-Up |
|------|----------|-----------|
| **èµ·ç‚¹** | æŸ¥è¯¢ç›®æ ‡ | åŸºç¡€äº‹å® |
| **æ–¹å‘** | ç›®æ ‡â†’äº‹å® | äº‹å®â†’ç›®æ ‡ |
| **é€‚ç”¨** | ç›®æ ‡å¯¼å‘æŸ¥è¯¢ | å…¨é‡æ¨å¯¼ |
| **ç©ºé—´** | ä½ï¼ˆæŒ‰éœ€è®¡ç®—ï¼‰ | é«˜ï¼ˆé¢„è®¡ç®—æ‰€æœ‰ï¼‰ |
| **OPAé€‰æ‹©** | âœ… | âŒ |

**ä¸ºä»€ä¹ˆé€‰æ‹©Top-Down**:

1. **æŒ‰éœ€æ±‚å€¼**: åªè®¡ç®—æŸ¥è¯¢ç›¸å…³çš„è§„åˆ™
2. **å»¶è¿Ÿä½**: é¿å…ä¸å¿…è¦çš„è®¡ç®—
3. **å†…å­˜å‹å¥½**: ä¸éœ€è¦å­˜å‚¨æ‰€æœ‰ä¸­é—´ç»“æœ
4. **é€‚åˆäº‘åŸç”Ÿ**: è¯·æ±‚é©±åŠ¨ã€æ— çŠ¶æ€

---

### 1.2 ç®—æ³•åŸºç¡€

**ç†è®ºåŸºç¡€**: SLD-Resolutionï¼ˆSelective Linear Definite clause resolutionï¼‰

**åŸç†**:

```text
ç›®æ ‡: G
è§„åˆ™: H :- Bâ‚, Bâ‚‚, ..., Bâ‚™

å¦‚æœ G ä¸ H ç»Ÿä¸€ï¼ˆunifyï¼‰ï¼Œåˆ™:
  æ–°ç›®æ ‡ = Bâ‚, Bâ‚‚, ..., Bâ‚™, Gçš„å‰©ä½™éƒ¨åˆ†
```

**ç¤ºä¾‹**:

```rego
# è§„åˆ™
allow if {
    input.method == "GET"
    is_admin
}

is_admin if {
    input.user.role == "admin"
}
```

**æ±‚å€¼è¿‡ç¨‹**:

```text
ç›®æ ‡: allow
  â†’ åŒ¹é…è§„åˆ™: allow :- input.method == "GET", is_admin
  â†’ å­ç›®æ ‡1: input.method == "GET" âœ“
  â†’ å­ç›®æ ‡2: is_admin
    â†’ åŒ¹é…è§„åˆ™: is_admin :- input.user.role == "admin"
    â†’ å­ç›®æ ‡2.1: input.user.role == "admin" âœ“
  â†’ æˆåŠŸ: allow = true
```

---

### 1.3 æ±‚å€¼å™¨æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Query Interface                â”‚
â”‚   (input + query path)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Query Planner (æŸ¥è¯¢è§„åˆ’)            â”‚
â”‚  â€¢ è·¯å¾„è§£æ                              â”‚
â”‚  â€¢ è§„åˆ™æŸ¥æ‰¾                              â”‚
â”‚  â€¢ ç´¢å¼•é€‰æ‹©                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Evaluation Engine (æ±‚å€¼å¼•æ“)         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  1. Unification (ç»Ÿä¸€)           â”‚   â”‚
â”‚  â”‚  2. Indexing (ç´¢å¼•æŸ¥æ‰¾)          â”‚   â”‚
â”‚  â”‚  3. Backtracking (å›æº¯)          â”‚   â”‚
â”‚  â”‚  4. Caching (ç¼“å­˜)               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Result Builder (ç»“æœæ„å»º)           â”‚
â”‚  â€¢ ç»‘å®šæ”¶é›†                              â”‚
â”‚  â€¢ ç»“æœæ ¼å¼åŒ–                            â”‚
â”‚  â€¢ é”™è¯¯å¤„ç†                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¸å¿ƒç®—æ³•

### 2.1 ä¸»æ±‚å€¼å¾ªç¯

**ä¼ªä»£ç **:

```python
def evaluate(goal, bindings, store):
    """
    goal: å½“å‰ç›®æ ‡ï¼ˆè¡¨è¾¾å¼åˆ—è¡¨ï¼‰
    bindings: å½“å‰å˜é‡ç»‘å®š
    store: æ•°æ®å­˜å‚¨
    è¿”å›: æ‰€æœ‰æ»¡è¶³ç›®æ ‡çš„ç»‘å®šé›†åˆ
    """
    if goal.is_empty():
        # æ‰€æœ‰å­ç›®æ ‡å·²æ»¡è¶³
        return {bindings}
    
    # é€‰æ‹©ç¬¬ä¸€ä¸ªå­ç›®æ ‡
    current, rest = goal.split_first()
    results = set()
    
    # å°è¯•æ‰€æœ‰å¯èƒ½çš„æ–¹å¼æ»¡è¶³å½“å‰å­ç›®æ ‡
    for new_bindings in satisfy(current, bindings, store):
        # é€’å½’æ±‚å€¼å‰©ä½™ç›®æ ‡
        for final_bindings in evaluate(rest, new_bindings, store):
            results.add(final_bindings)
    
    return results


def satisfy(expr, bindings, store):
    """æ»¡è¶³å•ä¸ªè¡¨è¾¾å¼"""
    if expr.is_unification():  # x = y
        theta = unify(expr.left, expr.right, bindings)
        if theta is not None:
            yield bindings.extend(theta)
    
    elif expr.is_comparison():  # x == y
        v1 = evaluate_term(expr.left, bindings)
        v2 = evaluate_term(expr.right, bindings)
        if compare(v1, v2, expr.operator):
            yield bindings
    
    elif expr.is_call():  # f(x, y)
        # æŸ¥æ‰¾è§„åˆ™å®šä¹‰
        for rule in find_rules(expr.name, store):
            # ç»Ÿä¸€å‚æ•°
            theta = unify_args(expr.args, rule.params, bindings)
            if theta is not None:
                # æ±‚å€¼è§„åˆ™ä½“
                for body_bindings in evaluate(rule.body, theta, store):
                    yield body_bindings
    
    elif expr.is_negation():  # not p
        # å¦å®šå³å¤±è´¥ï¼ˆNegation as Failureï¼‰
        if not any(evaluate([expr.inner], bindings, store)):
            yield bindings
```

---

### 2.2 ç»Ÿä¸€ç®—æ³•ï¼ˆUnificationï¼‰

**Robinsonç»Ÿä¸€ç®—æ³•**ï¼ˆ1965ï¼‰:

```python
def unify(term1, term2, bindings):
    """
    è¿”å›ä½¿ term1 å’Œ term2 ç›¸ç­‰çš„ç»‘å®šï¼Œå¤±è´¥åˆ™è¿”å› None
    """
    # åº”ç”¨å½“å‰ç»‘å®š
    t1 = deref(term1, bindings)
    t2 = deref(term2, bindings)
    
    # æƒ…å†µ1: ç›¸åŒå€¼
    if t1 == t2:
        return {}
    
    # æƒ…å†µ2: t1æ˜¯å˜é‡
    if is_var(t1):
        if occurs_check(t1, t2, bindings):
            return None  # å¾ªç¯å¼•ç”¨
        return {t1: t2}
    
    # æƒ…å†µ3: t2æ˜¯å˜é‡
    if is_var(t2):
        if occurs_check(t2, t1, bindings):
            return None
        return {t2: t1}
    
    # æƒ…å†µ4: å¤åˆç±»å‹
    if is_array(t1) and is_array(t2):
        if len(t1) != len(t2):
            return None
        result = {}
        for i in range(len(t1)):
            theta = unify(t1[i], t2[i], bindings.extend(result))
            if theta is None:
                return None
            result.update(theta)
        return result
    
    if is_object(t1) and is_object(t2):
        if set(t1.keys()) != set(t2.keys()):
            return None
        result = {}
        for key in t1.keys():
            theta = unify(t1[key], t2[key], bindings.extend(result))
            if theta is None:
                return None
            result.update(theta)
        return result
    
    # å¤±è´¥
    return None


def deref(term, bindings):
    """è§£å¼•ç”¨å˜é‡"""
    while is_var(term) and term in bindings:
        term = bindings[term]
    return term


def occurs_check(var, term, bindings):
    """æ£€æŸ¥varæ˜¯å¦å‡ºç°åœ¨termä¸­ï¼ˆé˜²æ­¢æ— é™å¾ªç¯ï¼‰"""
    term = deref(term, bindings)
    if var == term:
        return True
    if is_compound(term):
        return any(occurs_check(var, sub, bindings) for sub in term)
    return False
```

---

### 2.3 å›æº¯æœºåˆ¶ï¼ˆBacktrackingï¼‰

**å®ç°æ–¹å¼**: ä½¿ç”¨ç”Ÿæˆå™¨ï¼ˆGeneratorï¼‰å®ç°è‡ªåŠ¨å›æº¯ã€‚

**ç¤ºä¾‹**:

```python
def evaluate_disjunction(rules, bindings, store):
    """æ±‚å€¼å¤šä¸ªè§„åˆ™ï¼ˆORè¯­ä¹‰ï¼‰"""
    for rule in rules:
        # å°è¯•æ¯ä¸ªè§„åˆ™
        for result in evaluate(rule.body, bindings, store):
            yield result  # æˆåŠŸåˆ™yield
            # å¦‚æœè°ƒç”¨è€…éœ€è¦æ›´å¤šç»“æœï¼Œä¼šç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªè§„åˆ™
```

**è°ƒç”¨æ ˆç¤ºä¾‹**:

```text
ç›®æ ‡: allow
  å°è¯•è§„åˆ™1: allow :- is_admin
    å°è¯•is_adminè§„åˆ™1: is_admin :- role == "admin" [å¤±è´¥]
    å›æº¯...
    å°è¯•is_adminè§„åˆ™2: is_admin :- role == "superuser" [æˆåŠŸ] âœ“
  è¿”å›æˆåŠŸ

å¦‚æœè°ƒç”¨è€…éœ€è¦æ‰€æœ‰è§£:
  ç»§ç»­...
  å°è¯•è§„åˆ™2: allow :- is_public [æˆåŠŸ] âœ“
  è¿”å›æˆåŠŸ
```

---

## 3. æ±‚å€¼è¿‡ç¨‹

### 3.1 å®Œæ•´ç¤ºä¾‹

**ç­–ç•¥**:

```rego
package example

import future.keywords.if

allow if {
    input.method == "GET"
    some user in data.users
    user.id == input.user_id
    "read" in user.permissions
}
```

**è¾“å…¥**:

```json
{
    "method": "GET",
    "user_id": "alice"
}
```

**æ•°æ®**:

```json
{
    "users": [
        {"id": "alice", "permissions": ["read", "write"]},
        {"id": "bob", "permissions": ["read"]}
    ]
}
```

---

### 3.2 æ±‚å€¼æ­¥éª¤

**æ­¥éª¤1: æŸ¥æ‰¾è§„åˆ™**:

```text
æŸ¥è¯¢: data.example.allow
æ‰¾åˆ°è§„åˆ™: allow :- body
```

**æ­¥éª¤2: æ±‚å€¼è§„åˆ™ä½“**:

```text
ç›®æ ‡é˜Ÿåˆ—: [
    input.method == "GET",
    some user in data.users,
    user.id == input.user_id,
    "read" in user.permissions
]
ç»‘å®š: {}
```

**æ­¥éª¤3: è¡¨è¾¾å¼1**:

```text
è¡¨è¾¾å¼: input.method == "GET"
æ±‚å€¼:
    å·¦ä¾§: input.method â†’ "GET"
    å³ä¾§: "GET"
    æ¯”è¾ƒ: "GET" == "GET" â†’ true âœ“
ç»‘å®š: {}
```

**æ­¥éª¤4: è¡¨è¾¾å¼2**:

```text
è¡¨è¾¾å¼: some user in data.users
æ±‚å€¼:
    éå†: data.users = [user1, user2]
    è¿­ä»£1: user = user1 {"id": "alice", ...}
```

**æ­¥éª¤5: è¡¨è¾¾å¼3**:

```text
è¡¨è¾¾å¼: user.id == input.user_id
æ±‚å€¼:
    å·¦ä¾§: user.id â†’ "alice"
    å³ä¾§: input.user_id â†’ "alice"
    æ¯”è¾ƒ: "alice" == "alice" â†’ true âœ“
ç»‘å®š: {user: {"id": "alice", "permissions": ["read", "write"]}}
```

**æ­¥éª¤6: è¡¨è¾¾å¼4**:

```text
è¡¨è¾¾å¼: "read" in user.permissions
æ±‚å€¼:
    user.permissions â†’ ["read", "write"]
    æˆå‘˜æ£€æŸ¥: "read" in ["read", "write"] â†’ true âœ“
ç»‘å®š: {user: {"id": "alice", ...}}
```

**æ­¥éª¤7: è§„åˆ™æˆåŠŸ**:

```text
æ‰€æœ‰è¡¨è¾¾å¼æ»¡è¶³
è¿”å›: allow = true
```

---

### 3.3 æ‰§è¡Œè·Ÿè¸ªï¼ˆTraceï¼‰

**å¯ç”¨è·Ÿè¸ª**:

```bash
opa eval --explain=full 'data.example.allow' -d policy.rego -i input.json
```

**è¾“å‡º**:

```text
query:1           Enter data.example.allow = _
query:1           | Eval data.example.allow = _
query:1           | Index data.example.allow matched 1 rule
policy.rego:3     | Enter allow
policy.rego:4     | | Eval input.method == "GET"
policy.rego:4     | | Index input.method = ref, lookup "GET"
policy.rego:4     | | Exit input.method == "GET"
policy.rego:5     | | Eval some user in data.users
policy.rego:5     | | Index data.users (matched 2 items)
policy.rego:5     | | Enter user = {"id": "alice", ...}
policy.rego:6     | | | Eval user.id == input.user_id
policy.rego:6     | | | Exit user.id == input.user_id
policy.rego:7     | | | Eval "read" in user.permissions
policy.rego:7     | | | Exit "read" in user.permissions
policy.rego:5     | | Exit some user in data.users
policy.rego:3     | Exit allow (success)
query:1           | Exit data.example.allow = true
query:1           Redo data.example.allow = _
```

---

## 4. ä¼˜åŒ–æŠ€æœ¯

### 4.1 ç´¢å¼•ï¼ˆIndexingï¼‰

**è‡ªåŠ¨ç´¢å¼•æ„å»º**:

OPAè‡ªåŠ¨ä¸ºä»¥ä¸‹æ¨¡å¼å»ºç«‹å“ˆå¸Œç´¢å¼•ï¼š

```rego
# æ¨¡å¼1: ç­‰å€¼æ¯”è¾ƒ
input.x == "constant"
data.y[z] == "constant"

# æ¨¡å¼2: ç›´æ¥è®¿é—®
data.users["alice"]
data.configs[input.config_id]
```

**ç´¢å¼•æ•°æ®ç»“æ„**:

```go
type Index struct {
    // é”® â†’ è§„åˆ™é›†åˆ
    exact map[string][]*Rule
    
    // Trieç”¨äºå‰ç¼€åŒ¹é…
    trie *Trie
}
```

**æŸ¥æ‰¾è¿‡ç¨‹**:

```python
def find_rules_indexed(ref, store):
    """åˆ©ç”¨ç´¢å¼•æŸ¥æ‰¾è§„åˆ™"""
    # 1. å°è¯•ç²¾ç¡®åŒ¹é…
    if ref.is_concrete():
        return store.index.exact[ref.value]
    
    # 2. å°è¯•å‰ç¼€åŒ¹é…
    if ref.has_prefix():
        return store.index.trie.find(ref.prefix)
    
    # 3. å›é€€åˆ°å…¨è¡¨æ‰«æ
    return store.all_rules
```

**æ€§èƒ½æå‡**:

```text
æ— ç´¢å¼•: O(n) n=è§„åˆ™æ•°é‡
æœ‰ç´¢å¼•: O(1) ç²¾ç¡®åŒ¹é…
        O(log n) å‰ç¼€åŒ¹é…
```

---

### 4.2 çŸ­è·¯æ±‚å€¼ï¼ˆShort-Circuitï¼‰

**åŸç†**: ä¸€æ—¦ç¡®å®šç»“æœï¼Œç«‹å³åœæ­¢ã€‚

**ç¤ºä¾‹**:

```rego
# ANDè¿æ¥: ä»»ä¸€å¤±è´¥åˆ™æ•´ä½“å¤±è´¥
allow if {
    input.method == "POST"  # å¦‚æœå¤±è´¥ï¼Œä¸æ‰§è¡Œåç»­
    expensive_check()
}

# ORè¿æ¥: ä»»ä¸€æˆåŠŸåˆ™æ•´ä½“æˆåŠŸ
allow if { is_admin }       # å¦‚æœæˆåŠŸï¼Œä¸å°è¯•å…¶ä»–è§„åˆ™
allow if { is_public }
```

---

### 4.3 å°¾è°ƒç”¨ä¼˜åŒ–ï¼ˆTail Call Optimizationï¼‰

**OPAå®ç°**: è¯†åˆ«å°¾é€’å½’ï¼Œè½¬æ¢ä¸ºè¿­ä»£ã€‚

**ç¤ºä¾‹**:

```rego
# åŸå§‹é€’å½’
count(arr, n) if {
    n == count(rest, n-1)
    rest := array.slice(arr, 0, n-1)
}

# ä¼˜åŒ–ä¸ºè¿­ä»£
count_iter(arr, acc, i) if {
    i >= count(arr)
    result := acc
}
```

---

### 4.4 ç¼“å­˜ï¼ˆCachingï¼‰

**è§„åˆ™çº§ç¼“å­˜**:

```go
type Cache struct {
    results map[string]Value  // æŸ¥è¯¢ â†’ ç»“æœ
    hits    uint64
    misses  uint64
}

func (e *Evaluator) EvalCached(query Query, input Input) Value {
    key := hash(query, input)
    if val, ok := e.cache.results[key]; ok {
        e.cache.hits++
        return val
    }
    
    result := e.Eval(query, input)
    e.cache.results[key] = result
    e.cache.misses++
    return result
}
```

**ç¼“å­˜ç­–ç•¥**:

- LRUï¼ˆLeast Recently Usedï¼‰
- TTLï¼ˆTime To Liveï¼‰
- å¤§å°é™åˆ¶

---

## 5. å®ç°ç»†èŠ‚

### 5.1 Goå®ç°ï¼ˆç®€åŒ–ï¼‰

```go
package topdown

import "github.com/open-policy-agent/opa/ast"

// Evaluator æ±‚å€¼å™¨
type Evaluator struct {
    store  Store
    input  ast.Value
    index  *Index
    cache  *Cache
}

// Eval æ±‚å€¼æŸ¥è¯¢
func (e *Evaluator) Eval(ctx context.Context, query ast.Body) ([]Bindings, error) {
    return e.eval(ctx, query, NewBindings(), 0)
}

// eval é€’å½’æ±‚å€¼
func (e *Evaluator) eval(ctx context.Context, query ast.Body, bindings Bindings, idx int) ([]Bindings, error) {
    // åŸºç¡€æƒ…å†µ: æ‰€æœ‰è¡¨è¾¾å¼å·²æ±‚å€¼
    if idx >= len(query) {
        return []Bindings{bindings}, nil
    }
    
    expr := query[idx]
    var results []Bindings
    
    // æ±‚å€¼å½“å‰è¡¨è¾¾å¼
    for _, newBindings := range e.evalExpr(ctx, expr, bindings) {
        // é€’å½’æ±‚å€¼å‰©ä½™è¡¨è¾¾å¼
        rest, err := e.eval(ctx, query, newBindings, idx+1)
        if err != nil {
            return nil, err
        }
        results = append(results, rest...)
    }
    
    return results, nil
}

// evalExpr æ±‚å€¼å•ä¸ªè¡¨è¾¾å¼
func (e *Evaluator) evalExpr(ctx context.Context, expr *ast.Expr, bindings Bindings) []Bindings {
    switch {
    case expr.IsEquality():
        return e.evalEquality(expr, bindings)
    case expr.IsCall():
        return e.evalCall(ctx, expr, bindings)
    case expr.IsNegated():
        return e.evalNegation(ctx, expr, bindings)
    default:
        return nil
    }
}

// evalEquality æ±‚å€¼ç›¸ç­‰è¡¨è¾¾å¼
func (e *Evaluator) evalEquality(expr *ast.Expr, bindings Bindings) []Bindings {
    // æ±‚å€¼å·¦å³ä¸¤ä¾§
    left := e.evalTerm(expr.Operand(0), bindings)
    right := e.evalTerm(expr.Operand(1), bindings)
    
    // ç»Ÿä¸€
    theta, err := Unify(left, right)
    if err != nil {
        return nil
    }
    
    // æ‰©å±•ç»‘å®š
    newBindings := bindings.Copy()
    newBindings.Extend(theta)
    return []Bindings{newBindings}
}
```

---

### 5.2 æ•°æ®ç»“æ„

**å˜é‡ç»‘å®š**:

```go
type Bindings struct {
    m map[ast.Var]ast.Value
}

func (b Bindings) Get(v ast.Var) (ast.Value, bool) {
    val, ok := b.m[v]
    return val, ok
}

func (b *Bindings) Put(v ast.Var, val ast.Value) {
    b.m[v] = val
}

func (b Bindings) Copy() Bindings {
    m := make(map[ast.Var]ast.Value, len(b.m))
    for k, v := range b.m {
        m[k] = v
    }
    return Bindings{m}
}
```

**æ±‚å€¼ä¸Šä¸‹æ–‡**:

```go
type Context struct {
    Query    ast.Body
    Input    ast.Value
    Data     ast.Value
    Bindings Bindings
    Trace    *Trace
    Cancel   context.Context
}
```

---

## 6. æ€§èƒ½åˆ†æ

### 6.1 æ—¶é—´å¤æ‚åº¦

**æœ€åæƒ…å†µ**:

```text
T(query) = O(b^d Ã— |Rules| Ã— |Data|)
```

- `b`: åˆ†æ”¯å› å­ï¼ˆæ¯æ­¥çš„é€‰æ‹©æ•°ï¼‰
- `d`: æŸ¥è¯¢æ·±åº¦
- `|Rules|`: è§„åˆ™æ•°é‡
- `|Data|`: æ•°æ®å¤§å°

**æœ€å¥½æƒ…å†µ**ï¼ˆæœ‰ç´¢å¼•ï¼‰:

```text
T(query) = O(d Ã— log|Rules|)
```

---

### 6.2 ç©ºé—´å¤æ‚åº¦

**è°ƒç”¨æ ˆ**:

```text
S(stack) = O(d Ã— |Vars|)
```

- `d`: é€’å½’æ·±åº¦
- `|Vars|`: å˜é‡æ•°é‡

**ç»‘å®šå­˜å‚¨**:

```text
S(bindings) = O(|Solutions| Ã— |Vars|)
```

---

### 6.3 åŸºå‡†æµ‹è¯•

**æµ‹è¯•ç”¨ä¾‹**:

```rego
package benchmark

allow if {
    input.method == "GET"
    user := data.users[input.user_id]
    "read" in user.permissions
}
```

**ç»“æœ**ï¼ˆå•æ ¸ï¼Œç®€å•è§„åˆ™ï¼‰:

```text
BenchmarkEval-8    1000000    1.2 Âµs/op    0 allocs/op
```

**æ‰©å±•**ï¼ˆ100ä¸‡è§„åˆ™ + ç´¢å¼•ï¼‰:

```text
BenchmarkEvalIndexed-8    500000    2.5 Âµs/op    0 allocs/op
```

---

## é™„å½•: è°ƒè¯•æŠ€å·§

### A.1 å¯ç”¨è¯¦ç»†æ—¥å¿—

```bash
opa run --server --log-level debug
```

### A.2 ä½¿ç”¨REPL

```bash
opa run
> data.example.allow with input as {"user": "alice"}
true
```

### A.3 æ€§èƒ½åˆ†æ

```bash
opa eval --profile 'data.example.allow' -d policy.rego
```

**è¾“å‡º**:

```text
+------------------+--------+---------+
| RULE             | TIME   | CALLS   |
+------------------+--------+---------+
| data.example.allow | 1.2ms | 1       |
| data.example.is_admin | 0.5ms | 1    |
+------------------+--------+---------+
```

---

**ä¸‹ä¸€ç¯‡**: [03.5-ç´¢å¼•ä¸ä¼˜åŒ–](./03.5-ç´¢å¼•ä¸ä¼˜åŒ–.md)  
**ç›¸å…³**: [06.3-æ±‚å€¼æ­£ç¡®æ€§è¯æ˜](../06-å½¢å¼åŒ–è¯æ˜/06.3-æ±‚å€¼æ­£ç¡®æ€§è¯æ˜.md)
