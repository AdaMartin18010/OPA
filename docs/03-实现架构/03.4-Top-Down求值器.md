# Top-Down 求值器（Top-Down Evaluator）

> **更新日期**: 2025年10月20日  
> **实现**: Go 1.22+ / OPA v0.60+  
> **算法**: SLD-Resolution + Backtracking

---

## 目录

- [Top-Down 求值器（Top-Down Evaluator）](#top-down-求值器top-down-evaluator)
  - [目录](#目录)
  - [1. 求值器概述](#1-求值器概述)
    - [1.1 什么是Top-Down求值](#11-什么是top-down求值)
    - [1.2 算法基础](#12-算法基础)
    - [1.3 求值器架构](#13-求值器架构)
  - [2. 核心算法](#2-核心算法)
    - [2.1 主求值循环](#21-主求值循环)
    - [2.2 统一算法（Unification）](#22-统一算法unification)
    - [2.3 回溯机制（Backtracking）](#23-回溯机制backtracking)
  - [3. 求值过程](#3-求值过程)
    - [3.1 完整示例](#31-完整示例)
    - [3.2 求值步骤](#32-求值步骤)
    - [3.3 执行跟踪（Trace）](#33-执行跟踪trace)
  - [4. 优化技术](#4-优化技术)
    - [4.1 索引（Indexing）](#41-索引indexing)
    - [4.2 短路求值（Short-Circuit）](#42-短路求值short-circuit)
    - [4.3 尾调用优化（Tail Call Optimization）](#43-尾调用优化tail-call-optimization)
    - [4.4 缓存（Caching）](#44-缓存caching)
  - [5. 实现细节](#5-实现细节)
    - [5.1 Go实现（简化）](#51-go实现简化)
    - [5.2 数据结构](#52-数据结构)
  - [6. 性能分析](#6-性能分析)
    - [6.1 时间复杂度](#61-时间复杂度)
    - [6.2 空间复杂度](#62-空间复杂度)
    - [6.3 基准测试](#63-基准测试)
  - [附录: 调试技巧](#附录-调试技巧)
    - [A.1 启用详细日志](#a1-启用详细日志)
    - [A.2 使用REPL](#a2-使用repl)
    - [A.3 性能分析](#a3-性能分析)

---

## 1. 求值器概述

### 1.1 什么是Top-Down求值

**定义**: 从查询目标开始，递归地分解成子目标，直到所有目标都被满足或失败。

**对比Bottom-Up**:

| 维度 | Top-Down | Bottom-Up |
|------|----------|-----------|
| **起点** | 查询目标 | 基础事实 |
| **方向** | 目标→事实 | 事实→目标 |
| **适用** | 目标导向查询 | 全量推导 |
| **空间** | 低（按需计算） | 高（预计算所有） |
| **OPA选择** | ✅ | ❌ |

**为什么选择Top-Down**:

1. **按需求值**: 只计算查询相关的规则
2. **延迟低**: 避免不必要的计算
3. **内存友好**: 不需要存储所有中间结果
4. **适合云原生**: 请求驱动、无状态

---

### 1.2 算法基础

**理论基础**: SLD-Resolution（Selective Linear Definite clause resolution）

**原理**:

```text
目标: G
规则: H :- B₁, B₂, ..., Bₙ

如果 G 与 H 统一（unify），则:
  新目标 = B₁, B₂, ..., Bₙ, G的剩余部分
```

**示例**:

```rego
# 规则
allow if {
    input.method == "GET"
    is_admin
}

is_admin if {
    input.user.role == "admin"
}
```

**求值过程**:

```text
目标: allow
  → 匹配规则: allow :- input.method == "GET", is_admin
  → 子目标1: input.method == "GET" ✓
  → 子目标2: is_admin
    → 匹配规则: is_admin :- input.user.role == "admin"
    → 子目标2.1: input.user.role == "admin" ✓
  → 成功: allow = true
```

---

### 1.3 求值器架构

```text
┌─────────────────────────────────────────┐
│          Query Interface                │
│   (input + query path)                  │
└───────────────┬─────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────┐
│      Query Planner (查询规划)            │
│  • 路径解析                              │
│  • 规则查找                              │
│  • 索引选择                              │
└───────────────┬─────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────┐
│    Evaluation Engine (求值引擎)         │
│  ┌─────────────────────────────────┐   │
│  │  1. Unification (统一)           │   │
│  │  2. Indexing (索引查找)          │   │
│  │  3. Backtracking (回溯)          │   │
│  │  4. Caching (缓存)               │   │
│  └─────────────────────────────────┘    │
└───────────────┬─────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────┐
│      Result Builder (结果构建)           │
│  • 绑定收集                              │
│  • 结果格式化                            │
│  • 错误处理                              │
└─────────────────────────────────────────┘
```

---

## 2. 核心算法

### 2.1 主求值循环

**伪代码**:

```python
def evaluate(goal, bindings, store):
    """
    goal: 当前目标（表达式列表）
    bindings: 当前变量绑定
    store: 数据存储
    返回: 所有满足目标的绑定集合
    """
    if goal.is_empty():
        # 所有子目标已满足
        return {bindings}
    
    # 选择第一个子目标
    current, rest = goal.split_first()
    results = set()
    
    # 尝试所有可能的方式满足当前子目标
    for new_bindings in satisfy(current, bindings, store):
        # 递归求值剩余目标
        for final_bindings in evaluate(rest, new_bindings, store):
            results.add(final_bindings)
    
    return results


def satisfy(expr, bindings, store):
    """满足单个表达式"""
    if expr.is_unification():  # x = y
        theta = unify(expr.left, expr.right, bindings)
        if theta is not None:
            yield bindings.extend(theta)
    
    elif expr.is_comparison():  # x == y
        v1 = evaluate_term(expr.left, bindings)
        v2 = evaluate_term(expr.right, bindings)
        if compare(v1, v2, expr.operator):
            yield bindings
    
    elif expr.is_call():  # f(x, y)
        # 查找规则定义
        for rule in find_rules(expr.name, store):
            # 统一参数
            theta = unify_args(expr.args, rule.params, bindings)
            if theta is not None:
                # 求值规则体
                for body_bindings in evaluate(rule.body, theta, store):
                    yield body_bindings
    
    elif expr.is_negation():  # not p
        # 否定即失败（Negation as Failure）
        if not any(evaluate([expr.inner], bindings, store)):
            yield bindings
```

---

### 2.2 统一算法（Unification）

**Robinson统一算法**（1965）:

```python
def unify(term1, term2, bindings):
    """
    返回使 term1 和 term2 相等的绑定，失败则返回 None
    """
    # 应用当前绑定
    t1 = deref(term1, bindings)
    t2 = deref(term2, bindings)
    
    # 情况1: 相同值
    if t1 == t2:
        return {}
    
    # 情况2: t1是变量
    if is_var(t1):
        if occurs_check(t1, t2, bindings):
            return None  # 循环引用
        return {t1: t2}
    
    # 情况3: t2是变量
    if is_var(t2):
        if occurs_check(t2, t1, bindings):
            return None
        return {t2: t1}
    
    # 情况4: 复合类型
    if is_array(t1) and is_array(t2):
        if len(t1) != len(t2):
            return None
        result = {}
        for i in range(len(t1)):
            theta = unify(t1[i], t2[i], bindings.extend(result))
            if theta is None:
                return None
            result.update(theta)
        return result
    
    if is_object(t1) and is_object(t2):
        if set(t1.keys()) != set(t2.keys()):
            return None
        result = {}
        for key in t1.keys():
            theta = unify(t1[key], t2[key], bindings.extend(result))
            if theta is None:
                return None
            result.update(theta)
        return result
    
    # 失败
    return None


def deref(term, bindings):
    """解引用变量"""
    while is_var(term) and term in bindings:
        term = bindings[term]
    return term


def occurs_check(var, term, bindings):
    """检查var是否出现在term中（防止无限循环）"""
    term = deref(term, bindings)
    if var == term:
        return True
    if is_compound(term):
        return any(occurs_check(var, sub, bindings) for sub in term)
    return False
```

---

### 2.3 回溯机制（Backtracking）

**实现方式**: 使用生成器（Generator）实现自动回溯。

**示例**:

```python
def evaluate_disjunction(rules, bindings, store):
    """求值多个规则（OR语义）"""
    for rule in rules:
        # 尝试每个规则
        for result in evaluate(rule.body, bindings, store):
            yield result  # 成功则yield
            # 如果调用者需要更多结果，会继续尝试下一个规则
```

**调用栈示例**:

```text
目标: allow
  尝试规则1: allow :- is_admin
    尝试is_admin规则1: is_admin :- role == "admin" [失败]
    回溯...
    尝试is_admin规则2: is_admin :- role == "superuser" [成功] ✓
  返回成功

如果调用者需要所有解:
  继续...
  尝试规则2: allow :- is_public [成功] ✓
  返回成功
```

---

## 3. 求值过程

### 3.1 完整示例

**策略**:

```rego
package example

import future.keywords.if

allow if {
    input.method == "GET"
    some user in data.users
    user.id == input.user_id
    "read" in user.permissions
}
```

**输入**:

```json
{
    "method": "GET",
    "user_id": "alice"
}
```

**数据**:

```json
{
    "users": [
        {"id": "alice", "permissions": ["read", "write"]},
        {"id": "bob", "permissions": ["read"]}
    ]
}
```

---

### 3.2 求值步骤

**步骤1: 查找规则**:

```text
查询: data.example.allow
找到规则: allow :- body
```

**步骤2: 求值规则体**:

```text
目标队列: [
    input.method == "GET",
    some user in data.users,
    user.id == input.user_id,
    "read" in user.permissions
]
绑定: {}
```

**步骤3: 表达式1**:

```text
表达式: input.method == "GET"
求值:
    左侧: input.method → "GET"
    右侧: "GET"
    比较: "GET" == "GET" → true ✓
绑定: {}
```

**步骤4: 表达式2**:

```text
表达式: some user in data.users
求值:
    遍历: data.users = [user1, user2]
    迭代1: user = user1 {"id": "alice", ...}
```

**步骤5: 表达式3**:

```text
表达式: user.id == input.user_id
求值:
    左侧: user.id → "alice"
    右侧: input.user_id → "alice"
    比较: "alice" == "alice" → true ✓
绑定: {user: {"id": "alice", "permissions": ["read", "write"]}}
```

**步骤6: 表达式4**:

```text
表达式: "read" in user.permissions
求值:
    user.permissions → ["read", "write"]
    成员检查: "read" in ["read", "write"] → true ✓
绑定: {user: {"id": "alice", ...}}
```

**步骤7: 规则成功**:

```text
所有表达式满足
返回: allow = true
```

---

### 3.3 执行跟踪（Trace）

**启用跟踪**:

```bash
opa eval --explain=full 'data.example.allow' -d policy.rego -i input.json
```

**输出**:

```text
query:1           Enter data.example.allow = _
query:1           | Eval data.example.allow = _
query:1           | Index data.example.allow matched 1 rule
policy.rego:3     | Enter allow
policy.rego:4     | | Eval input.method == "GET"
policy.rego:4     | | Index input.method = ref, lookup "GET"
policy.rego:4     | | Exit input.method == "GET"
policy.rego:5     | | Eval some user in data.users
policy.rego:5     | | Index data.users (matched 2 items)
policy.rego:5     | | Enter user = {"id": "alice", ...}
policy.rego:6     | | | Eval user.id == input.user_id
policy.rego:6     | | | Exit user.id == input.user_id
policy.rego:7     | | | Eval "read" in user.permissions
policy.rego:7     | | | Exit "read" in user.permissions
policy.rego:5     | | Exit some user in data.users
policy.rego:3     | Exit allow (success)
query:1           | Exit data.example.allow = true
query:1           Redo data.example.allow = _
```

---

## 4. 优化技术

### 4.1 索引（Indexing）

**自动索引构建**:

OPA自动为以下模式建立哈希索引：

```rego
# 模式1: 等值比较
input.x == "constant"
data.y[z] == "constant"

# 模式2: 直接访问
data.users["alice"]
data.configs[input.config_id]
```

**索引数据结构**:

```go
type Index struct {
    // 键 → 规则集合
    exact map[string][]*Rule
    
    // Trie用于前缀匹配
    trie *Trie
}
```

**查找过程**:

```python
def find_rules_indexed(ref, store):
    """利用索引查找规则"""
    # 1. 尝试精确匹配
    if ref.is_concrete():
        return store.index.exact[ref.value]
    
    # 2. 尝试前缀匹配
    if ref.has_prefix():
        return store.index.trie.find(ref.prefix)
    
    # 3. 回退到全表扫描
    return store.all_rules
```

**性能提升**:

```text
无索引: O(n) n=规则数量
有索引: O(1) 精确匹配
        O(log n) 前缀匹配
```

---

### 4.2 短路求值（Short-Circuit）

**原理**: 一旦确定结果，立即停止。

**示例**:

```rego
# AND连接: 任一失败则整体失败
allow if {
    input.method == "POST"  # 如果失败，不执行后续
    expensive_check()
}

# OR连接: 任一成功则整体成功
allow if { is_admin }       # 如果成功，不尝试其他规则
allow if { is_public }
```

---

### 4.3 尾调用优化（Tail Call Optimization）

**OPA实现**: 识别尾递归，转换为迭代。

**示例**:

```rego
# 原始递归
count(arr, n) if {
    n == count(rest, n-1)
    rest := array.slice(arr, 0, n-1)
}

# 优化为迭代
count_iter(arr, acc, i) if {
    i >= count(arr)
    result := acc
}
```

---

### 4.4 缓存（Caching）

**规则级缓存**:

```go
type Cache struct {
    results map[string]Value  // 查询 → 结果
    hits    uint64
    misses  uint64
}

func (e *Evaluator) EvalCached(query Query, input Input) Value {
    key := hash(query, input)
    if val, ok := e.cache.results[key]; ok {
        e.cache.hits++
        return val
    }
    
    result := e.Eval(query, input)
    e.cache.results[key] = result
    e.cache.misses++
    return result
}
```

**缓存策略**:

- LRU（Least Recently Used）
- TTL（Time To Live）
- 大小限制

---

## 5. 实现细节

### 5.1 Go实现（简化）

```go
package topdown

import "github.com/open-policy-agent/opa/ast"

// Evaluator 求值器
type Evaluator struct {
    store  Store
    input  ast.Value
    index  *Index
    cache  *Cache
}

// Eval 求值查询
func (e *Evaluator) Eval(ctx context.Context, query ast.Body) ([]Bindings, error) {
    return e.eval(ctx, query, NewBindings(), 0)
}

// eval 递归求值
func (e *Evaluator) eval(ctx context.Context, query ast.Body, bindings Bindings, idx int) ([]Bindings, error) {
    // 基础情况: 所有表达式已求值
    if idx >= len(query) {
        return []Bindings{bindings}, nil
    }
    
    expr := query[idx]
    var results []Bindings
    
    // 求值当前表达式
    for _, newBindings := range e.evalExpr(ctx, expr, bindings) {
        // 递归求值剩余表达式
        rest, err := e.eval(ctx, query, newBindings, idx+1)
        if err != nil {
            return nil, err
        }
        results = append(results, rest...)
    }
    
    return results, nil
}

// evalExpr 求值单个表达式
func (e *Evaluator) evalExpr(ctx context.Context, expr *ast.Expr, bindings Bindings) []Bindings {
    switch {
    case expr.IsEquality():
        return e.evalEquality(expr, bindings)
    case expr.IsCall():
        return e.evalCall(ctx, expr, bindings)
    case expr.IsNegated():
        return e.evalNegation(ctx, expr, bindings)
    default:
        return nil
    }
}

// evalEquality 求值相等表达式
func (e *Evaluator) evalEquality(expr *ast.Expr, bindings Bindings) []Bindings {
    // 求值左右两侧
    left := e.evalTerm(expr.Operand(0), bindings)
    right := e.evalTerm(expr.Operand(1), bindings)
    
    // 统一
    theta, err := Unify(left, right)
    if err != nil {
        return nil
    }
    
    // 扩展绑定
    newBindings := bindings.Copy()
    newBindings.Extend(theta)
    return []Bindings{newBindings}
}
```

---

### 5.2 数据结构

**变量绑定**:

```go
type Bindings struct {
    m map[ast.Var]ast.Value
}

func (b Bindings) Get(v ast.Var) (ast.Value, bool) {
    val, ok := b.m[v]
    return val, ok
}

func (b *Bindings) Put(v ast.Var, val ast.Value) {
    b.m[v] = val
}

func (b Bindings) Copy() Bindings {
    m := make(map[ast.Var]ast.Value, len(b.m))
    for k, v := range b.m {
        m[k] = v
    }
    return Bindings{m}
}
```

**求值上下文**:

```go
type Context struct {
    Query    ast.Body
    Input    ast.Value
    Data     ast.Value
    Bindings Bindings
    Trace    *Trace
    Cancel   context.Context
}
```

---

## 6. 性能分析

### 6.1 时间复杂度

**最坏情况**:

```text
T(query) = O(b^d × |Rules| × |Data|)
```

- `b`: 分支因子（每步的选择数）
- `d`: 查询深度
- `|Rules|`: 规则数量
- `|Data|`: 数据大小

**最好情况**（有索引）:

```text
T(query) = O(d × log|Rules|)
```

---

### 6.2 空间复杂度

**调用栈**:

```text
S(stack) = O(d × |Vars|)
```

- `d`: 递归深度
- `|Vars|`: 变量数量

**绑定存储**:

```text
S(bindings) = O(|Solutions| × |Vars|)
```

---

### 6.3 基准测试

**测试用例**:

```rego
package benchmark

allow if {
    input.method == "GET"
    user := data.users[input.user_id]
    "read" in user.permissions
}
```

**结果**（单核，简单规则）:

```text
BenchmarkEval-8    1000000    1.2 µs/op    0 allocs/op
```

**扩展**（100万规则 + 索引）:

```text
BenchmarkEvalIndexed-8    500000    2.5 µs/op    0 allocs/op
```

---

## 附录: 调试技巧

### A.1 启用详细日志

```bash
opa run --server --log-level debug
```

### A.2 使用REPL

```bash
opa run
> data.example.allow with input as {"user": "alice"}
true
```

### A.3 性能分析

```bash
opa eval --profile 'data.example.allow' -d policy.rego
```

**输出**:

```text
+------------------+--------+---------+
| RULE             | TIME   | CALLS   |
+------------------+--------+---------+
| data.example.allow | 1.2ms | 1       |
| data.example.is_admin | 0.5ms | 1    |
+------------------+--------+---------+
```

---

**下一篇**: [03.5-索引与优化](./03.5-索引与优化.md)  
**相关**: [06.3-求值正确性证明](../06-形式化证明/06.3-求值正确性证明.md)
