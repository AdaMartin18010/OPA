# API网关授权（API Gateway Authorization）

> **适用版本**: OPA v0.30+ (Envoy插件成熟) | 推荐 v0.68+  
> **场景**: 微服务架构、API管理  
> **集成**: Envoy、Kong、NGINX、AWS API Gateway  
> **最后验证**: 2025-10-21  
> **文档状态**: ✅ 生产验证  
> **参考**: <https://www.openpolicyagent.org/docs/latest/envoy-authorization/>

---

## 🌐 API网关授权架构

> **部署模式**:
>
> - ✅ **Sidecar模式**（推荐）：每个网关实例配套OPA
>   - 优点：低延迟（<5ms）、高可用、无单点故障
>   - 缺点：资源开销稍高
> - ✅ **集中式模式**：共享OPA集群
>   - 优点：资源集约、策略统一管理
>   - 缺点：网络延迟、需要高可用设计
>
> **性能要求**:
>
> - P99延迟 < 10ms（Sidecar < 5ms）
> - QPS支持 > 10K（单OPA实例）
> - CPU/内存：200m CPU + 256MB（轻量场景）
>
> **生产注意事项**:
>
> - ⚠️ 配置降级策略（OPA不可用时的行为）
> - ⚠️ 监控授权延迟和拒绝率
> - ✅ 使用Bundle更新策略（避免重启）
>
> 实战: [电商API案例](../../PRODUCTION_CASES.md#案例1电商平台api授权) | [详细实战](../09-生产实战/09.1-电商API授权实战.md)

---

## 1. 场景概述

### 1.1 API网关授权需求

**核心挑战**：

```text
挑战1: 细粒度授权
  - 不同API不同权限要求
  - 动态权限管理
  - 上下文相关决策

挑战2: 高性能要求
  - 延迟 < 5ms
  - 吞吐 > 10k req/s
  - 高可用 99.99%

挑战3: 策略复杂性
  - RBAC + ABAC混合
  - 多租户隔离
  - 速率限制
  - 数据过滤
```

### 1.2 OPA集成架构

**Envoy + OPA架构**：

```text
┌──────────┐
│  Client  │
└────┬─────┘
     │ HTTP Request
     ↓
┌────────────────────────────────┐
│    Envoy Proxy (API Gateway)   │
│  ┌──────────────────────────┐  │
│  │  1. 接收请求              │  │
│  ├──────────────────────────┤  │
│  │  2. ext_authz调用OPA     │◄─┼─→ OPA Sidecar
│  │     - JWT验证             │  │   ├── 策略求值
│  │     - 权限检查            │  │   ├── 数据查询
│  │     - 速率限制            │  │   └── 决策返回
│  ├──────────────────────────┤  │
│  │  3. 应用决策              │  │
│  │     - Allow: 转发请求     │  │
│  │     - Deny: 返回403       │  │
│  └──────────────────────────┘  │
└────────────┬───────────────────┘
             │
             ↓ (if allowed)
┌────────────────────────────────┐
│      Backend Service           │
└────────────────────────────────┘
```

---

## 2. Envoy集成

### 2.1 Envoy配置

**ext_authz配置**：

```yaml
static_resources:
  listeners:
    - name: main
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8080
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                codec_type: AUTO
                stat_prefix: ingress_http
                route_config:
                  name: local_route
                  virtual_hosts:
                    - name: backend
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: backend_service
                http_filters:
                  # OPA授权过滤器
                  - name: envoy.filters.http.ext_authz
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
                      transport_api_version: V3
                      grpc_service:
                        envoy_grpc:
                          cluster_name: opa_service
                        timeout: 0.5s
                      with_request_body:
                        max_request_bytes: 8192
                        allow_partial_message: true
                  
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
    - name: opa_service
      connect_timeout: 0.25s
      type: STRICT_DNS
      lb_policy: ROUND_ROBIN
      http2_protocol_options: {}
      load_assignment:
        cluster_name: opa_service
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: 127.0.0.1
                      port_value: 9191
    
    - name: backend_service
      connect_timeout: 0.25s
      type: STRICT_DNS
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: backend_service
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: backend
                      port_value: 8000
```

### 2.2 OPA策略

**完整授权策略**：

```rego
package envoy.authz

import rego.v1

default allow := false

# JWT验证
allow if {
    valid_jwt
    has_required_permissions
}

# 提取JWT
token := t if {
    v := input.attributes.request.http.headers.authorization
    startswith(v, "Bearer ")
    t := substring(v, 7, -1)
}

# 验证JWT签名
valid_jwt if {
    [_, payload, _] := io.jwt.decode(token)
    payload.exp > time.now_ns() / 1000000000
    io.jwt.verify_hs256(token, "secret-key")
}

# JWT Payload
jwt_payload := payload if {
    [_, payload, _] := io.jwt.decode(token)
}

# 检查权限
has_required_permissions if {
    # 获取请求路径和方法
    path := input.attributes.request.http.path
    method := input.attributes.request.http.method
    
    # 获取用户角色
    user_roles := jwt_payload.roles
    
    # 检查角色是否有权限
    some role in user_roles
    allowed_methods := data.permissions[path][role]
    method in allowed_methods
}

# 速率限制（可选）
allow if {
    valid_jwt
    not rate_limited
}

rate_limited if {
    user_id := jwt_payload.sub
    count := data.rate_limits[user_id].count
    count >= data.rate_limits[user_id].max
}
```

---

## 3. Kong集成

### 3.1 Kong Plugin配置

**OPA Plugin**：

```yaml
apiVersion: configuration.konghq.com/v1
kind: KongPlugin
metadata:
  name: opa-authz
plugin: opa
config:
  opa_host: http://opa:8181
  opa_path: /v1/data/kong/authz/allow
  include_body_in_opa_input: true
  include_route_in_opa_input: true
```

**关联到服务**：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-api
  annotations:
    konghq.com/plugins: opa-authz
spec:
  ports:
    - port: 80
      targetPort: 8000
  selector:
    app: my-api
```

### 3.2 Kong策略

```rego
package kong.authz

import rego.v1

default allow := false

allow if {
    # 验证API Key
    api_key := input.request.headers["x-api-key"]
    data.api_keys[api_key].active == true
    
    # 检查配额
    not quota_exceeded(api_key)
}

quota_exceeded(key) if {
    usage := data.api_usage[key].count
    limit := data.api_keys[key].quota
    usage >= limit
}
```

---

## 4. 多租户SaaS授权

### 4.1 场景设计

**租户隔离架构**：

```text
请求: GET /api/documents/123
Header: X-Tenant-ID: tenant-a

决策流程:
1. 提取租户ID
2. 验证用户属于该租户
3. 检查资源属于该租户
4. 检查用户权限
5. 应用数据过滤
```

### 4.2 租户策略

```rego
package saas.authz

import rego.v1

default allow := false

# 租户隔离
allow if {
    # 1. 用户认证
    user := get_user_from_token
    
    # 2. 租户验证
    tenant_id := input.request.headers["x-tenant-id"]
    user.tenant_id == tenant_id
    
    # 3. 资源所有权
    resource_id := extract_resource_id(input.request.path)
    resource := data.resources[resource_id]
    resource.tenant_id == tenant_id
    
    # 4. 权限检查
    has_permission(user, input.request.method, resource.type)
}

# 提取资源ID
extract_resource_id(path) := id if {
    parts := split(path, "/")
    id := parts[count(parts) - 1]
}

# 权限检查
has_permission(user, method, resource_type) if {
    some role in user.roles
    permissions := data.role_permissions[role][resource_type]
    method_to_action := {
        "GET": "read",
        "POST": "create",
        "PUT": "update",
        "DELETE": "delete"
    }
    action := method_to_action[method]
    action in permissions
}

# 从JWT提取用户
get_user_from_token := user if {
    token := input.request.headers.authorization
    [_, payload, _] := io.jwt.decode(substring(token, 7, -1))
    user := data.users[payload.sub]
}
```

---

## 5. 细粒度授权

### 5.1 基于属性的访问控制（ABAC）

```rego
package api.abac

import rego.v1

default allow := false

allow if {
    user := get_user
    resource := get_resource
    action := get_action
    
    # ABAC规则
    evaluate_abac(user, resource, action)
}

evaluate_abac(user, resource, action) if {
    # 规则1: Owner全权限
    user.id == resource.owner_id
}

evaluate_abac(user, resource, action) if {
    # 规则2: 同部门read权限
    user.department == resource.department
    action == "read"
}

evaluate_abac(user, resource, action) if {
    # 规则3: 敏感资源需要额外权限
    not resource.sensitive
}

evaluate_abac(user, resource, action) if {
    resource.sensitive
    "sensitive_access" in user.permissions
    action in ["read", "write"]
}
```

### 5.2 上下文相关授权

```rego
package api.context

import rego.v1

allow if {
    # 时间限制
    within_business_hours
    
    # 地理位置限制
    from_allowed_location
    
    # IP白名单
    from_allowed_ip
}

within_business_hours if {
    now := time.now_ns()
    hour := time.clock(now)[0]
    hour >= 9
    hour < 18
    
    weekday := time.weekday(now)
    weekday >= 1  # Monday
    weekday <= 5  # Friday
}

from_allowed_location if {
    country := input.request.headers["x-geoip-country"]
    country in data.allowed_countries
}

from_allowed_ip if {
    ip := input.request.headers["x-forwarded-for"]
    ip in data.ip_whitelist
}
```

---

## 6. 性能优化

### 6.1 缓存策略

**决策缓存**：

```yaml
# OPA配置
caching:
  inter_query_builtin_cache:
    max_size_bytes: 10485760  # 10MB
```

**应用层缓存**：

```go
// Envoy中缓存OPA决策
type CachedAuthz struct {
    cache *lru.Cache
    opa   *opa.Client
}

func (c *CachedAuthz) Check(req *AuthzRequest) (*AuthzResponse, error) {
    key := cacheKey(req)
    
    // 检查缓存
    if cached, ok := c.cache.Get(key); ok {
        return cached.(*AuthzResponse), nil
    }
    
    // 调用OPA
    resp, err := c.opa.Authorize(req)
    if err != nil {
        return nil, err
    }
    
    // 缓存结果（短时间）
    c.cache.Add(key, resp)
    return resp, nil
}
```

### 6.2 批量授权

```rego
package api.batch

import rego.v1

# 批量授权接口
decisions[req] := {"allow": allow, "reason": reason} if {
    some req in input.requests
    allow := check_permission(req)
    reason := sprintf("User %s %s access to %s", 
        [req.user, allow ? "has" : "lacks", req.resource])
}

check_permission(req) if {
    user := data.users[req.user]
    resource := data.resources[req.resource]
    req.action in user.permissions
}
```

---

## 7. 监控与调试

### 7.1 决策日志

**Envoy日志配置**：

```yaml
# OPA配置
decision_logs:
  service: log-service
  reporting:
    min_delay_seconds: 1
    max_delay_seconds: 5
```

**日志格式**：

```json
{
  "decision_id": "uuid",
  "timestamp": "2025-10-21T10:30:00Z",
  "labels": {
    "app": "api-gateway",
    "env": "production"
  },
  "input": {
    "attributes": {
      "request": {
        "http": {
          "method": "GET",
          "path": "/api/users/123",
          "headers": {...}
        }
      }
    }
  },
  "result": {
    "allow": false,
    "reason": "insufficient_permissions"
  },
  "metrics": {
    "timer_rego_query_eval_ns": 1250000
  }
}
```

### 7.2 性能指标

**Prometheus Metrics**：

```promql
# 授权延迟
histogram_quantile(0.99, 
  rate(opa_http_request_duration_seconds_bucket[5m])
)

# 授权拒绝率
rate(envoy_ext_authz_denied_total[5m]) / 
rate(envoy_ext_authz_total[5m])

# 吞吐量
rate(envoy_ext_authz_total[5m])
```

---

## 8. 最佳实践

### 8.1 策略设计

**DO's**:

```rego
# ✅ 结构清晰
package api.authz.v1

default allow := false

allow if { admin_access }
allow if { user_access }

# ✅ 可测试
test_admin_access if {
    admin_access with input as {"user": {"role": "admin"}}
}

# ✅ 性能优化
permissions := data.role_permissions[input.user.role]  # 缓存
allow if { input.action in permissions }
```

**DON'Ts**:

```rego
# ❌ 过于复杂
allow if {
    complex_nested_logic
    with_many_conditions
    hard_to_maintain
}

# ❌ 性能差
allow if {
    user := data.users[_]  # 遍历所有用户
    user.id == input.user_id
}
```

### 8.2 测试

**单元测试**：

```rego
package api.authz.v1

test_admin_allow_all if {
    allow with input as {
        "user": {"id": "u1", "role": "admin"},
        "action": "delete",
        "resource": "anything"
    }
}

test_user_read_only if {
    allow with input as {
        "user": {"id": "u2", "role": "user"},
        "action": "read",
        "resource": "doc"
    }
    
    not allow with input as {
        "user": {"id": "u2", "role": "user"},
        "action": "write",
        "resource": "doc"
    }
}
```

**集成测试**：

```bash
# 使用curl测试
curl -X GET http://api-gateway/api/users/123 \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-Tenant-ID: tenant-a"

# 预期: 200 OK (if authorized) or 403 Forbidden
```

---

## 9. 故障排查

**常见问题**：

```text
问题1: 授权延迟高
  □ 检查OPA性能指标
  □ 优化策略复杂度
  □ 启用缓存
  □ 增加OPA副本数

问题2: 误拒绝/误允许
  □ 检查决策日志
  □ 验证JWT有效性
  □ 确认数据同步
  □ 测试策略逻辑

问题3: OPA不可用
  □ 检查Pod健康状态
  □ 查看OPA日志
  □ 验证Envoy配置
  □ 检查网络连接
```

---

**相关文档**：

- [Kubernetes集成](../04-生态系统/04.1-Kubernetes集成.md)
- [访问控制(RBAC)](./05.1-访问控制(RBAC).md)

**参考资源**：

- Envoy External Authorization: <https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/ext_authz/v3/ext_authz.proto>
- OPA Envoy Tutorial: <https://www.openpolicyagent.org/docs/latest/envoy-tutorial-standalone-envoy/>
