# 访问控制（RBAC）应用场景

> **适用版本**: OPA v0.55+ | Rego v1.0  
> **推荐版本**: OPA v0.68+  
> **最后验证**: 2025-10-21  
> **难度**: ⭐⭐⭐ 中级  
> **常见度**: ⭐⭐⭐⭐⭐ 最常用

---

## ⚠️ RBAC实施建议

> **设计和实现注意**:
> 
> - ✅ **默认拒绝**: 始终使用`default allow := false`
> - ✅ **最小权限**: 遵循最小权限原则，按需授权
> - ✅ **完整测试**: 测试覆盖所有角色和权限组合
> - ✅ **审计日志**: 记录所有访问决策，便于审计
> - ✅ **性能优化**: 使用索引数据结构，避免遍历（见[性能优化](../08-最佳实践/08.2-性能优化指南.md)）
> - ⚠️ 层级角色可能导致意外权限，需要充分测试
> - ⚠️ ABAC条件复杂时注意性能影响
> 
> **生产环境**:
> - 权限变更需要严格的审批流程
> - 定期审查角色和权限配置
> - 监控异常访问模式
> 
> 参考: [生产案例-电商API授权](../../PRODUCTION_CASES.md#案例1电商平台api授权) | [设计模式](../08-最佳实践/08.1-策略设计模式.md)  

---

## 目录

- [访问控制（RBAC）应用场景](#访问控制rbac应用场景)
  - [目录](#目录)
  - [1. RBAC概述](#1-rbac概述)
    - [1.1 什么是RBAC](#11-什么是rbac)
    - [1.2 为什么使用OPA实现RBAC](#12-为什么使用opa实现rbac)
    - [1.3 RBAC模型层次](#13-rbac模型层次)
  - [2. 基本RBAC实现](#2-基本rbac实现)
    - [2.1 数据模型设计](#21-数据模型设计)
      - [2.1.1 用户数据](#211-用户数据)
      - [2.1.2 角色数据](#212-角色数据)
      - [2.1.3 资源数据](#213-资源数据)
    - [2.2 策略实现](#22-策略实现)
      - [2.2.1 基础授权规则](#221-基础授权规则)
      - [2.2.2 使用示例](#222-使用示例)
    - [2.3 辅助规则](#23-辅助规则)
      - [2.3.1 用户信息查询](#231-用户信息查询)
      - [2.3.2 角色查询](#232-角色查询)
  - [3. 高级RBAC模式](#3-高级rbac模式)
    - [3.1 层级角色（Role Hierarchy）](#31-层级角色role-hierarchy)
    - [3.2 属性基础访问控制（ABAC）](#32-属性基础访问控制abac)
    - [3.3 动态权限](#33-动态权限)
    - [3.4 委托授权（Delegation）](#34-委托授权delegation)
  - [4. 实战案例](#4-实战案例)
    - [4.1 API授权](#41-api授权)
      - [4.1.1 策略](#411-策略)
      - [4.1.2 数据](#412-数据)
    - [4.2 文档管理系统](#42-文档管理系统)
      - [4.2.1 数据模型](#421-数据模型)
      - [4.2.2 策略](#422-策略)
    - [4.3 多租户SaaS](#43-多租户saas)
      - [4.3.1 数据模型](#431-数据模型)
      - [4.3.2 策略](#432-策略)
  - [5. 性能优化](#5-性能优化)
    - [5.1 索引策略](#51-索引策略)
    - [5.2 缓存热数据](#52-缓存热数据)
    - [5.3 部分求值](#53-部分求值)
  - [6. 测试与验证](#6-测试与验证)
    - [6.1 单元测试](#61-单元测试)
    - [6.2 集成测试](#62-集成测试)
    - [6.3 性能基准](#63-性能基准)
  - [附录: 常见模式速查](#附录-常见模式速查)

---

## 1. RBAC概述

### 1.1 什么是RBAC

**定义**: Role-Based Access Control，基于角色的访问控制。

**核心概念**:

```text
User (用户) → Role (角色) → Permission (权限) → Resource (资源)
```

**关系**:

- User ⊆ Role: 用户被分配角色
- Role ⊆ Permission: 角色拥有权限
- Permission → (Resource, Action): 权限定义对资源的操作

---

### 1.2 为什么使用OPA实现RBAC

**对比传统RBAC**:

| 维度 | 传统RBAC | OPA RBAC |
|------|---------|----------|
| **表达能力** | 简单角色 | 复杂条件 |
| **上下文** | 静态 | 动态（时间、IP等） |
| **数据访问** | 有限 | 完全访问data |
| **组合** | 困难 | 易组合 |
| **测试** | 手动 | 自动化测试 |

**OPA优势**:

```rego
# 传统RBAC: user.role == "admin"
# OPA RBAC: 可以表达复杂逻辑
allow if {
    user.role == "admin"
    user.department == resource.department
    time.now_ns() < user.access_expires
    not is_blacklisted(user.ip)
}
```

---

### 1.3 RBAC模型层次

```text
Level 0: Flat RBAC (扁平RBAC)
  └─ User → Role → Permission

Level 1: Hierarchical RBAC (层级RBAC)
  └─ Role继承: Admin ⊃ Manager ⊃ User

Level 2: Constrained RBAC (约束RBAC)
  └─ 角色互斥、数量限制

Level 3: Symmetric RBAC (对称RBAC)
  └─ 权限-角色双向查询

Level 4: Context-Aware RBAC (上下文感知)
  └─ 时间、位置、设备等上下文
```

---

## 2. 基本RBAC实现

### 2.1 数据模型设计

#### 2.1.1 用户数据

```json
{
    "users": {
        "alice": {
            "id": "alice",
            "name": "Alice Smith",
            "email": "alice@example.com",
            "roles": ["admin", "developer"],
            "department": "engineering",
            "manager": "bob"
        },
        "bob": {
            "id": "bob",
            "roles": ["manager"],
            "department": "engineering"
        },
        "charlie": {
            "id": "charlie",
            "roles": ["viewer"],
            "department": "sales"
        }
    }
}
```

#### 2.1.2 角色数据

```json
{
    "roles": {
        "admin": {
            "permissions": [
                {"action": "read", "resource": "*"},
                {"action": "write", "resource": "*"},
                {"action": "delete", "resource": "*"}
            ]
        },
        "developer": {
            "permissions": [
                {"action": "read", "resource": "code"},
                {"action": "write", "resource": "code"},
                {"action": "deploy", "resource": "staging"}
            ]
        },
        "viewer": {
            "permissions": [
                {"action": "read", "resource": "*"}
            ]
        }
    }
}
```

#### 2.1.3 资源数据

```json
{
    "resources": {
        "/api/users": {
            "type": "api",
            "owner": "engineering",
            "sensitivity": "high"
        },
        "/api/public": {
            "type": "api",
            "owner": "public",
            "sensitivity": "low"
        }
    }
}
```

---

### 2.2 策略实现

#### 2.2.1 基础授权规则

```rego
package rbac.authz

import future.keywords.if
import future.keywords.in

# 主要决策规则
allow if {
    # 获取用户角色
    some role in user_roles
    # 检查角色权限
    has_permission(role, input.action, input.resource)
}

# 获取用户的所有角色
user_roles contains role if {
    some role in data.users[input.user].roles
}

# 检查角色是否有权限
has_permission(role, action, resource) if {
    # 遍历角色的权限列表
    some permission in data.roles[role].permissions
    # 匹配操作
    permission.action == action
    # 匹配资源（支持通配符）
    matches_resource(permission.resource, resource)
}

# 资源匹配（支持 * 通配符）
matches_resource(pattern, resource) if {
    pattern == "*"
}

matches_resource(pattern, resource) if {
    pattern == resource
}

matches_resource(pattern, resource) if {
    # 前缀匹配: /api/* 匹配 /api/users
    endswith(pattern, "/*")
    prefix := trim_suffix(pattern, "/*")
    startswith(resource, prefix)
}
```

#### 2.2.2 使用示例

**查询**:

```json
{
    "input": {
        "user": "alice",
        "action": "read",
        "resource": "/api/users"
    }
}
```

**结果**:

```json
{
    "result": true
}
```

---

### 2.3 辅助规则

#### 2.3.1 用户信息查询

```rego
# 获取用户详细信息
user_info[info] if {
    user := data.users[input.user]
    info := {
        "id": user.id,
        "name": user.name,
        "roles": user.roles,
        "department": user.department
    }
}

# 检查用户是否存在
user_exists if {
    data.users[input.user]
}
```

#### 2.3.2 角色查询

```rego
# 获取角色的所有权限
role_permissions[role] := permissions if {
    some role in input.roles
    permissions := data.roles[role].permissions
}

# 获取用户的所有权限（扁平化）
user_permissions contains permission if {
    some role in user_roles
    some permission in data.roles[role].permissions
}
```

---

## 3. 高级RBAC模式

### 3.1 层级角色（Role Hierarchy）

**数据模型**:

```json
{
    "role_hierarchy": {
        "admin": {
            "inherits": ["manager"]
        },
        "manager": {
            "inherits": ["developer"]
        },
        "developer": {
            "inherits": ["viewer"]
        },
        "viewer": {
            "inherits": []
        }
    }
}
```

**策略**:

```rego
# 递归获取角色及其继承的角色
all_roles contains role if {
    some role in data.users[input.user].roles
}

all_roles contains inherited_role if {
    some role in all_roles
    some inherited_role in data.role_hierarchy[role].inherits
}

# 使用所有角色检查权限
allow if {
    some role in all_roles
    has_permission(role, input.action, input.resource)
}
```

---

### 3.2 属性基础访问控制（ABAC）

**结合RBAC和ABAC**:

```rego
# RBAC: 基于角色
allow if {
    some role in user_roles
    has_permission(role, input.action, input.resource)
}

# ABAC: 基于属性
allow if {
    # 属性1: 部门匹配
    user := data.users[input.user]
    resource := data.resources[input.resource]
    user.department == resource.owner
    
    # 属性2: 时间限制
    within_business_hours
    
    # 属性3: IP白名单
    input.source_ip in data.allowed_ips
}

within_business_hours if {
    now := time.now_ns()
    hour := time.clock([now, "UTC"])[0]
    hour >= 9
    hour <= 17
}
```

---

### 3.3 动态权限

**场景**: 资源所有者自动获得权限。

```rego
# 资源所有者规则
allow if {
    input.action == "read"
    resource := data.resources[input.resource]
    resource.owner == input.user
}

# 资源创建者规则
allow if {
    input.action in ["read", "write", "delete"]
    resource := data.resources[input.resource]
    resource.created_by == input.user
}
```

---

### 3.4 委托授权（Delegation）

**数据模型**:

```json
{
    "delegations": [
        {
            "from": "alice",
            "to": "bob",
            "permissions": [
                {"action": "approve", "resource": "/api/orders"}
            ],
            "expires": "2025-12-31T23:59:59Z"
        }
    ]
}
```

**策略**:

```rego
# 检查委托权限
allow if {
    some delegation in data.delegations
    delegation.from == data.resources[input.resource].owner
    delegation.to == input.user
    not is_expired(delegation.expires)
    has_delegated_permission(delegation, input.action, input.resource)
}

is_expired(expires_str) if {
    expires := time.parse_rfc3339_ns(expires_str)
    time.now_ns() > expires
}

has_delegated_permission(delegation, action, resource) if {
    some perm in delegation.permissions
    perm.action == action
    perm.resource == resource
}
```

---

## 4. 实战案例

### 4.1 API授权

**场景**: 微服务API授权。

#### 4.1.1 策略

```rego
package api.authz

import future.keywords.if
import future.keywords.in

# 主决策
allow if {
    is_public_endpoint
}

allow if {
    is_authenticated
    has_api_permission
}

# 公开端点
public_endpoints := {
    "/health",
    "/metrics",
    "/api/public/*"
}

is_public_endpoint if {
    some endpoint in public_endpoints
    matches_path(endpoint, input.path)
}

# 认证检查
is_authenticated if {
    input.user != ""
    input.token != ""
    verify_token(input.token, input.user)
}

# API权限检查
has_api_permission if {
    some role in user_roles
    some api_permission in data.api_permissions[role]
    api_permission.method == input.method
    matches_path(api_permission.path, input.path)
}

# 路径匹配
matches_path(pattern, path) if {
    pattern == path
}

matches_path(pattern, path) if {
    endswith(pattern, "/*")
    prefix := trim_suffix(pattern, "/*")
    startswith(path, prefix)
}

# Token验证（简化示例）
verify_token(token, user) if {
    # 实际应该调用JWT验证
    token != ""
}
```

#### 4.1.2 数据

```json
{
    "api_permissions": {
        "admin": [
            {"method": "*", "path": "/api/*"}
        ],
        "developer": [
            {"method": "GET", "path": "/api/services/*"},
            {"method": "POST", "path": "/api/deployments/*"}
        ],
        "viewer": [
            {"method": "GET", "path": "/api/*"}
        ]
    }
}
```

---

### 4.2 文档管理系统

**场景**: 企业文档权限控制。

#### 4.2.1 数据模型

```json
{
    "documents": {
        "doc-001": {
            "title": "Q4 Financial Report",
            "owner": "alice",
            "department": "finance",
            "classification": "confidential",
            "shared_with": ["bob", "charlie"],
            "created_at": "2025-01-01T00:00:00Z"
        }
    }
}
```

#### 4.2.2 策略

```rego
package documents.authz

import future.keywords.if
import future.keywords.in

# 读权限
allow_read if {
    # 场景1: 文档所有者
    is_owner
}

allow_read if {
    # 场景2: 明确共享
    is_shared_with_user
}

allow_read if {
    # 场景3: 同部门 + 权限
    same_department
    "read" in user_permissions
}

allow_read if {
    # 场景4: Admin角色
    "admin" in user_roles
}

# 写权限
allow_write if {
    is_owner
    not is_locked
}

allow_write if {
    "editor" in user_roles
    same_department
}

# 删除权限
allow_delete if {
    is_owner
    "admin" in user_roles
}

# 辅助规则
document := data.documents[input.document_id]

is_owner if {
    document.owner == input.user
}

is_shared_with_user if {
    input.user in document.shared_with
}

same_department if {
    user := data.users[input.user]
    user.department == document.department
}

is_locked if {
    document.locked == true
}
```

---

### 4.3 多租户SaaS

**场景**: SaaS平台租户隔离。

#### 4.3.1 数据模型

```json
{
    "tenants": {
        "tenant-a": {
            "id": "tenant-a",
            "name": "Company A",
            "users": ["alice", "bob"],
            "plan": "enterprise"
        }
    },
    "users": {
        "alice": {
            "id": "alice",
            "tenant": "tenant-a",
            "roles": ["org-admin"]
        }
    },
    "resources": {
        "project-123": {
            "id": "project-123",
            "tenant": "tenant-a",
            "owner": "alice"
        }
    }
}
```

#### 4.3.2 策略

```rego
package saas.authz

import future.keywords.if

# 租户隔离
allow if {
    # 1. 检查资源所属租户
    resource := data.resources[input.resource_id]
    resource_tenant := resource.tenant
    
    # 2. 检查用户所属租户
    user := data.users[input.user]
    user_tenant := user.tenant
    
    # 3. 租户必须匹配
    resource_tenant == user_tenant
    
    # 4. 检查租户内权限
    has_tenant_permission
}

has_tenant_permission if {
    user := data.users[input.user]
    some role in user.roles
    some permission in data.tenant_permissions[role]
    permission.action == input.action
}

# 超级管理员跨租户访问
allow if {
    user := data.users[input.user]
    user.global_admin == true
}
```

---

## 5. 性能优化

### 5.1 索引策略

```rego
# ✅ 好：使用直接索引
user := data.users[input.user_id]

# ❌ 差：遍历所有用户
user := u if {
    u := data.users[_]
    u.id == input.user_id
}
```

### 5.2 缓存热数据

```go
// 应用层缓存用户角色
type RoleCache struct {
    cache map[string][]string
    mu    sync.RWMutex
}

func (rc *RoleCache) GetRoles(userID string) ([]string, bool) {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    roles, ok := rc.cache[userID]
    return roles, ok
}
```

### 5.3 部分求值

**预计算固定数据**:

```bash
# 编译时部分求值
opa build -t wasm -e 'data.rbac.authz.allow' \
    --bundle policy/ \
    --optimize 1
```

**效果**: 将角色权限提前展开，运行时只需检查input。

---

## 6. 测试与验证

### 6.1 单元测试

```rego
package rbac.authz_test

import future.keywords.if

test_admin_full_access if {
    allow with input as {
        "user": "alice",
        "action": "delete",
        "resource": "/api/users"
    } with data.users as {
        "alice": {"roles": ["admin"]}
    } with data.roles as {
        "admin": {
            "permissions": [{"action": "*", "resource": "*"}]
        }
    }
}

test_viewer_read_only if {
    allow with input as {
        "user": "charlie",
        "action": "read",
        "resource": "/api/users"
    }
    
    not allow with input as {
        "user": "charlie",
        "action": "write",
        "resource": "/api/users"
    }
}

test_department_isolation if {
    not allow with input as {
        "user": "charlie",
        "action": "read",
        "resource": "/api/engineering/docs"
    } with data.users.charlie as {
        "department": "sales"
    } with data.resources as {
        "/api/engineering/docs": {"department": "engineering"}
    }
}
```

**运行测试**:

```bash
opa test policy/ -v
```

---

### 6.2 集成测试

**测试框架**（Go示例）:

```go
func TestRBACPolicy(t *testing.T) {
    ctx := context.Background()
    
    // 加载策略
    r := rego.New(
        rego.Query("data.rbac.authz.allow"),
        rego.Load([]string{"policy.rego"}, nil),
    )
    
    // 测试用例
    tests := []struct {
        input    map[string]interface{}
        expected bool
    }{
        {
            input: map[string]interface{}{
                "user":     "alice",
                "action":   "read",
                "resource": "/api/users",
            },
            expected: true,
        },
        // 更多测试...
    }
    
    for _, tt := range tests {
        result, err := r.Eval(ctx, rego.EvalInput(tt.input))
        assert.NoError(t, err)
        assert.Equal(t, tt.expected, result[0].Expressions[0].Value)
    }
}
```

---

### 6.3 性能基准

```bash
# 基准测试
opa bench policy.rego \
    --data data.json \
    --input input.json \
    --count 10000
```

**输出**:

```text
+-------------------+----------+---------+
| METRIC            | VALUE    | UNIT    |
+-------------------+----------+---------+
| samples           | 10000    |         |
| mean              | 1.23     | ms      |
| p50               | 1.10     | ms      |
| p90               | 1.80     | ms      |
| p99               | 3.20     | ms      |
+-------------------+----------+---------+
```

---

## 附录: 常见模式速查

| 模式 | 用途 | 示例 |
|------|------|------|
| **直接角色检查** | 简单RBAC | `"admin" in user.roles` |
| **权限查找** | 标准RBAC | `has_permission(role, action, resource)` |
| **资源所有者** | 动态权限 | `resource.owner == user` |
| **部门隔离** | ABAC | `user.dept == resource.dept` |
| **时间限制** | 上下文感知 | `time.now_ns() < expiry` |
| **委托** | 临时授权 | `delegation.to == user` |
| **继承** | 层级角色 | `all_roles contains inherited` |

---

**下一篇**: [05.2-API网关授权](./05.2-API网关授权.md)  
**相关**: [07.1-核心概念定义](../07-概念图谱/07.1-核心概念定义.md)
