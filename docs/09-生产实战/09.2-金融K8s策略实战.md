# 09.2 金融公司Kubernetes策略实战

> **适用版本**: Gatekeeper v3.10+ | 推荐 v3.18+  
> **Kubernetes版本**: 1.25+ | 推荐 1.30+  
> **难度**: ⭐⭐⭐⭐⭐ 专家级  
> **场景**: 金融生产环境、严格合规  
> **预计学习时间**: 3-4小时  
> **最后验证**: 2025-10-21  
> **文档状态**: ✅ 生产验证

---

## ⚠️ 金融行业合规提示

> **监管要求**:
>
> - ✅ 满足PCI-DSS、SOC 2、ISO 27001合规要求
> - ✅ 所有策略变更需要审计日志
> - ✅ 生产环境部署需要变更审批流程
> - ⚠️ 本案例基于真实场景改编，具体策略需结合自身合规要求
>
> **安全基线**:
>
> - **必须**：禁止特权容器、root用户
> - **必须**：强制网络隔离（NetworkPolicy）
> - **必须**：启用Pod Security Standards
> - **必须**：审计所有拒绝决策
>
> 参考: [安全合规标准](../01-技术规范/01.5-安全合规标准.md) | [部署检查清单](../../CHECKLIST.md)

---

## 📋 案例概述

本案例来自某大型金融机构（资产管理规模 $500B+），展示如何在高度监管的Kubernetes环境中实施多层次策略控制。

### 业务背景

**公司规模**:

- 20+ 关键业务系统
- 500+ 微服务
- 3个K8s集群（开发/预发/生产）
- 多个合规团队（安全、审计、风控）

**核心挑战**:

1. **严格合规**：满足金融监管要求（PCI-DSS、SOC 2、ISO 27001）
2. **零容忍安全**：不允许任何安全漏洞到达生产环境
3. **多团队协作**：20+团队，权限隔离、资源配额管理
4. **审计追溯**：所有操作可审计，策略变更有完整记录

---

## 🏗️ 技术架构

### 整体架构

```text
                    ┌─────────────────────────┐
                    │  开发团队（20+ teams）   │
                    └────────┬────────────────┘
                             │ kubectl apply
                             ↓
                ┌────────────────────────────┐
                │   Kubernetes API Server    │
                └────────────┬───────────────┘
                             │
                             ↓
          ┌──────────────────────────────────┐
          │  OPA Gatekeeper Webhook          │
          │  - Validation Mode               │
          │  - Mutation Mode                 │
          │  - Audit Mode                    │
          └────────────┬─────────────────────┘
                       │
         ┌─────────────┼─────────────┐
         ↓             ↓             ↓
    ┌────────┐   ┌─────────┐  ┌──────────┐
    │ 策略层1 │   │ 策略层2  │  │ 策略层3   │
    │ 安全基线│   │ 资源配额 │  │ 命名规范  │
    └────────┘   └─────────┘  └──────────┘
                       │
                       ↓
              ┌────────────────┐
              │  审计日志       │
              │  - Prometheus   │
              │  - Elasticsearch│
              │  - SIEM集成     │
              └────────────────┘
```

---

## 🔒 策略架构

### 三层策略体系

```text
┌──────────────────────────────────────────┐
│  Layer 1: 安全基线（强制，所有环境）      │
│  - 禁止特权容器                          │
│  - 禁止root用户                          │
│  - 强制资源限制                          │
│  - 镜像仓库白名单                        │
└──────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────┐
│  Layer 2: 资源配额（按命名空间）          │
│  - CPU/内存配额                          │
│  - Pod数量限制                           │
│  - PVC存储限制                           │
└──────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────┐
│  Layer 3: 业务规范（按业务线）            │
│  - 命名规范                              │
│  - 标签要求                              │
│  - 网络策略                              │
│  - 服务网格配置                          │
└──────────────────────────────────────────┘
```

---

## 📦 Layer 1: 安全基线策略

### 1.1 ConstraintTemplate: 安全上下文

```yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspsecuritycontext
  annotations:
    description: "强制安全上下文配置"
    compliance: "PCI-DSS 2.2.4, SOC 2 CC6.1"
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSecurityContext
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowPrivilegeEscalation:
              type: boolean
              description: "是否允许权限提升"
            runAsNonRoot:
              type: boolean
              description: "是否强制非root用户"
            requiredDropCapabilities:
              type: array
              items:
                type: string
              description: "必须丢弃的Linux Capabilities"
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspsecuritycontext

        import rego.v1

        violation[{"msg": msg}] if {
            container := input_containers[_]
            not container.securityContext.runAsNonRoot == true
            msg := sprintf("Container '%s' must set runAsNonRoot to true", [container.name])
        }

        violation[{"msg": msg}] if {
            container := input_containers[_]
            container.securityContext.allowPrivilegeEscalation == true
            msg := sprintf("Container '%s' must not allow privilege escalation", [container.name])
        }

        violation[{"msg": msg}] if {
            container := input_containers[_]
            params := object.get(input, "parameters", {})
            required_caps := object.get(params, "requiredDropCapabilities", [])
            count(required_caps) > 0
            provided_caps := object.get(container, ["securityContext", "capabilities", "drop"], [])
            missing := {cap | cap := required_caps[_]; not cap in provided_caps}
            count(missing) > 0
            msg := sprintf("Container '%s' must drop capabilities: %v", [container.name, missing])
        }

        input_containers[container] if {
            container := input.review.object.spec.containers[_]
        }

        input_containers[container] if {
            container := input.review.object.spec.initContainers[_]
        }
```

### 1.2 Constraint: 生产环境强制

```yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sPSPSecurityContext
metadata:
  name: prod-security-context
  annotations:
    severity: "critical"
    owner: "security-team"
spec:
  enforcementAction: deny
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaceSelector:
      matchLabels:
        environment: production
  parameters:
    allowPrivilegeEscalation: false
    runAsNonRoot: true
    requiredDropCapabilities:
      - ALL
```

---

## 📊 Layer 2: 资源配额策略

### 2.1 ConstraintTemplate: 资源限制

```yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequiredresources
  annotations:
    description: "强制资源requests和limits"
    compliance: "内部资源管理政策"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredResources
      validation:
        openAPIV3Schema:
          type: object
          properties:
            cpu:
              type: object
              properties:
                max:
                  type: string
                min:
                  type: string
            memory:
              type: object
              properties:
                max:
                  type: string
                min:
                  type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredresources

        import rego.v1

        violation[{"msg": msg}] if {
            container := input_containers[_]
            not container.resources.requests.cpu
            msg := sprintf("Container '%s' must specify CPU requests", [container.name])
        }

        violation[{"msg": msg}] if {
            container := input_containers[_]
            not container.resources.limits.cpu
            msg := sprintf("Container '%s' must specify CPU limits", [container.name])
        }

        violation[{"msg": msg}] if {
            container := input_containers[_]
            not container.resources.requests.memory
            msg := sprintf("Container '%s' must specify memory requests", [container.name])
        }

        violation[{"msg": msg}] if {
            container := input_containers[_]
            not container.resources.limits.memory
            msg := sprintf("Container '%s' must specify memory limits", [container.name])
        }

        # 检查资源上限
        violation[{"msg": msg}] if {
            container := input_containers[_]
            params := object.get(input, "parameters", {})
            max_cpu := object.get(params, ["cpu", "max"], "")
            max_cpu != ""
            cpu_limit := container.resources.limits.cpu
            cpu_value := parse_cpu(cpu_limit)
            max_value := parse_cpu(max_cpu)
            cpu_value > max_value
            msg := sprintf("Container '%s' CPU limit %s exceeds maximum %s", [
                container.name,
                cpu_limit,
                max_cpu,
            ])
        }

        parse_cpu(cpu_string) := cores if {
            # 解析"100m"格式
            endswith(cpu_string, "m")
            cores_str := trim_suffix(cpu_string, "m")
            cores := to_number(cores_str) / 1000
        }

        parse_cpu(cpu_string) := cores if {
            # 解析"2"格式
            not endswith(cpu_string, "m")
            cores := to_number(cpu_string)
        }

        input_containers[container] if {
            container := input.review.object.spec.containers[_]
        }

        input_containers[container] if {
            container := input.review.object.spec.initContainers[_]
        }
```

### 2.2 Constraint: 按业务线配置

```yaml
# 核心交易系统（高资源）
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredResources
metadata:
  name: trading-system-resources
spec:
  enforcementAction: deny
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaceSelector:
      matchLabels:
        business: trading
  parameters:
    cpu:
      min: "500m"
      max: "8"
    memory:
      min: "1Gi"
      max: "16Gi"
---
# 一般应用（标准资源）
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredResources
metadata:
  name: standard-app-resources
spec:
  enforcementAction: deny
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaceSelector:
      matchExpressions:
        - key: business
          operator: NotIn
          values: ["trading", "risk"]
  parameters:
    cpu:
      min: "100m"
      max: "2"
    memory:
      min: "128Mi"
      max: "4Gi"
```

---

## 🏷️ Layer 3: 业务规范策略

### 3.1 ConstraintTemplate: 标签要求

```yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
  annotations:
    description: "强制业务标签"
    compliance: "内部CMDB集成要求"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        openAPIV3Schema:
          type: object
          properties:
            labels:
              type: array
              items:
                type: object
                properties:
                  key:
                    type: string
                  allowedRegex:
                    type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredlabels

        import rego.v1

        violation[{"msg": msg}] if {
            provided := {label | input.review.object.metadata.labels[label]}
            required := {label | label := input.parameters.labels[_].key}
            missing := required - provided
            count(missing) > 0
            msg := sprintf("Missing required labels: %v", [missing])
        }

        violation[{"msg": msg}] if {
            label_def := input.parameters.labels[_]
            label_key := label_def.key
            allowed_regex := label_def.allowedRegex
            actual_value := object.get(input.review.object.metadata.labels, label_key, "")
            actual_value != ""
            not regex.match(allowed_regex, actual_value)
            msg := sprintf("Label '%s' value '%s' does not match regex '%s'", [
                label_key,
                actual_value,
                allowed_regex,
            ])
        }
```

### 3.2 Constraint: 金融业务标签

```yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredLabels
metadata:
  name: financial-labels
spec:
  enforcementAction: deny
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet"]
    namespaceSelector:
      matchLabels:
        environment: production
  parameters:
    labels:
      - key: "app"
        allowedRegex: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
      - key: "version"
        allowedRegex: "^v[0-9]+\\.[0-9]+\\.[0-9]+$"
      - key: "owner"
        allowedRegex: "^[a-z-]+$"
      - key: "cost-center"
        allowedRegex: "^CC[0-9]{4}$"
      - key: "compliance"
        allowedRegex: "^(pci-dss|soc2|iso27001)$"
      - key: "data-classification"
        allowedRegex: "^(public|internal|confidential|restricted)$"
```

---

## 📈 性能与监控

### Webhook延迟监控

```yaml
# prometheus-alerts.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: gatekeeper-alerts
  namespace: gatekeeper-system
data:
  alerts.yaml: |
    groups:
      - name: gatekeeper
        interval: 30s
        rules:
          # Webhook延迟告警
          - alert: GatekeeperWebhookHighLatency
            expr: histogram_quantile(0.99, sum(rate(gatekeeper_webhook_request_duration_seconds_bucket[5m])) by (le)) > 1
            for: 5m
            labels:
              severity: warning
              compliance: true
            annotations:
              summary: "Gatekeeper webhook P99延迟超过1秒"
              description: "可能影响集群操作，需要优化策略"

          # 拒绝率告警
          - alert: GatekeeperHighDenyRate
            expr: sum(rate(gatekeeper_violations_total[5m])) by (enforcement_action) > 10
            for: 10m
            labels:
              severity: info
            annotations:
              summary: "Gatekeeper拒绝率过高"
              description: "可能有配置错误或团队不了解策略"

          # 审计违规告警
          - alert: GatekeeperAuditViolations
            expr: sum(gatekeeper_audit_violations) by (enforcement_action, constraint_name) > 0
            for: 1h
            labels:
              severity: critical
              compliance: true
            annotations:
              summary: "发现现有资源违规"
              description: "Constraint {{ $labels.constraint_name }} 发现违规资源"
```

### 审计日志配置

```yaml
# gatekeeper-audit-config.yaml
apiVersion: config.gatekeeper.sh/v1alpha1
kind: Config
metadata:
  name: config
  namespace: gatekeeper-system
spec:
  audit:
    auditInterval: 60  # 每60秒审计一次
    constraintViolationsLimit: 1000
    auditChunkSize: 500
    logLevel: "INFO"
  validation:
    traces:
      - user: "system:serviceaccount:*"
        kind:
          group: ""
          version: "v1"
          kind: "Pod"
        dump: "All"  # 记录所有决策
  match:
    - excludedNamespaces:
        - "kube-system"
        - "kube-public"
        - "kube-node-lease"
        - "gatekeeper-system"
      processes:
        - "audit"
        - "webhook"
```

---

## 🚀 部署流程

### Step 1: 安装Gatekeeper

```bash
# 1. 安装Gatekeeper (Helm)
helm repo add gatekeeper https://open-policy-agent.github.io/gatekeeper/charts
helm repo update

# 2. 创建values.yaml
cat > gatekeeper-values.yaml <<EOF
replicas: 3
auditInterval: 60
constraintViolationsLimit: 1000
auditChunkSize: 500
logLevel: INFO
image:
  repository: openpolicyagent/gatekeeper
  tag: v3.18.0
resources:
  limits:
    cpu: "1000m"
    memory: "512Mi"
  requests:
    cpu: "100m"
    memory: "256Mi"
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8888"
EOF

# 3. 部署
helm install gatekeeper gatekeeper/gatekeeper \
  -n gatekeeper-system \
  --create-namespace \
  -f gatekeeper-values.yaml

# 4. 验证
kubectl get pods -n gatekeeper-system
kubectl get crd | grep gatekeeper
```

### Step 2: 部署策略（分阶段）

**阶段1: Audit模式（2周）**:

```bash
# 部署所有ConstraintTemplate
kubectl apply -f constraint-templates/

# 部署Constraint（enforcementAction: dryrun）
kubectl apply -f constraints/layer1-security-audit.yaml
kubectl apply -f constraints/layer2-resources-audit.yaml

# 监控违规情况
kubectl get constraints -A
kubectl describe constraint prod-security-context
```

**阶段2: 预发环境Deny模式（2周）**:

```bash
# 修改为deny模式
kubectl patch constraint prod-security-context \
  --type=json \
  -p='[{"op": "replace", "path": "/spec/enforcementAction", "value": "deny"}]'

# 监控拒绝率和团队反馈
kubectl get events --field-selector reason=FailedCreate
```

**阶段3: 生产环境Deny模式**:

```bash
# 确认无误后，生产环境启用
kubectl apply -f constraints/layer1-security-prod.yaml
kubectl apply -f constraints/layer2-resources-prod.yaml
kubectl apply -f constraints/layer3-business-prod.yaml

# 持续监控
watch -n 10 'kubectl get constraints -A'
```

### Step 3: 集成监控

```bash
# Prometheus集成
kubectl apply -f monitoring/prometheus-servicemonitor.yaml

# Grafana Dashboard
kubectl apply -f monitoring/gatekeeper-dashboard.json

# 告警规则
kubectl apply -f monitoring/prometheus-alerts.yaml
```

---

## 📊 实际效果

### 部署前后对比

| 指标 | 部署前 | 部署后 | 改善 |
|---|---|---|---|
| **安全漏洞** | 15个/月 | 0个/月 | **100% ↓** |
| **资源超配** | 30% 集群 | 0% | **100% ↓** |
| **审计不合规** | 12次/年 | 0次/年 | **100% ↓** |
| **部署失败率** | 2% | 0.5% | **75% ↓** |
| **部署延迟** | <1s | <1.5s | **+0.5s** |
| **策略覆盖** | 0% | 100% | **+100%** |

### 关键指标

**性能指标**:

- Webhook P99延迟: <800ms（目标<1s）
- 审计周期: 60秒
- 策略评估成功率: 99.99%

**业务指标**:

- 策略违规拦截: ~200次/周
- 审计发现问题: ~50个/月
- 策略变更频率: 2-3次/月

**合规指标**:

- PCI-DSS审计: ✅ 通过
- SOC 2审计: ✅ 通过
- ISO 27001审计: ✅ 通过

---

## 🎓 关键经验

### 1. 分阶段推进

✅ **推荐做法**:

- Week 1-2: Audit模式，收集违规数据
- Week 3-4: 预发环境Deny，团队适应
- Week 5: 生产环境启用

❌ **避免做法**:

- 直接生产Deny模式 → 大量拒绝，影响业务
- 策略太复杂 → 团队理解困难

### 2. 充分沟通

✅ **沟通策略**:

- 每周安全例会讲解新策略
- 提供策略文档和示例
- 建立Slack频道快速答疑

### 3. 监控告警

✅ **必需监控**:

- Webhook延迟（P99 < 1s）
- 拒绝率（突增需调查）
- 审计违规（持续跟进修复）

### 4. 例外管理

```yaml
# 允许特定场景例外
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sPSPSecurityContext
metadata:
  name: security-context-with-exemptions
spec:
  enforcementAction: deny
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
    namespaceSelector:
      matchExpressions:
        - key: policy.gatekeeper.sh/exempt
          operator: DoesNotExist
```

---

## 📚 相关文档

- [Gatekeeper详解](../04-生态系统/04.2-Gatekeeper详解.md)
- [Kubernetes集成](../04-生态系统/04.1-Kubernetes集成.md)
- [安全合规标准](../01-技术规范/01.5-安全合规标准.md)
- [策略设计模式](../08-最佳实践/08.1-策略设计模式.md)
- [部署检查清单](../../CHECKLIST.md)

---

## ❓ 常见问题

**Q: Gatekeeper会影响集群性能吗？**

A: 影响很小（P99增加500-800ms）。关键优化：

- 策略简洁，避免复杂遍历
- 使用Audit模式处理非关键检查
- 监控Webhook延迟

**Q: 如何处理紧急变更？**

A: 设置紧急豁免机制：

```bash
# 临时禁用某个Constraint
kubectl patch constraint prod-security-context \
  --type=json \
  -p='[{"op": "replace", "path": "/spec/enforcementAction", "value": "warn"}]'

# 事后恢复并审计
```

**Q: 策略冲突如何解决？**

A: 使用命名空间标签隔离：

```yaml
match:
  namespaceSelector:
    matchLabels:
      enforcement-level: "strict"  # 或 "standard", "permissive"
```

---

**案例来源**: 基于某全球资产管理公司生产环境脱敏改编  
**实施周期**: 3个月（规划1个月 + 实施2个月）  
**ROI**: 安全事件减少100%，审计成本降低60%

---

**下一步**: 学习 [SaaS多租户WASM部署](09.3-SaaS多租户WASM实战.md) 了解边缘场景优化
