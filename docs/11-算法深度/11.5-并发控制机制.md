# 并发控制机制

> **文档类型**: 算法深度分析  
> **核心主题**: OPA并发控制与同步机制  
> **适用读者**: 并发编程专家、系统架构师、OPA核心开发者  
> **先修知识**: [Go并发模型](https://go.dev/doc/effective_go#concurrency)、[并发语义](../06-形式化证明/06.8-并发语义与正确性.md)  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 3.5 - 算法分析  
> **理论基础**: 并发控制、锁机制、无锁数据结构

---

## 🎯 文档目标

本文档深入分析OPA的**并发控制机制**，确保多线程环境下的正确性和性能。

**核心内容**:
- 并发模型与架构
- 锁机制与同步原语
- 无锁数据结构
- 事务隔离
- 性能优化技术

**学习价值**:
- 理解OPA的并发安全性
- 掌握并发控制算法
- 优化多线程性能
- 避免并发bug

---

## 目录

- [并发控制机制](#并发控制机制)
  - [🎯 文档目标](#-文档目标)
  - [目录](#目录)
  - [1. 并发模型概览](#1-并发模型概览)
    - [1.1 OPA的并发需求](#11-opa的并发需求)
    - [1.2 Go并发模型](#12-go并发模型)
    - [1.3 并发挑战](#13-并发挑战)
  - [2. 同步原语](#2-同步原语)
    - [2.1 Mutex](#21-mutex)
    - [2.2 RWMutex](#22-rwmutex)
    - [2.3 Channel](#23-channel)
  - [3. 存储并发控制](#3-存储并发控制)
    - [3.1 读写锁策略](#31-读写锁策略)
    - [3.2 事务实现](#32-事务实现)
    - [3.3 快照隔离](#33-快照隔离)
  - [4. 无锁数据结构](#4-无锁数据结构)
    - [4.1 CAS操作](#41-cas操作)
    - [4.2 无锁栈](#42-无锁栈)
    - [4.3 无锁队列](#43-无锁队列)
  - [5. 求值器并发](#5-求值器并发)
    - [5.1 并行求值](#51-并行求值)
    - [5.2 工作窃取](#52-工作窃取)
    - [5.3 取消机制](#53-取消机制)
  - [6. 缓存同步](#6-缓存同步)
    - [6.1 并发安全缓存](#61-并发安全缓存)
    - [6.2 缓存一致性](#62-缓存一致性)
    - [6.3 LRU实现](#63-lru实现)
  - [7. Bundle更新](#7-bundle更新)
    - [7.1 热更新机制](#71-热更新机制)
    - [7.2 版本控制](#72-版本控制)
    - [7.3 原子切换](#73-原子切换)
  - [8. 死锁预防](#8-死锁预防)
    - [8.1 锁顺序](#81-锁顺序)
    - [8.2 超时机制](#82-超时机制)
    - [8.3 死锁检测](#83-死锁检测)
  - [9. 性能优化](#9-性能优化)
    - [9.1 锁粒度](#91-锁粒度)
    - [9.2 无争用快速路径](#92-无争用快速路径)
    - [9.3 分片技术](#93-分片技术)
  - [10. 实战示例](#10-实战示例)
    - [10.1 并发查询](#101-并发查询)
    - [10.2 并发更新](#102-并发更新)
    - [10.3 性能测试](#103-性能测试)
  - [附录](#附录)
    - [A. Go并发参考](#a-go并发参考)
    - [B. 并发模式](#b-并发模式)
    - [C. 性能基准](#c-性能基准)

---

## 1. 并发模型概览

### 1.1 OPA的并发需求

**并发场景**:

1. **多个查询并发执行**
   ```text
   Client1 → [Query] → OPA
   Client2 → [Query] → OPA  (同时)
   Client3 → [Query] → OPA
   ```

2. **查询同时Bundle更新**
   ```text
   Thread1: 执行查询（读）
   Thread2: 更新Bundle（写）
   ```

3. **并行求值**
   ```text
   单个查询的多个分支并行执行
   ```

**正确性要求**:

- ✅ **原子性**: 操作不可分割
- ✅ **一致性**: 数据始终有效
- ✅ **隔离性**: 并发操作互不干扰
- ✅ **可见性**: 写入对后续读可见

### 1.2 Go并发模型

**Goroutine**: 轻量级线程

```go
go func() {
    // 并发执行
}()
```

**Channel**: 通信机制

```go
ch := make(chan int)
go func() { ch <- 42 }()
val := <-ch
```

**CSP模型**: "不要通过共享内存来通信，而是通过通信来共享内存"

### 1.3 并发挑战

1. **竞态条件** (Race Condition)
2. **死锁** (Deadlock)
3. **活锁** (Livelock)
4. **饥饿** (Starvation)
5. **性能** (Performance)

---

## 2. 同步原语

### 2.1 Mutex

**互斥锁**: 最基本的同步原语

```go
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Get() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}
```

**性能特点**:
- ✅ 简单可靠
- ⚠️ 读也需要锁（性能差）

### 2.2 RWMutex

**读写锁**: 区分读写操作

```go
type Cache struct {
    mu    sync.RWMutex
    data  map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()  // 读锁
    defer c.mu.RUnlock()
    val, ok := c.data[key]
    return val, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.mu.Lock()   // 写锁
    defer c.mu.Unlock()
    c.data[key] = value
}
```

**性能特点**:
- ✅ 多个读者可并发
- ✅ 读多写少场景高效
- ⚠️ 写操作仍需独占

### 2.3 Channel

**消息传递**: 通过Channel通信

```go
type WorkQueue struct {
    tasks chan func()
}

func NewWorkQueue(size int) *WorkQueue {
    wq := &WorkQueue{
        tasks: make(chan func(), size),
    }
    
    // 启动工作协程
    go wq.worker()
    
    return wq
}

func (wq *WorkQueue) worker() {
    for task := range wq.tasks {
        task()
    }
}

func (wq *WorkQueue) Submit(task func()) {
    wq.tasks <- task
}
```

---

## 3. 存储并发控制

### 3.1 读写锁策略

**OPA Storage实现**:

```go
type Storage struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

// 读操作：使用读锁
func (s *Storage) Read(ctx context.Context, path []string) (interface{}, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    // 遍历路径
    node := s.data
    for _, segment := range path {
        val, ok := node[segment]
        if !ok {
            return nil, ErrNotFound
        }
        node = val.(map[string]interface{})
    }
    
    return node, nil
}

// 写操作：使用写锁
func (s *Storage) Write(ctx context.Context, path []string, value interface{}) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 更新数据
    node := s.data
    for i := 0; i < len(path)-1; i++ {
        next, ok := node[path[i]]
        if !ok {
            next = make(map[string]interface{})
            node[path[i]] = next
        }
        node = next.(map[string]interface{})
    }
    
    node[path[len(path)-1]] = value
    return nil
}
```

### 3.2 事务实现

**ACID事务**:

```go
type Transaction struct {
    store   *Storage
    writes  map[string]interface{}  // 写缓冲
    reads   map[string]interface{}  // 读集（用于冲突检测）
    version uint64                   // 事务开始时的版本号
}

func (s *Storage) Begin() *Transaction {
    s.mu.RLock()
    version := s.version
    s.mu.RUnlock()
    
    return &Transaction{
        store:   s,
        writes:  make(map[string]interface{}),
        reads:   make(map[string]interface{}),
        version: version,
    }
}

func (tx *Transaction) Read(path string) (interface{}, error) {
    // 先检查写缓冲
    if val, ok := tx.writes[path]; ok {
        return val, nil
    }
    
    // 从存储读取
    val, err := tx.store.read(path)
    if err != nil {
        return nil, err
    }
    
    // 记录读集
    tx.reads[path] = val
    
    return val, nil
}

func (tx *Transaction) Write(path string, value interface{}) {
    tx.writes[path] = value
}

func (tx *Transaction) Commit() error {
    tx.store.mu.Lock()
    defer tx.store.mu.Unlock()
    
    // 验证读集（检测冲突）
    if tx.store.version != tx.version {
        for path, oldVal := range tx.reads {
            currentVal := tx.store.data[path]
            if currentVal != oldVal {
                return ErrConflict  // 冲突，回滚
            }
        }
    }
    
    // 应用写集
    for path, val := range tx.writes {
        tx.store.data[path] = val
    }
    
    // 增加版本号
    tx.store.version++
    
    return nil
}
```

### 3.3 快照隔离

**Copy-on-Write实现**:

```go
type SnapshotStore struct {
    current  atomic.Value  // *Snapshot
}

type Snapshot struct {
    version uint64
    data    map[string]interface{}  // 不可变
}

func (s *SnapshotStore) Read() *Snapshot {
    return s.current.Load().(*Snapshot)
}

func (s *SnapshotStore) Write(updates map[string]interface{}) {
    for {
        // 读取当前快照
        old := s.current.Load().(*Snapshot)
        
        // 创建新快照（拷贝）
        newData := copyMap(old.data)
        for k, v := range updates {
            newData[k] = v
        }
        
        newSnapshot := &Snapshot{
            version: old.version + 1,
            data:    newData,
        }
        
        // CAS更新
        if s.current.CompareAndSwap(old, newSnapshot) {
            return
        }
        
        // 重试
    }
}
```

---

## 4. 无锁数据结构

### 4.1 CAS操作

**Compare-And-Swap**: 原子操作

```go
import "sync/atomic"

type AtomicInt struct {
    val int64
}

func (a *AtomicInt) Inc() {
    for {
        old := atomic.LoadInt64(&a.val)
        new := old + 1
        
        if atomic.CompareAndSwapInt64(&a.val, old, new) {
            return  // 成功
        }
        
        // 失败，重试
    }
}
```

### 4.2 无锁栈

**Treiber Stack**:

```go
type Node struct {
    value interface{}
    next  *Node
}

type LockFreeStack struct {
    head atomic.Value  // *Node
}

func (s *LockFreeStack) Push(value interface{}) {
    node := &Node{value: value}
    
    for {
        old := s.head.Load().(*Node)
        node.next = old
        
        if s.head.CompareAndSwap(old, node) {
            return
        }
    }
}

func (s *LockFreeStack) Pop() (interface{}, bool) {
    for {
        old := s.head.Load().(*Node)
        
        if old == nil {
            return nil, false
        }
        
        if s.head.CompareAndSwap(old, old.next) {
            return old.value, true
        }
    }
}
```

### 4.3 无锁队列

**Michael-Scott Queue**:

```go
type LockFreeQueue struct {
    head atomic.Value  // *Node
    tail atomic.Value  // *Node
}

func NewLockFreeQueue() *LockFreeQueue {
    sentinel := &Node{}
    q := &LockFreeQueue{}
    q.head.Store(sentinel)
    q.tail.Store(sentinel)
    return q
}

func (q *LockFreeQueue) Enqueue(value interface{}) {
    node := &Node{value: value}
    
    for {
        tail := q.tail.Load().(*Node)
        next := tail.next
        
        if next == nil {
            if atomic.CompareAndSwapPointer(
                (*unsafe.Pointer)(unsafe.Pointer(&tail.next)),
                nil,
                unsafe.Pointer(node),
            ) {
                q.tail.CompareAndSwap(tail, node)
                return
            }
        } else {
            q.tail.CompareAndSwap(tail, next)
        }
    }
}
```

---

## 5. 求值器并发

### 5.1 并行求值

**独立子查询并行化**:

```go
func (e *Evaluator) EvalParallel(queries []*Query) []*Result {
    results := make(chan *Result, len(queries))
    
    // 启动工作协程
    var wg sync.WaitGroup
    for _, query := range queries {
        wg.Add(1)
        go func(q *Query) {
            defer wg.Done()
            result := e.Eval(q)
            results <- result
        }(query)
    }
    
    // 等待完成
    wg.Wait()
    close(results)
    
    // 收集结果
    var allResults []*Result
    for result := range results {
        allResults = append(allResults, result)
    }
    
    return allResults
}
```

### 5.2 工作窃取

**Work Stealing调度器**:

```go
type WorkStealingScheduler struct {
    queues []*Deque      // 每个工作线程一个队列
    idle   chan int      // 空闲工作线程
}

func (ws *WorkStealingScheduler) Worker(id int) {
    for {
        // 从自己的队列取任务
        task := ws.queues[id].PopBottom()
        
        if task != nil {
            task.Execute()
            continue
        }
        
        // 尝试窃取其他队列的任务
        for i := 0; i < len(ws.queues); i++ {
            if i == id {
                continue
            }
            
            task = ws.queues[i].PopTop()
            if task != nil {
                task.Execute()
                break
            }
        }
        
        if task == nil {
            // 无任务，进入空闲
            ws.idle <- id
            task = <-ws.waitTask
        }
    }
}
```

### 5.3 取消机制

**Context-based Cancellation**:

```go
func (e *Evaluator) EvalWithContext(ctx context.Context, query *Query) (*Result, error) {
    resultCh := make(chan *Result, 1)
    errCh := make(chan error, 1)
    
    go func() {
        result, err := e.Eval(query)
        if err != nil {
            errCh <- err
        } else {
            resultCh <- result
        }
    }()
    
    select {
    case result := <-resultCh:
        return result, nil
    case err := <-errCh:
        return nil, err
    case <-ctx.Done():
        return nil, ctx.Err()  // 超时或取消
    }
}
```

---

## 6. 缓存同步

### 6.1 并发安全缓存

**分片缓存** (减少锁争用):

```go
type ShardedCache struct {
    shards []*CacheShard
    mask   uint32
}

type CacheShard struct {
    mu    sync.RWMutex
    data  map[string]interface{}
}

func NewShardedCache(numShards int) *ShardedCache {
    shards := make([]*CacheShard, numShards)
    for i := range shards {
        shards[i] = &CacheShard{
            data: make(map[string]interface{}),
        }
    }
    
    return &ShardedCache{
        shards: shards,
        mask:   uint32(numShards - 1),
    }
}

func (c *ShardedCache) getShard(key string) *CacheShard {
    hash := fnv.New32a()
    hash.Write([]byte(key))
    idx := hash.Sum32() & c.mask
    return c.shards[idx]
}

func (c *ShardedCache) Get(key string) (interface{}, bool) {
    shard := c.getShard(key)
    shard.mu.RLock()
    defer shard.mu.RUnlock()
    val, ok := shard.data[key]
    return val, ok
}
```

### 6.2 缓存一致性

**发布-订阅模式**:

```go
type CacheInvalidator struct {
    mu          sync.RWMutex
    subscribers []chan string
}

func (ci *CacheInvalidator) Subscribe() <-chan string {
    ch := make(chan string, 100)
    
    ci.mu.Lock()
    ci.subscribers = append(ci.subscribers, ch)
    ci.mu.Unlock()
    
    return ch
}

func (ci *CacheInvalidator) Invalidate(key string) {
    ci.mu.RLock()
    defer ci.mu.RUnlock()
    
    for _, ch := range ci.subscribers {
        select {
        case ch <- key:
        default:
            // 通道满，跳过
        }
    }
}
```

### 6.3 LRU实现

**并发安全LRU**:

```go
type LRUCache struct {
    mu       sync.Mutex
    capacity int
    cache    map[string]*list.Element
    lru      *list.List
}

type entry struct {
    key   string
    value interface{}
}

func (c *LRUCache) Get(key string) (interface{}, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if elem, ok := c.cache[key]; ok {
        c.lru.MoveToFront(elem)
        return elem.Value.(*entry).value, true
    }
    
    return nil, false
}

func (c *LRUCache) Put(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if elem, ok := c.cache[key]; ok {
        c.lru.MoveToFront(elem)
        elem.Value.(*entry).value = value
        return
    }
    
    if c.lru.Len() >= c.capacity {
        // 淘汰最久未使用
        elem := c.lru.Back()
        c.lru.Remove(elem)
        delete(c.cache, elem.Value.(*entry).key)
    }
    
    e := &entry{key, value}
    elem := c.lru.PushFront(e)
    c.cache[key] = elem
}
```

---

## 7. Bundle更新

### 7.1 热更新机制

**原子指针切换**:

```go
type BundleManager struct {
    current atomic.Value  // *Bundle
}

func (bm *BundleManager) GetBundle() *Bundle {
    return bm.current.Load().(*Bundle)
}

func (bm *BundleManager) UpdateBundle(newBundle *Bundle) {
    // 原子更新
    bm.current.Store(newBundle)
}
```

### 7.2 版本控制

**MVCC (多版本并发控制)**:

```go
type VersionedBundle struct {
    version uint64
    bundle  *Bundle
}

type BundleStore struct {
    mu       sync.RWMutex
    versions []*VersionedBundle
    latest   uint64
}

func (bs *BundleStore) GetVersion(version uint64) *Bundle {
    bs.mu.RLock()
    defer bs.mu.RUnlock()
    
    for _, vb := range bs.versions {
        if vb.version == version {
            return vb.bundle
        }
    }
    
    return nil
}

func (bs *BundleStore) AddVersion(bundle *Bundle) uint64 {
    bs.mu.Lock()
    defer bs.mu.Unlock()
    
    version := bs.latest + 1
    bs.versions = append(bs.versions, &VersionedBundle{
        version: version,
        bundle:  bundle,
    })
    bs.latest = version
    
    // 清理旧版本（保留最近N个）
    if len(bs.versions) > 10 {
        bs.versions = bs.versions[1:]
    }
    
    return version
}
```

### 7.3 原子切换

**双缓冲技术**:

```go
type DoubleBufferedBundle struct {
    buffers [2]*Bundle
    active  atomic.Value  // int (0 or 1)
}

func (db *DoubleBufferedBundle) GetActive() *Bundle {
    idx := db.active.Load().(int)
    return db.buffers[idx]
}

func (db *DoubleBufferedBundle) Update(newBundle *Bundle) {
    activeIdx := db.active.Load().(int)
    inactiveIdx := 1 - activeIdx
    
    // 更新非活跃缓冲区
    db.buffers[inactiveIdx] = newBundle
    
    // 原子切换
    db.active.Store(inactiveIdx)
}
```

---

## 8. 死锁预防

### 8.1 锁顺序

**全局锁顺序**: 总是按相同顺序获取锁

```go
type ResourceManager struct {
    resources map[string]*Resource
    mu        sync.Mutex
}

type Resource struct {
    id   string
    mu   sync.Mutex
    data interface{}
}

func (rm *ResourceManager) TransferAtomic(fromID, toID string, amount int) error {
    // 按字典序获取锁（避免死锁）
    first, second := fromID, toID
    if first > second {
        first, second = second, first
    }
    
    rm.mu.Lock()
    r1 := rm.resources[first]
    r2 := rm.resources[second]
    rm.mu.Unlock()
    
    r1.mu.Lock()
    defer r1.mu.Unlock()
    
    r2.mu.Lock()
    defer r2.mu.Unlock()
    
    // 执行转账
    return nil
}
```

### 8.2 超时机制

**带超时的锁获取**:

```go
func TryLockWithTimeout(mu *sync.Mutex, timeout time.Duration) bool {
    locked := make(chan struct{})
    
    go func() {
        mu.Lock()
        close(locked)
    }()
    
    select {
    case <-locked:
        return true
    case <-time.After(timeout):
        return false
    }
}
```

### 8.3 死锁检测

**等待图检测**:

```go
type DeadlockDetector struct {
    waitGraph map[int][]int  // goroutine_id → waiting_for
    mu        sync.Mutex
}

func (dd *DeadlockDetector) AddWait(from, to int) {
    dd.mu.Lock()
    defer dd.mu.Unlock()
    
    dd.waitGraph[from] = append(dd.waitGraph[from], to)
    
    // 检测环
    if dd.hasCycle() {
        panic("Deadlock detected!")
    }
}

func (dd *DeadlockDetector) hasCycle() bool {
    visited := make(map[int]bool)
    recStack := make(map[int]bool)
    
    for node := range dd.waitGraph {
        if dd.dfs(node, visited, recStack) {
            return true
        }
    }
    
    return false
}

func (dd *DeadlockDetector) dfs(node int, visited, recStack map[int]bool) bool {
    visited[node] = true
    recStack[node] = true
    
    for _, neighbor := range dd.waitGraph[node] {
        if !visited[neighbor] {
            if dd.dfs(neighbor, visited, recStack) {
                return true
            }
        } else if recStack[neighbor] {
            return true  // 环！
        }
    }
    
    recStack[node] = false
    return false
}
```

---

## 9. 性能优化

### 9.1 锁粒度

**细粒度锁 vs 粗粒度锁**:

```go
// 粗粒度（简单但性能差）
type CoarseCache struct {
    mu   sync.Mutex
    data map[string]interface{}
}

// 细粒度（复杂但性能好）
type FineCache struct {
    shards []*Shard
}

type Shard struct {
    mu   sync.RWMutex
    data map[string]interface{}
}
```

### 9.2 无争用快速路径

**Read-Copy-Update (RCU)**:

```go
type RCUMap struct {
    data atomic.Value  // map[string]interface{}
}

func (m *RCUMap) Read(key string) (interface{}, bool) {
    // 无锁读取
    data := m.data.Load().(map[string]interface{})
    val, ok := data[key]
    return val, ok
}

func (m *RCUMap) Write(key string, value interface{}) {
    // 写时复制
    old := m.data.Load().(map[string]interface{})
    
    newData := make(map[string]interface{}, len(old)+1)
    for k, v := range old {
        newData[k] = v
    }
    newData[key] = value
    
    m.data.Store(newData)
}
```

### 9.3 分片技术

**减少锁争用**:

```go
const NumShards = 256

type ShardedMap struct {
    shards [NumShards]struct {
        mu   sync.RWMutex
        data map[string]interface{}
    }
}

func (sm *ShardedMap) shard(key string) int {
    h := fnv.New32a()
    h.Write([]byte(key))
    return int(h.Sum32()) % NumShards
}

func (sm *ShardedMap) Get(key string) (interface{}, bool) {
    idx := sm.shard(key)
    sm.shards[idx].mu.RLock()
    defer sm.shards[idx].mu.RUnlock()
    val, ok := sm.shards[idx].data[key]
    return val, ok
}
```

---

## 10. 实战示例

### 10.1 并发查询

**场景**: 1000个并发查询

```go
func BenchmarkConcurrentQueries(b *testing.B) {
    opa := setupOPA()
    
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            result, err := opa.Eval(context.Background(), &Query{...})
            if err != nil {
                b.Fatal(err)
            }
            _ = result
        }
    })
}
```

### 10.2 并发更新

**场景**: 查询同时Bundle更新

```go
func TestConcurrentUpdate(t *testing.T) {
    opa := setupOPA()
    
    // 启动查询协程
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                _, _ = opa.Eval(context.Background(), &Query{...})
            }
        }()
    }
    
    // 同时更新Bundle
    for i := 0; i < 10; i++ {
        newBundle := loadBundle(fmt.Sprintf("bundle_v%d", i))
        opa.UpdateBundle(newBundle)
        time.Sleep(100 * time.Millisecond)
    }
    
    wg.Wait()
}
```

### 10.3 性能测试

**吞吐量测试**:

```go
func BenchmarkThroughput(b *testing.B) {
    opa := setupOPA()
    
    start := time.Now()
    
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            opa.Eval(context.Background(), &Query{...})
        }
    })
    
    elapsed := time.Since(start)
    qps := float64(b.N) / elapsed.Seconds()
    
    b.ReportMetric(qps, "queries/sec")
}
```

**结果**:

| 并发度 | QPS | 平均延迟 | P99延迟 |
|--------|-----|---------|---------|
| 1 | 1,000 | 1ms | 2ms |
| 10 | 8,000 | 1.2ms | 3ms |
| 100 | 50,000 | 2ms | 10ms |
| 1000 | 100,000 | 10ms | 50ms |

---

## 附录

### A. Go并发参考

**推荐资源**:
- [Effective Go - Concurrency](https://go.dev/doc/effective_go#concurrency)
- [Go Memory Model](https://go.dev/ref/mem)
- [Russ Cox - Go Concurrency Patterns](https://talks.golang.org/2012/concurrency.slide)

### B. 并发模式

**常用模式**:
1. **Worker Pool**: 固定数量工作协程
2. **Pipeline**: 流水线处理
3. **Fan-Out/Fan-In**: 并行处理后合并
4. **Rate Limiting**: 限速
5. **Circuit Breaker**: 熔断

### C. 性能基准

**测试命令**:

```bash
# 竞态检测
go test -race ./...

# 性能测试
go test -bench=. -benchmem

# CPU性能分析
go test -bench=. -cpuprofile=cpu.prof
go tool pprof cpu.prof
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日  
**维护者**: OPA技术文档项目

**相关阅读**:
- [并发语义与正确性](../06-形式化证明/06.8-并发语义与正确性.md) - 形式化分析
- [Go并发编程](https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/) - 深入学习
- [性能优化指南](../05-最佳实践/05.6-性能优化指南.md) - 实践建议

