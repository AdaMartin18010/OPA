# SLD-Resolutionè¯¦è§£

> **æ–‡æ¡£ç±»å‹**: ç®—æ³•æ·±åº¦åˆ†æ  
> **æ ¸å¿ƒç®—æ³•**: SLD-Resolution (Selective Linear Definite Resolution)  
> **é€‚ç”¨è¯»è€…**: ç®—æ³•ç ”ç©¶è€…ã€é€»è¾‘ç¼–ç¨‹ä¸“å®¶ã€OPAæ ¸å¿ƒå¼€å‘è€…  
> **å…ˆä¿®çŸ¥è¯†**: [å‘½é¢˜é€»è¾‘ä¸ä¸€é˜¶é€»è¾‘](../06-å½¢å¼åŒ–è¯æ˜/06.3-å‘½é¢˜é€»è¾‘ä¸ä¸€é˜¶é€»è¾‘åŸºç¡€.md)ã€[æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§](../06-å½¢å¼åŒ–è¯æ˜/06.4-æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜.md)  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 3.1 - ç®—æ³•åˆ†æ  
> **ç†è®ºåŸºç¡€**: Datalog, Prolog, Hornå­å¥

---

## ğŸ¯ æ–‡æ¡£ç›®æ ‡

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æOPAä½¿ç”¨çš„**SLD-Resolution**ç®—æ³•ï¼Œè¿™æ˜¯é€»è¾‘ç¼–ç¨‹çš„æ ¸å¿ƒæ±‚è§£æœºåˆ¶ã€‚

**æ ¸å¿ƒå†…å®¹**:

- SLD-Resolutionçš„ç†è®ºåŸºç¡€
- ç®—æ³•çš„è¯¦ç»†æ­¥éª¤å’Œæ•°æ®ç»“æ„
- é€‰æ‹©å‡½æ•°ä¸æœç´¢ç­–ç•¥
- æ­£ç¡®æ€§ä¸å®Œå¤‡æ€§åˆ†æ
- OPAä¸­çš„å…·ä½“å®ç°

**å­¦ä¹ ä»·å€¼**:

- ç†è§£é€»è¾‘ç¼–ç¨‹çš„æ‰§è¡Œæ¨¡å‹
- æŒæ¡å›æº¯æœç´¢ç®—æ³•
- ä¼˜åŒ–ç­–ç•¥æ±‚å€¼æ€§èƒ½
- å®ç°è‡ªå®šä¹‰æ±‚å€¼å™¨

---

## ç›®å½•

- [SLD-Resolutionè¯¦è§£](#sld-resolutionè¯¦è§£)
  - [ğŸ¯ æ–‡æ¡£ç›®æ ‡](#-æ–‡æ¡£ç›®æ ‡)
  - [ç›®å½•](#ç›®å½•)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [1.1 Hornå­å¥](#11-hornå­å¥)
    - [1.2 ResolutionåŸç†](#12-resolutionåŸç†)
    - [1.3 SLDçš„ç‰¹æ®Šæ€§](#13-sldçš„ç‰¹æ®Šæ€§)
  - [2. ç®—æ³•å®šä¹‰](#2-ç®—æ³•å®šä¹‰)
    - [2.1 åŸºæœ¬æ¦‚å¿µ](#21-åŸºæœ¬æ¦‚å¿µ)
    - [2.2 SLDæ¨å¯¼](#22-sldæ¨å¯¼)
    - [2.3 SLDæ ‘](#23-sldæ ‘)
  - [3. ç®—æ³•è¿‡ç¨‹](#3-ç®—æ³•è¿‡ç¨‹)
    - [3.1 åˆå§‹åŒ–](#31-åˆå§‹åŒ–)
    - [3.2 é€‰æ‹©ç›®æ ‡](#32-é€‰æ‹©ç›®æ ‡)
    - [3.3 è§„åˆ™åŒ¹é…](#33-è§„åˆ™åŒ¹é…)
    - [3.4 ç»Ÿä¸€ä¸æ›¿æ¢](#34-ç»Ÿä¸€ä¸æ›¿æ¢)
    - [3.5 ç”Ÿæˆæ–°ç›®æ ‡](#35-ç”Ÿæˆæ–°ç›®æ ‡)
  - [4. é€‰æ‹©å‡½æ•°](#4-é€‰æ‹©å‡½æ•°)
    - [4.1 Prologçš„å·¦ä¼˜å…ˆç­–ç•¥](#41-prologçš„å·¦ä¼˜å…ˆç­–ç•¥)
    - [4.2 OPAçš„é€‰æ‹©ç­–ç•¥](#42-opaçš„é€‰æ‹©ç­–ç•¥)
    - [4.3 æ™ºèƒ½é€‰æ‹©ä¼˜åŒ–](#43-æ™ºèƒ½é€‰æ‹©ä¼˜åŒ–)
  - [5. æœç´¢ç­–ç•¥](#5-æœç´¢ç­–ç•¥)
    - [5.1 æ·±åº¦ä¼˜å…ˆæœç´¢](#51-æ·±åº¦ä¼˜å…ˆæœç´¢)
    - [5.2 å¹¿åº¦ä¼˜å…ˆæœç´¢](#52-å¹¿åº¦ä¼˜å…ˆæœç´¢)
    - [5.3 è¿­ä»£åŠ æ·±](#53-è¿­ä»£åŠ æ·±)
  - [6. å›æº¯æœºåˆ¶](#6-å›æº¯æœºåˆ¶)
    - [6.1 é€‰æ‹©ç‚¹](#61-é€‰æ‹©ç‚¹)
    - [6.2 å›æº¯æ ˆ](#62-å›æº¯æ ˆ)
    - [6.3 å‰ªæä¼˜åŒ–](#63-å‰ªæä¼˜åŒ–)
  - [7. æ­£ç¡®æ€§åˆ†æ](#7-æ­£ç¡®æ€§åˆ†æ)
    - [7.1 å¯é æ€§å®šç†](#71-å¯é æ€§å®šç†)
    - [7.2 å®Œå¤‡æ€§å®šç†](#72-å®Œå¤‡æ€§å®šç†)
    - [7.3 ç»ˆæ­¢æ€§åˆ†æ](#73-ç»ˆæ­¢æ€§åˆ†æ)
  - [8. å¤æ‚åº¦åˆ†æ](#8-å¤æ‚åº¦åˆ†æ)
    - [8.1 æ—¶é—´å¤æ‚åº¦](#81-æ—¶é—´å¤æ‚åº¦)
    - [8.2 ç©ºé—´å¤æ‚åº¦](#82-ç©ºé—´å¤æ‚åº¦)
    - [8.3 æœ€åæƒ…å†µ](#83-æœ€åæƒ…å†µ)
  - [9. OPAä¸­çš„å®ç°](#9-opaä¸­çš„å®ç°)
    - [9.1 æ•°æ®ç»“æ„](#91-æ•°æ®ç»“æ„)
    - [9.2 æ±‚å€¼å¾ªç¯](#92-æ±‚å€¼å¾ªç¯)
    - [9.3 ä¼˜åŒ–æŠ€æœ¯](#93-ä¼˜åŒ–æŠ€æœ¯)
  - [10. å®æˆ˜ç¤ºä¾‹](#10-å®æˆ˜ç¤ºä¾‹)
    - [10.1 ç®€å•æŸ¥è¯¢](#101-ç®€å•æŸ¥è¯¢)
    - [10.2 é€’å½’æŸ¥è¯¢](#102-é€’å½’æŸ¥è¯¢)
    - [10.3 å¦å®šæŸ¥è¯¢](#103-å¦å®šæŸ¥è¯¢)
  - [é™„å½•](#é™„å½•)
    - [A. å½¢å¼åŒ–å®šä¹‰](#a-å½¢å¼åŒ–å®šä¹‰)
    - [B. è¯æ˜ç»†èŠ‚](#b-è¯æ˜ç»†èŠ‚)
    - [C. æ€§èƒ½å¯¹æ¯”](#c-æ€§èƒ½å¯¹æ¯”)

---

## 1. ç†è®ºåŸºç¡€

### 1.1 Hornå­å¥

**å®šä¹‰**:

Hornå­å¥æ˜¯ä¸€é˜¶é€»è¾‘ä¸­çš„ç‰¹æ®Šå­å¥å½¢å¼ï¼š

```text
H â† Bâ‚, Bâ‚‚, ..., Bâ‚™
```

å…¶ä¸­ï¼š

- `H`: å¤´éƒ¨ï¼ˆHeadï¼‰ï¼Œä¸€ä¸ªåŸå­
- `Báµ¢`: ä½“éƒ¨ï¼ˆBodyï¼‰ï¼ŒåŸå­çš„åˆå–

**ä¸‰ç§å½¢å¼**:

1. **ç¡®å®šå­å¥** (Definite Clause): `H â† Bâ‚, ..., Bâ‚™` (n â‰¥ 0)
2. **ç›®æ ‡å­å¥** (Goal Clause): `â† Bâ‚, ..., Bâ‚™` (æ— å¤´éƒ¨)
3. **å•å…ƒå­å¥** (Unit Clause): `H â†` (æ— ä½“éƒ¨ï¼Œäº‹å®)

**ç¤ºä¾‹**:

```prolog
% äº‹å®ï¼ˆå•å…ƒå­å¥ï¼‰
parent(tom, bob).
parent(bob, ann).

% è§„åˆ™ï¼ˆç¡®å®šå­å¥ï¼‰
grandparent(X, Z) :- parent(X, Y), parent(Y, Z).

% æŸ¥è¯¢ï¼ˆç›®æ ‡å­å¥ï¼‰
?- grandparent(tom, ann).
```

### 1.2 ResolutionåŸç†

**Resolutionè§„åˆ™**:

ç»™å®šä¸¤ä¸ªå­å¥ï¼š

- `Câ‚ = H âˆ¨ Lâ‚ âˆ¨ ... âˆ¨ Lâ‚˜`
- `Câ‚‚ = Â¬H âˆ¨ Kâ‚ âˆ¨ ... âˆ¨ Kâ‚™`

å¯ä»¥æ¨å¯¼å‡ºï¼š

- `R = (Lâ‚ âˆ¨ ... âˆ¨ Lâ‚˜ âˆ¨ Kâ‚ âˆ¨ ... âˆ¨ Kâ‚™)Ïƒ`

å…¶ä¸­`Ïƒ`æ˜¯ä½¿`H`å’Œ`Â¬H`ç»Ÿä¸€çš„æœ€ä¸€èˆ¬ç»Ÿä¸€å­ï¼ˆMGUï¼‰ã€‚

**Hornå­å¥çš„Resolution**:

å¯¹äºHornå­å¥ï¼ŒResolutionæœ‰ç‰¹æ®Šæ€§è´¨ï¼š

```text
Câ‚: H â† Bâ‚, ..., Bâ‚˜
Câ‚‚: â† Gâ‚, ..., H, ..., Gâ‚™  (Håœ¨æŸä¸ªä½ç½®)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
R:  â† Gâ‚, ..., Bâ‚, ..., Bâ‚˜, ..., Gâ‚™
```

### 1.3 SLDçš„ç‰¹æ®Šæ€§

**SLD = Selective Linear Definite Resolution**:

- **Selective**: æ¯æ¬¡åªé€‰æ‹©ç›®æ ‡ä¸­çš„ä¸€ä¸ªåŸå­
- **Linear**: å§‹ç»ˆä½¿ç”¨ä¸€ä¸ªç›®æ ‡å­å¥
- **Definite**: åªé€‚ç”¨äºHornå­å¥

**ç‰¹ç‚¹**:

1. âœ… **ç®€å•**: ç®—æ³•ç›´è§‚ï¼Œæ˜“äºå®ç°
2. âœ… **é«˜æ•ˆ**: é¿å…äº†ä¸€èˆ¬Resolutionçš„æœç´¢ç©ºé—´çˆ†ç‚¸
3. âœ… **å®Œå¤‡**: å¯¹äºHornå­å¥ï¼Œä¿è¯æ‰¾åˆ°æ‰€æœ‰ç­”æ¡ˆ
4. âš ï¸ **é™åˆ¶**: åªé€‚ç”¨äºHornå­å¥

---

## 2. ç®—æ³•å®šä¹‰

### 2.1 åŸºæœ¬æ¦‚å¿µ

**ç¨‹åºï¼ˆProgramï¼‰**:

```text
P = {Câ‚, Câ‚‚, ..., Câ‚™}
```

å…¶ä¸­æ¯ä¸ª`Cáµ¢`æ˜¯ç¡®å®šå­å¥ã€‚

**ç›®æ ‡ï¼ˆGoalï¼‰**:

```text
G = â† Aâ‚, Aâ‚‚, ..., Aâ‚˜
```

**ç­”æ¡ˆæ›¿æ¢ï¼ˆAnswer Substitutionï¼‰**:

å¦‚æœä»`G`æ¨å¯¼å‡ºç©ºå­å¥ï¼Œåˆ™ç´¯ç§¯çš„æ›¿æ¢`Î¸`æ˜¯ç­”æ¡ˆã€‚

### 2.2 SLDæ¨å¯¼

**å®šä¹‰**:

ç»™å®šç¨‹åº`P`å’Œç›®æ ‡`G = â† Aâ‚, ..., Aáµ¢, ..., Aâ‚˜`ï¼š

1. **é€‰æ‹©**ç›®æ ‡ä¸­çš„åŸå­`Aáµ¢`
2. **åŒ¹é…**ç¨‹åºä¸­çš„å­å¥`C = H â† Bâ‚, ..., Bâ‚™`
3. **ç»Ÿä¸€** `Aáµ¢`å’Œ`H`ï¼Œå¾—åˆ°MGU `Î¸`
4. **æ›¿æ¢**äº§ç”Ÿæ–°ç›®æ ‡: `G' = (â† Aâ‚, ..., Aáµ¢â‚‹â‚, Bâ‚, ..., Bâ‚™, Aáµ¢â‚Šâ‚, ..., Aâ‚˜)Î¸`

**æ¨å¯¼åºåˆ—**:

```text
Gâ‚€ âŸ¹á¶œÂ¹'á¶¿Â¹ Gâ‚ âŸ¹á¶œÂ²'á¶¿Â² Gâ‚‚ âŸ¹ ... âŸ¹á¶œâ¿'á¶¿â¿ Gâ‚™
```

å…¶ä¸­ï¼š

- `Gáµ¢`æ˜¯ç›®æ ‡
- `Câ±`æ˜¯ä½¿ç”¨çš„å­å¥
- `Î¸â±`æ˜¯ç»Ÿä¸€æ›¿æ¢

**æˆåŠŸæ¨å¯¼**:

å¦‚æœ`Gâ‚™ = â–¡`ï¼ˆç©ºå­å¥ï¼‰ï¼Œåˆ™æ¨å¯¼æˆåŠŸï¼Œç­”æ¡ˆæ˜¯`Î¸ = Î¸â‚Î¸â‚‚...Î¸â‚™`ã€‚

### 2.3 SLDæ ‘

**å®šä¹‰**:

SLDæ ‘æ˜¯æ‰€æœ‰å¯èƒ½SLDæ¨å¯¼çš„æœç´¢ç©ºé—´ï¼š

```text
                 Gâ‚€
               /  |  \
             /    |    \
           Gâ‚    Gâ‚'   Gâ‚''
          / \     |     ...
        /    \    |
      Gâ‚‚     Gâ‚‚' Gâ‚‚''
      |       |    ...
     â–¡       ...
  (æˆåŠŸ)
```

**èŠ‚ç‚¹**:

- æ ¹èŠ‚ç‚¹ï¼šåˆå§‹ç›®æ ‡
- å†…éƒ¨èŠ‚ç‚¹ï¼šä¸­é—´ç›®æ ‡
- å¶èŠ‚ç‚¹ï¼šç©ºå­å¥ï¼ˆæˆåŠŸï¼‰æˆ–å¤±è´¥

**è¾¹**:

- æ ‡è®°ä¸º`(C, Î¸)`ï¼Œè¡¨ç¤ºä½¿ç”¨å­å¥`C`å’Œæ›¿æ¢`Î¸`

**å®Œå¤‡æ€§**:

å¦‚æœç­”æ¡ˆå­˜åœ¨ï¼Œåˆ™åœ¨SLDæ ‘çš„æŸæ¡åˆ†æ”¯ä¸Šã€‚

---

## 3. ç®—æ³•è¿‡ç¨‹

### 3.1 åˆå§‹åŒ–

```text
è¾“å…¥: 
  - ç¨‹åº P = {Câ‚, ..., Câ‚™}
  - æŸ¥è¯¢ Q = ?- Aâ‚, ..., Aâ‚˜

åˆå§‹åŒ–:
  - å½“å‰ç›®æ ‡: G = â† Aâ‚, ..., Aâ‚˜
  - ç­”æ¡ˆæ›¿æ¢: Î¸ = âˆ… (ç©º)
  - å›æº¯æ ˆ: Stack = []
```

### 3.2 é€‰æ‹©ç›®æ ‡

**é€‰æ‹©å‡½æ•°** `select(G)`:

ä»ç›®æ ‡`G = â† Aâ‚, ..., Aâ‚˜`ä¸­é€‰æ‹©ä¸€ä¸ªåŸå­`Aáµ¢`ã€‚

**å¸¸è§ç­–ç•¥**:

1. **å·¦ä¼˜å…ˆ**: æ€»æ˜¯é€‰æ‹©æœ€å·¦è¾¹çš„åŸå­ï¼ˆPrologï¼‰
2. **å³ä¼˜å…ˆ**: æ€»æ˜¯é€‰æ‹©æœ€å³è¾¹çš„åŸå­
3. **æ™ºèƒ½é€‰æ‹©**: æ ¹æ®å¯å‘å¼é€‰æ‹©

**ç¤ºä¾‹**:

```text
G = â† parent(X, Y), parent(Y, ann)
select(G) = parent(X, Y)  // å·¦ä¼˜å…ˆ
```

### 3.3 è§„åˆ™åŒ¹é…

**åŒ¹é…è¿‡ç¨‹**:

ç»™å®šé€‰ä¸­çš„åŸå­`A`ï¼ŒæŸ¥æ‰¾ç¨‹åºä¸­æ‰€æœ‰å¯åŒ¹é…çš„å­å¥ï¼š

```text
matches(A, P) = { C âˆˆ P | head(C)å’ŒAå¯ç»Ÿä¸€ }
```

**ç¤ºä¾‹**:

```text
A = parent(tom, Y)

Pä¸­çš„å­å¥:
  Câ‚: parent(tom, bob) â†
  Câ‚‚: parent(bob, ann) â†
  Câ‚ƒ: parent(X, Z) â† father(X, Z)

matches(A, P) = {Câ‚, Câ‚ƒ}
```

### 3.4 ç»Ÿä¸€ä¸æ›¿æ¢

**ç»Ÿä¸€ç®—æ³•** (è¯¦è§[Robinsonç»Ÿä¸€ç®—æ³•](11.2-Robinsonç»Ÿä¸€ç®—æ³•.md)):

```text
unify(A, head(C)) = Î¸ (MGU) or fail
```

**åº”ç”¨æ›¿æ¢**:

```text
G' = (G - {A} âˆª body(C))Î¸
```

**ç¤ºä¾‹**:

```text
A = parent(tom, Y)
C = parent(tom, bob) â†

Î¸ = unify(A, parent(tom, bob))
  = {Y/bob}

æ–°ç›®æ ‡: G' = GÎ¸ (å…¶ä¸­Yè¢«æ›¿æ¢ä¸ºbob)
```

### 3.5 ç”Ÿæˆæ–°ç›®æ ‡

**æ›¿æ¢è§„åˆ™**:

```text
G = â† Aâ‚, ..., Aáµ¢, ..., Aâ‚˜
C = H â† Bâ‚, ..., Bâ‚™
Î¸ = unify(Aáµ¢, H)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
G' = (â† Aâ‚, ..., Aáµ¢â‚‹â‚, Bâ‚, ..., Bâ‚™, Aáµ¢â‚Šâ‚, ..., Aâ‚˜)Î¸
```

**ç‰¹æ®Šæƒ…å†µ**:

1. **ç©ºä½“éƒ¨**: `C = H â†`, åˆ™`G' = (G - {Aáµ¢})Î¸`
2. **ç©ºç›®æ ‡**: `G' = â†`, æ¨å¯¼æˆåŠŸ
3. **æ— åŒ¹é…**: å›æº¯

---

## 4. é€‰æ‹©å‡½æ•°

### 4.1 Prologçš„å·¦ä¼˜å…ˆç­–ç•¥

**å®šä¹‰**:

```text
select(â† Aâ‚, ..., Aâ‚˜) = Aâ‚
```

æ€»æ˜¯é€‰æ‹©æœ€å·¦è¾¹çš„åŸå­ã€‚

**ä¼˜ç‚¹**:

- âœ… ç®€å•ç¡®å®š
- âœ… å°¾é€’å½’ä¼˜åŒ–
- âœ… æ˜“äºç†è§£å’Œè°ƒè¯•

**ç¼ºç‚¹**:

- âš ï¸ å¯èƒ½é™·å…¥æ— é™å¾ªç¯
- âš ï¸ ä¸æ˜¯æœ€ä¼˜é€‰æ‹©

**ç¤ºä¾‹é—®é¢˜**:

```prolog
% å·¦é€’å½’è§„åˆ™
path(X, Y) :- edge(X, Y).
path(X, Y) :- path(X, Z), edge(Z, Y).

% æŸ¥è¯¢ä¼šæ— é™å¾ªç¯
?- path(a, b).
```

### 4.2 OPAçš„é€‰æ‹©ç­–ç•¥

OPAä½¿ç”¨**æ™ºèƒ½é€‰æ‹©**ç­–ç•¥ï¼š

**å¯å‘å¼è§„åˆ™**:

1. **ä¼˜å…ˆGroundåŸå­**: å®Œå…¨ç¡®å®šçš„åŸå­
2. **ç´¢å¼•æ”¯æŒ**: æœ‰ç´¢å¼•å¯ç”¨çš„åŸå­
3. **ä¼°è®¡åŸºæ•°**: é¢„æœŸç»“æœå°‘çš„åŸå­
4. **ä¾èµ–é¡ºåº**: æ»¡è¶³å˜é‡ä¾èµ–

**ä¼ªä»£ç **:

```go
func selectBest(goals []Goal) Goal {
    var best Goal
    bestScore := -1
    
    for _, goal := range goals {
        score := 0
        
        if goal.IsGround() {
            score += 1000
        }
        
        if hasIndex(goal) {
            score += 500
        }
        
        score += (1000 - estimateCardinality(goal))
        
        if score > bestScore {
            bestScore = score
            best = goal
        }
    }
    
    return best
}
```

### 4.3 æ™ºèƒ½é€‰æ‹©ä¼˜åŒ–

**åŠ¨æ€é‡æ’åº**:

åœ¨æ±‚å€¼è¿‡ç¨‹ä¸­ï¼Œæ ¹æ®å·²çŸ¥ç»‘å®šåŠ¨æ€è°ƒæ•´åŸå­é¡ºåºã€‚

**ç¤ºä¾‹**:

```text
åˆå§‹ç›®æ ‡: â† expensive(X), cheap(X)

å¦‚æœcheap(X)æ›´é«˜æ•ˆ:
é‡æ’åºä¸º: â† cheap(X), expensive(X)

æ±‚å€¼cheap(X)åï¼ŒXå·²ç»‘å®š:
æ‰§è¡Œ: expensive(known_value)  // æ›´å¿«
```

---

## 5. æœç´¢ç­–ç•¥

### 5.1 æ·±åº¦ä¼˜å…ˆæœç´¢

**Prologå’ŒOPAé»˜è®¤ç­–ç•¥**:

**ç®—æ³•**:

```text
DFS(G):
  if G = â–¡:
    return success
  
  A = select(G)
  
  for each C in matches(A, P):
    Î¸ = unify(A, head(C))
    if Î¸ â‰  fail:
      G' = resolve(G, A, C, Î¸)
      if DFS(G') = success:
        return success
  
  return fail
```

**ç‰¹ç‚¹**:

- âœ… ç©ºé—´å¤æ‚åº¦ä½ O(æ·±åº¦)
- âœ… æ‰¾åˆ°ç¬¬ä¸€ä¸ªç­”æ¡ˆå¿«
- âš ï¸ å¯èƒ½é™·å…¥æ— é™æ·±åº¦
- âš ï¸ ä¸ä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£

### 5.2 å¹¿åº¦ä¼˜å…ˆæœç´¢

**ç®—æ³•**:

```text
BFS(Gâ‚€):
  queue = [Gâ‚€]
  
  while queue not empty:
    G = queue.dequeue()
    
    if G = â–¡:
      return success
    
    A = select(G)
    
    for each C in matches(A, P):
      Î¸ = unify(A, head(C))
      if Î¸ â‰  fail:
        G' = resolve(G, A, C, Î¸)
        queue.enqueue(G')
  
  return fail
```

**ç‰¹ç‚¹**:

- âœ… å®Œå¤‡æ€§ï¼šæ€»èƒ½æ‰¾åˆ°æœ€çŸ­ç­”æ¡ˆ
- âœ… ä¸ä¼šé™·å…¥æ— é™æ·±åº¦
- âš ï¸ ç©ºé—´å¤æ‚åº¦é«˜ O(åˆ†æ”¯^æ·±åº¦)

### 5.3 è¿­ä»£åŠ æ·±

**ç»“åˆDFSå’ŒBFSä¼˜ç‚¹**:

```text
IDDFS(Gâ‚€):
  for depth = 0 to âˆ:
    if DFS_Limited(Gâ‚€, depth) = success:
      return success
  
  return fail
```

**ç‰¹ç‚¹**:

- âœ… ç©ºé—´å¤æ‚åº¦ä½ï¼ˆå¦‚DFSï¼‰
- âœ… å®Œå¤‡æ€§ï¼ˆå¦‚BFSï¼‰
- âš ï¸ é‡å¤è®¡ç®—

---

## 6. å›æº¯æœºåˆ¶

### 6.1 é€‰æ‹©ç‚¹

**å®šä¹‰**:

å½“ä¸€ä¸ªåŸå­æœ‰å¤šä¸ªåŒ¹é…å­å¥æ—¶ï¼Œåˆ›å»ºé€‰æ‹©ç‚¹ã€‚

**é€‰æ‹©ç‚¹ç»“æ„**:

```go
type ChoicePoint struct {
    Goal         Goal            // å½“å‰ç›®æ ‡
    Atom         Atom            // é€‰ä¸­çš„åŸå­
    Clauses      []Clause        // å¯é€‰å­å¥
    CurrentIndex int             // å½“å‰å°è¯•çš„ç´¢å¼•
    Substitution Substitution    // å½“å‰æ›¿æ¢
}
```

### 6.2 å›æº¯æ ˆ

**å®ç°**:

```go
type BacktrackStack struct {
    stack []ChoicePoint
}

func (bs *BacktrackStack) Push(cp ChoicePoint) {
    bs.stack = append(bs.stack, cp)
}

func (bs *BacktrackStack) Pop() (ChoicePoint, bool) {
    if len(bs.stack) == 0 {
        return ChoicePoint{}, false
    }
    
    cp := bs.stack[len(bs.stack)-1]
    bs.stack = bs.stack[:len(bs.stack)-1]
    return cp, true
}

func (bs *BacktrackStack) Backtrack() bool {
    for {
        cp, ok := bs.Pop()
        if !ok {
            return false  // æ²¡æœ‰æ›´å¤šé€‰æ‹©ç‚¹
        }
        
        cp.CurrentIndex++
        
        if cp.CurrentIndex < len(cp.Clauses) {
            // è¿˜æœ‰æœªå°è¯•çš„å­å¥
            bs.Push(cp)
            return true
        }
        
        // æ­¤é€‰æ‹©ç‚¹å·²ç©·å°½ï¼Œç»§ç»­å›æº¯
    }
}
```

### 6.3 å‰ªæä¼˜åŒ–

**Cutæ“ä½œ** (!):

Prologçš„cutæ“ä½œå‰ªé™¤å½“å‰é€‰æ‹©ç‚¹ä¹‹åçš„æ‰€æœ‰åˆ†æ”¯ã€‚

**æ•ˆæœ**:

```prolog
max(X, Y, X) :- X >= Y, !.
max(X, Y, Y).

% æŸ¥è¯¢: max(5, 3, Z)
% ç¬¬ä¸€ä¸ªå­å¥æˆåŠŸåï¼Œ!é˜»æ­¢å°è¯•ç¬¬äºŒä¸ªå­å¥
```

**å®ç°**:

```go
func Cut(stack *BacktrackStack, cutPoint int) {
    // ç§»é™¤cutPointä¹‹åçš„æ‰€æœ‰é€‰æ‹©ç‚¹
    stack.stack = stack.stack[:cutPoint]
}
```

---

## 7. æ­£ç¡®æ€§åˆ†æ

### 7.1 å¯é æ€§å®šç†

**å®šç†** (Soundness):

å¦‚æœå­˜åœ¨ä»ç›®æ ‡`G`åˆ°ç©ºå­å¥çš„SLDæ¨å¯¼ï¼Œä¸”ç­”æ¡ˆæ›¿æ¢ä¸º`Î¸`ï¼Œåˆ™`GÎ¸`åœ¨ç¨‹åº`P`çš„è¯­ä¹‰ä¸‹ä¸ºçœŸã€‚

**è¯æ˜æ€è·¯**:

1. å½’çº³SLDæ¨å¯¼çš„æ­¥æ•°
2. æ¯æ­¥Resolutionä¿æŒé€»è¾‘è•´å«å…³ç³»
3. ç©ºå­å¥è¡¨ç¤ºæ‰€æœ‰ç›®æ ‡å·²æ»¡è¶³

### 7.2 å®Œå¤‡æ€§å®šç†

**å®šç†** (Completeness):

å¦‚æœ`GÎ¸`åœ¨ç¨‹åº`P`çš„è¯­ä¹‰ä¸‹ä¸ºçœŸï¼Œåˆ™å­˜åœ¨ä»`G`åˆ°ç©ºå­å¥çš„SLDæ¨å¯¼ï¼Œä¸”ç­”æ¡ˆæ›¿æ¢`Ïƒ â‰¤ Î¸`ï¼ˆ`Ïƒ`æ›´ä¸€èˆ¬ï¼‰ã€‚

**æ³¨æ„**: å®Œå¤‡æ€§ä¾èµ–äºé€‰æ‹©å‡½æ•°çš„å…¬å¹³æ€§ã€‚

### 7.3 ç»ˆæ­¢æ€§åˆ†æ

**é—®é¢˜**: SLD-Resolutionä¸ä¿è¯ç»ˆæ­¢ã€‚

**å¯¼è‡´éç»ˆæ­¢çš„æƒ…å†µ**:

1. **å·¦é€’å½’**:

    ```prolog
    ancestor(X, Y) :- ancestor(X, Z), parent(Z, Y).
    ancestor(X, Y) :- parent(X, Y).
    ```

2. **æ— é™æ•°æ®ç»“æ„**:

    ```prolog
    nat(0).
    nat(s(X)) :- nat(X).
    ```

**è§£å†³æ–¹æ¡ˆ**:

- å¾ªç¯æ£€æµ‹
- æ·±åº¦é™åˆ¶
- é‡å†™è§„åˆ™ï¼ˆæ¶ˆé™¤å·¦é€’å½’ï¼‰

---

## 8. å¤æ‚åº¦åˆ†æ

### 8.1 æ—¶é—´å¤æ‚åº¦

**æœ€åæƒ…å†µ**: O(b^d)

å…¶ä¸­ï¼š

- `b`: åˆ†æ”¯å› å­ï¼ˆå¹³å‡åŒ¹é…å­å¥æ•°ï¼‰
- `d`: æ¨å¯¼æ·±åº¦

**å¹³å‡æƒ…å†µ**: ä¾èµ–äºç¨‹åºç»“æ„å’Œé€‰æ‹©ç­–ç•¥

### 8.2 ç©ºé—´å¤æ‚åº¦

**DFS**: O(d)
**BFS**: O(b^d)

### 8.3 æœ€åæƒ…å†µ

**æŒ‡æ•°çˆ†ç‚¸**:

```prolog
p :- q, q.
q :- q.
q.

% æŸ¥è¯¢?- p. ä¼šäº§ç”ŸæŒ‡æ•°çº§é€‰æ‹©
```

---

## 9. OPAä¸­çš„å®ç°

### 9.1 æ•°æ®ç»“æ„

```go
// Goal: ç›®æ ‡
type Goal struct {
    Literals []Literal
}

// Clause: å­å¥
type Clause struct {
    Head Literal
    Body []Literal
}

// Substitution: æ›¿æ¢
type Substitution map[Var]Term
```

### 9.2 æ±‚å€¼å¾ªç¯

```go
func Eval(program []Clause, goal Goal) []Substitution {
    var results []Substitution
    stack := NewBacktrackStack()
    theta := NewSubstitution()
    
    for {
        if goal.IsEmpty() {
            // æˆåŠŸ
            results = append(results, theta)
            
            if !stack.Backtrack() {
                break
            }
            continue
        }
        
        // é€‰æ‹©åŸå­
        atom := SelectBest(goal)
        
        // åŒ¹é…å­å¥
        clauses := Match(atom, program)
        
        if len(clauses) == 0 {
            // å¤±è´¥ï¼Œå›æº¯
            if !stack.Backtrack() {
                break
            }
            continue
        }
        
        // åˆ›å»ºé€‰æ‹©ç‚¹
        if len(clauses) > 1 {
            stack.Push(ChoicePoint{
                Goal:    goal,
                Atom:    atom,
                Clauses: clauses[1:],
                Theta:   theta,
            })
        }
        
        // å°è¯•ç¬¬ä¸€ä¸ªå­å¥
        clause := clauses[0]
        mgu := Unify(atom, clause.Head)
        
        if mgu == nil {
            // ç»Ÿä¸€å¤±è´¥
            if !stack.Backtrack() {
                break
            }
            continue
        }
        
        // æ›´æ–°ç›®æ ‡å’Œæ›¿æ¢
        goal = Resolve(goal, atom, clause, mgu)
        theta = Compose(theta, mgu)
    }
    
    return results
}
```

### 9.3 ä¼˜åŒ–æŠ€æœ¯

1. **ç´¢å¼•**: å¿«é€ŸæŸ¥æ‰¾åŒ¹é…å­å¥
2. **ç¼“å­˜**: è®°å¿†åŒ–å·²è®¡ç®—ç»“æœ
3. **å¹¶è¡Œ**: å¤šçº¿ç¨‹æ¢ç´¢ä¸åŒåˆ†æ”¯
4. **å‰ªæ**: æå‰æ’é™¤ä¸å¯èƒ½çš„åˆ†æ”¯

---

## 10. å®æˆ˜ç¤ºä¾‹

### 10.1 ç®€å•æŸ¥è¯¢

**ç¨‹åº**:

```prolog
parent(tom, bob).
parent(bob, ann).
grandparent(X, Z) :- parent(X, Y), parent(Y, Z).
```

**æŸ¥è¯¢**: `?- grandparent(tom, ann).`

**SLDæ¨å¯¼**:

```text
Gâ‚€ = â† grandparent(tom, ann)

åŒ¹é…: grandparent(X, Z) :- parent(X, Y), parent(Y, Z)
Î¸â‚ = {X/tom, Z/ann}

Gâ‚ = â† parent(tom, Y), parent(Y, ann)

åŒ¹é…: parent(tom, bob)
Î¸â‚‚ = {Y/bob}

Gâ‚‚ = â† parent(bob, ann)

åŒ¹é…: parent(bob, ann)
Î¸â‚ƒ = {}

Gâ‚ƒ = â–¡ (æˆåŠŸ!)

ç­”æ¡ˆ: Î¸ = {X/tom, Y/bob, Z/ann}
```

### 10.2 é€’å½’æŸ¥è¯¢

**ç¨‹åº**:

```prolog
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).

parent(a, b).
parent(b, c).
parent(c, d).
```

**æŸ¥è¯¢**: `?- ancestor(a, d).`

**SLDæ ‘** (éƒ¨åˆ†):

```text
â† ancestor(a, d)
â”œâ”€[ä½¿ç”¨è§„åˆ™1] â† parent(a, d) [å¤±è´¥]
â””â”€[ä½¿ç”¨è§„åˆ™2] â† parent(a, Zâ‚), ancestor(Zâ‚, d)
   â””â”€[Zâ‚=b] â† ancestor(b, d)
      â”œâ”€[ä½¿ç”¨è§„åˆ™1] â† parent(b, d) [å¤±è´¥]
      â””â”€[ä½¿ç”¨è§„åˆ™2] â† parent(b, Zâ‚‚), ancestor(Zâ‚‚, d)
         â””â”€[Zâ‚‚=c] â† ancestor(c, d)
            â”œâ”€[ä½¿ç”¨è§„åˆ™1] â† parent(c, d)
            â”‚  â””â”€[æˆåŠŸ] â–¡
            â””â”€[ä½¿ç”¨è§„åˆ™2] ...
```

### 10.3 å¦å®šæŸ¥è¯¢

**ç¨‹åº**:

```prolog
employee(alice).
employee(bob).
manager(alice).

non_manager(X) :- employee(X), \+ manager(X).
```

**æŸ¥è¯¢**: `?- non_manager(bob).`

**NAFå®ç°** (Negation as Failure):

```text
Gâ‚€ = â† non_manager(bob)

Gâ‚ = â† employee(bob), \+ manager(bob)

Gâ‚‚ = â† \+ manager(bob)  (employee(bob)æˆåŠŸ)

å°è¯•è¯æ˜: â† manager(bob) [å¤±è´¥]

å› æ­¤: \+ manager(bob) æˆåŠŸ

Gâ‚ƒ = â–¡ (æˆåŠŸ!)
```

---

## é™„å½•

### A. å½¢å¼åŒ–å®šä¹‰

**SLDæ¨å¯¼æ­¥éª¤**:

```text
âŸ¨G, C, Î¸âŸ© âˆˆ SLD-Step(P) âŸº
  âˆƒA âˆˆ G, âˆƒC âˆˆ P, âˆƒÎ¸ = mgu(A, head(C)) :
    G' = (G \ {A} âˆª body(C))Î¸
```

### B. è¯æ˜ç»†èŠ‚

è¯¦ç»†çš„å¯é æ€§å’Œå®Œå¤‡æ€§è¯æ˜è§[æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜](../06-å½¢å¼åŒ–è¯æ˜/06.4-æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜.md)ã€‚

### C. æ€§èƒ½å¯¹æ¯”

**ä¸åŒç­–ç•¥çš„æ€§èƒ½å¯¹æ¯”**:

| ç­–ç•¥ | æ—¶é—´ | ç©ºé—´ | å®Œå¤‡æ€§ |
|------|------|------|--------|
| DFS  | O(b^d) | O(d) | âŒ |
| BFS  | O(b^d) | O(b^d) | âœ… |
| IDDFS | O(b^d) | O(d) | âœ… |
| A*   | O(b^d) | O(b^d) | âœ… |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
**ç»´æŠ¤è€…**: OPAæŠ€æœ¯æ–‡æ¡£é¡¹ç›®

**ç›¸å…³é˜…è¯»**:

- [Robinsonç»Ÿä¸€ç®—æ³•](11.2-Robinsonç»Ÿä¸€ç®—æ³•.md) - ç»Ÿä¸€ç®—æ³•è¯¦è§£
- [æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜](../06-å½¢å¼åŒ–è¯æ˜/06.4-æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜.md) - å½¢å¼åŒ–è¯æ˜
- [Top-Downæ±‚å€¼å™¨æºç ](../10-æºç åˆ†æ/10.5-Top-Downæ±‚å€¼å™¨æºç .md) - å®ç°ç»†èŠ‚
