# Robinsonç»Ÿä¸€ç®—æ³•

> **æ–‡æ¡£ç±»å‹**: ç®—æ³•æ·±åº¦åˆ†æ  
> **æ ¸å¿ƒç®—æ³•**: Robinson Unification Algorithm  
> **é€‚ç”¨è¯»è€…**: ç®—æ³•ç ”ç©¶è€…ã€é€»è¾‘ç¼–ç¨‹ä¸“å®¶ã€ç±»å‹ç³»ç»Ÿå¼€å‘è€…  
> **å…ˆä¿®çŸ¥è¯†**: [ä¸€é˜¶é€»è¾‘](../06-å½¢å¼åŒ–è¯æ˜/06.3-å‘½é¢˜é€»è¾‘ä¸ä¸€é˜¶é€»è¾‘åŸºç¡€.md)ã€[SLD-Resolution](11.1-SLD-Resolutionè¯¦è§£.md)  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 3.2 - ç®—æ³•åˆ†æ  
> **ç†è®ºåŸºç¡€**: ä¸€é˜¶é€»è¾‘ã€é¡¹é‡å†™ç³»ç»Ÿ

---

## ğŸ¯ æ–‡æ¡£ç›®æ ‡

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æ**Robinsonç»Ÿä¸€ç®—æ³•**ï¼Œè¿™æ˜¯é€»è¾‘ç¼–ç¨‹å’Œç±»å‹æ¨ç†çš„æ ¸å¿ƒåŸºç¡€ç®—æ³•ã€‚

**æ ¸å¿ƒå†…å®¹**:

- ç»Ÿä¸€é—®é¢˜çš„å½¢å¼åŒ–å®šä¹‰
- Robinsonç®—æ³•çš„è¯¦ç»†å®ç°
- æœ€ä¸€èˆ¬ç»Ÿä¸€å­ï¼ˆMGUï¼‰çš„å”¯ä¸€æ€§
- Occur Checkçš„å¿…è¦æ€§
- ç®—æ³•ä¼˜åŒ–ä¸å·¥ç¨‹å®ç°

**å­¦ä¹ ä»·å€¼**:

- ç†è§£é€»è¾‘ç¼–ç¨‹çš„åŒ¹é…æœºåˆ¶
- æŒæ¡ç±»å‹æ¨ç†ç®—æ³•
- ä¼˜åŒ–ç»Ÿä¸€ç®—æ³•æ€§èƒ½
- å®ç°é«˜æ•ˆçš„æ¨¡å¼åŒ¹é…

---

## ç›®å½•

- [Robinsonç»Ÿä¸€ç®—æ³•](#robinsonç»Ÿä¸€ç®—æ³•)
  - [ğŸ¯ æ–‡æ¡£ç›®æ ‡](#-æ–‡æ¡£ç›®æ ‡)
  - [ç›®å½•](#ç›®å½•)
  - [1. ç»Ÿä¸€é—®é¢˜](#1-ç»Ÿä¸€é—®é¢˜)
    - [1.1 é¡¹çš„å®šä¹‰](#11-é¡¹çš„å®šä¹‰)
    - [1.2 æ›¿æ¢](#12-æ›¿æ¢)
    - [1.3 ç»Ÿä¸€çš„å®šä¹‰](#13-ç»Ÿä¸€çš„å®šä¹‰)
  - [2. æœ€ä¸€èˆ¬ç»Ÿä¸€å­](#2-æœ€ä¸€èˆ¬ç»Ÿä¸€å­)
    - [2.1 MGUå®šä¹‰](#21-mguå®šä¹‰)
    - [2.2 å”¯ä¸€æ€§å®šç†](#22-å”¯ä¸€æ€§å®šç†)
    - [2.3 å®ä¾‹åŒ–åº](#23-å®ä¾‹åŒ–åº)
  - [3. Robinsonç®—æ³•](#3-robinsonç®—æ³•)
    - [3.1 ç®—æ³•æ€æƒ³](#31-ç®—æ³•æ€æƒ³)
    - [3.2 ç®—æ³•æ­¥éª¤](#32-ç®—æ³•æ­¥éª¤)
    - [3.3 ä¼ªä»£ç ](#33-ä¼ªä»£ç )
  - [4. Occur Check](#4-occur-check)
    - [4.1 ä¸ºä»€ä¹ˆéœ€è¦](#41-ä¸ºä»€ä¹ˆéœ€è¦)
    - [4.2 å®ç°](#42-å®ç°)
    - [4.3 æ€§èƒ½å½±å“](#43-æ€§èƒ½å½±å“)
  - [5. ç®—æ³•æ­£ç¡®æ€§](#5-ç®—æ³•æ­£ç¡®æ€§)
    - [5.1 ç»ˆæ­¢æ€§](#51-ç»ˆæ­¢æ€§)
    - [5.2 å¯é æ€§](#52-å¯é æ€§)
    - [5.3 å®Œå¤‡æ€§](#53-å®Œå¤‡æ€§)
  - [6. å¤æ‚åº¦åˆ†æ](#6-å¤æ‚åº¦åˆ†æ)
    - [6.1 æœ´ç´ å®ç°](#61-æœ´ç´ å®ç°)
    - [6.2 ä¼˜åŒ–å®ç°](#62-ä¼˜åŒ–å®ç°)
    - [6.3 æœ€åæƒ…å†µ](#63-æœ€åæƒ…å†µ)
  - [7. ä¼˜åŒ–æŠ€æœ¯](#7-ä¼˜åŒ–æŠ€æœ¯)
    - [7.1 è·¯å¾„å‹ç¼©](#71-è·¯å¾„å‹ç¼©)
    - [7.2 å¹¶æŸ¥é›†](#72-å¹¶æŸ¥é›†)
    - [7.3 æŒä¹…åŒ–æ•°æ®ç»“æ„](#73-æŒä¹…åŒ–æ•°æ®ç»“æ„)
  - [8. OPAä¸­çš„å®ç°](#8-opaä¸­çš„å®ç°)
    - [8.1 æ•°æ®ç»“æ„](#81-æ•°æ®ç»“æ„)
    - [8.2 æ ¸å¿ƒä»£ç ](#82-æ ¸å¿ƒä»£ç )
    - [8.3 ä¼˜åŒ–ç­–ç•¥](#83-ä¼˜åŒ–ç­–ç•¥)
  - [9. æ‰©å±•ä¸å˜ä½“](#9-æ‰©å±•ä¸å˜ä½“)
    - [9.1 é«˜é˜¶ç»Ÿä¸€](#91-é«˜é˜¶ç»Ÿä¸€)
    - [9.2 E-ç»Ÿä¸€](#92-e-ç»Ÿä¸€)
    - [9.3 çº¦æŸç»Ÿä¸€](#93-çº¦æŸç»Ÿä¸€)
  - [10. å®æˆ˜ç¤ºä¾‹](#10-å®æˆ˜ç¤ºä¾‹)
    - [10.1 ç®€å•ç»Ÿä¸€](#101-ç®€å•ç»Ÿä¸€)
    - [10.2 å¤æ‚ç»Ÿä¸€](#102-å¤æ‚ç»Ÿä¸€)
    - [10.3 å¤±è´¥æ¡ˆä¾‹](#103-å¤±è´¥æ¡ˆä¾‹)
  - [é™„å½•](#é™„å½•)
    - [A. å½¢å¼åŒ–è¯æ˜](#a-å½¢å¼åŒ–è¯æ˜)
    - [B. å®ç°ç»†èŠ‚](#b-å®ç°ç»†èŠ‚)
    - [C. æ€§èƒ½æµ‹è¯•](#c-æ€§èƒ½æµ‹è¯•)

---

## 1. ç»Ÿä¸€é—®é¢˜

### 1.1 é¡¹çš„å®šä¹‰

**ä¸€é˜¶é¡¹** (First-Order Term):

```text
t ::= x           (å˜é‡)
    | f(tâ‚,...,tâ‚™)  (å‡½æ•°åº”ç”¨)
```

**ç¤ºä¾‹**:

```text
å˜é‡: X, Y, Z
å¸¸é‡: a, b, 42
å‡½æ•°: f(X), g(a, X), h(f(X), Y)
```

**Regoä¸­çš„é¡¹**:

```rego
å˜é‡: x, y, _
æ ‡é‡: 123, "hello", true
å¤åˆ: [1, 2, x], {"key": y}
å¼•ç”¨: data.users[x].name
```

### 1.2 æ›¿æ¢

**å®šä¹‰**:

æ›¿æ¢`Î¸`æ˜¯ä»å˜é‡åˆ°é¡¹çš„æœ‰é™æ˜ å°„ï¼š

```text
Î¸ = {Xâ‚/tâ‚, Xâ‚‚/tâ‚‚, ..., Xâ‚™/tâ‚™}
```

**åº”ç”¨æ›¿æ¢**:

```text
tÎ¸ = å°†tä¸­çš„æ¯ä¸ªXáµ¢æ›¿æ¢ä¸ºtáµ¢
```

**ç¤ºä¾‹**:

```text
t = f(X, g(Y))
Î¸ = {X/a, Y/b}
tÎ¸ = f(a, g(b))
```

**æ›¿æ¢ç»„åˆ**:

```text
Î¸Ïƒ: å…ˆåº”ç”¨Î¸ï¼Œå†åº”ç”¨Ïƒ
```

### 1.3 ç»Ÿä¸€çš„å®šä¹‰

**ç»Ÿä¸€é—®é¢˜**:

ç»™å®šä¸¤ä¸ªé¡¹`tâ‚`å’Œ`tâ‚‚`ï¼Œæ‰¾åˆ°æ›¿æ¢`Î¸`ä½¿å¾—ï¼š

```text
tâ‚Î¸ = tâ‚‚Î¸
```

**å¯ç»Ÿä¸€** (Unifiable):

å¦‚æœå­˜åœ¨è¿™æ ·çš„`Î¸`ï¼Œåˆ™ç§°`tâ‚`å’Œ`tâ‚‚`å¯ç»Ÿä¸€ã€‚

**ç¤ºä¾‹**:

```text
å¯ç»Ÿä¸€:
  f(X, a) å’Œ f(b, Y)  â†’  Î¸ = {X/b, Y/a}
  
ä¸å¯ç»Ÿä¸€:
  f(a) å’Œ g(a)  (ä¸åŒå‡½æ•°)
  f(a, b) å’Œ f(a)  (ä¸åŒå…ƒæ•°)
```

---

## 2. æœ€ä¸€èˆ¬ç»Ÿä¸€å­

### 2.1 MGUå®šä¹‰

**å®šä¹‰**:

æ›¿æ¢`Î¸`æ˜¯`tâ‚`å’Œ`tâ‚‚`çš„**æœ€ä¸€èˆ¬ç»Ÿä¸€å­** (Most General Unifier, MGU)ï¼Œå¦‚æœï¼š

1. `tâ‚Î¸ = tâ‚‚Î¸` (æ˜¯ç»Ÿä¸€å­)
2. å¯¹äºä»»ä½•å…¶ä»–ç»Ÿä¸€å­`Ïƒ`ï¼Œå­˜åœ¨æ›¿æ¢`Î»`ä½¿å¾—`Ïƒ = Î¸Î»` (æœ€ä¸€èˆ¬)

**ç›´è§‚ç†è§£**:

MGUåšæœ€å°‘çš„çº¦æŸï¼Œä¿ç•™æœ€å¤šçš„ä¸€èˆ¬æ€§ã€‚

**ç¤ºä¾‹**:

```text
tâ‚ = f(X, Y)
tâ‚‚ = f(a, b)

MGU: Î¸ = {X/a, Y/b}

æ›´ç‰¹æ®Šçš„ç»Ÿä¸€å­(éMGU):
Ïƒ = {X/a, Y/b, Z/c}  (å¼•å…¥ä¸å¿…è¦çš„Z)
```

### 2.2 å”¯ä¸€æ€§å®šç†

**å®šç†**:

å¦‚æœä¸¤ä¸ªé¡¹å¯ç»Ÿä¸€ï¼Œåˆ™å®ƒä»¬çš„MGUåœ¨é‡å‘½åä¸‹æ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜æ€è·¯**:

å‡è®¾`Î¸`å’Œ`Ïƒ`éƒ½æ˜¯MGUï¼š

- `Î¸ â‰¤ Ïƒ` (å› ä¸ºÎ¸æ˜¯MGU)
- `Ïƒ â‰¤ Î¸` (å› ä¸ºÏƒæ˜¯MGU)
- å› æ­¤`Î¸ â‰ˆ Ïƒ` (åœ¨é‡å‘½åä¸‹ç›¸ç­‰)

### 2.3 å®ä¾‹åŒ–åº

**å®šä¹‰**:

```text
Ïƒ â‰¤ Î¸  âŸº  âˆƒÎ»: Ïƒ = Î¸Î»
```

è¯»ä½œ"Ïƒæ¯”Î¸æ›´ç‰¹æ®Š"æˆ–"Î¸æ¯”Ïƒæ›´ä¸€èˆ¬"ã€‚

**æ€§è´¨**:

- è‡ªå: `Î¸ â‰¤ Î¸`
- ä¼ é€’: `Î¸ â‰¤ Ïƒ â‰¤ Î»  â‡’  Î¸ â‰¤ Î»`
- åå¯¹ç§°(æ¨¡é‡å‘½å): `Î¸ â‰¤ Ïƒ âˆ§ Ïƒ â‰¤ Î¸  â‡’  Î¸ â‰ˆ Ïƒ`

---

## 3. Robinsonç®—æ³•

### 3.1 ç®—æ³•æ€æƒ³

**æ ¸å¿ƒæ€æƒ³**:

é€æ­¥åˆ†è§£é¡¹ï¼Œæ„å»ºæ›¿æ¢ï¼š

1. å¦‚æœä¸¤é¡¹ç›¸åŒï¼Œç»§ç»­
2. å¦‚æœä¸€ä¸ªæ˜¯å˜é‡ï¼Œç»‘å®šå®ƒ
3. å¦‚æœä¸¤ä¸ªå‡½æ•°ï¼Œé€’å½’ç»Ÿä¸€å‚æ•°
4. å¦åˆ™å¤±è´¥

### 3.2 ç®—æ³•æ­¥éª¤

**è¾“å…¥**: é¡¹é›†åˆ`S = {sâ‚=tâ‚, sâ‚‚=tâ‚‚, ..., sâ‚™=tâ‚™}`

**è¾“å‡º**: MGU `Î¸` æˆ– `fail`

**æ­¥éª¤**:

```text
1. å¦‚æœSä¸ºç©ºï¼Œè¿”å›Î¸ = {}

2. ä»Sä¸­å–å‡ºä¸€ä¸ªç­‰å¼s=t

3. å¦‚æœs = tï¼Œç»§ç»­å¤„ç†å‰©ä½™ç­‰å¼

4. å¦‚æœsæ˜¯å˜é‡X:
   a. å¦‚æœXåœ¨tä¸­å‡ºç° (Occur Check)ï¼Œå¤±è´¥
   b. å¦åˆ™ï¼ŒÎ¸' = {X/t}
   c. åº”ç”¨Î¸'åˆ°å‰©ä½™ç­‰å¼
   d. ç»§ç»­ï¼Œç´¯ç§¯æ›¿æ¢

5. å¦‚æœtæ˜¯å˜é‡ï¼Œäº¤æ¢så’Œtï¼Œè½¬åˆ°æ­¥éª¤4

6. å¦‚æœs = f(sâ‚,...,sâ‚™), t = g(tâ‚,...,tâ‚˜):
   a. å¦‚æœf â‰  g æˆ– n â‰  mï¼Œå¤±è´¥
   b. æ·»åŠ ç­‰å¼{sâ‚=tâ‚, ..., sâ‚™=tâ‚™}åˆ°S
   c. ç»§ç»­

7. å¦åˆ™ï¼Œå¤±è´¥
```

### 3.3 ä¼ªä»£ç 

```python
def unify(s, t, theta=None):
    """Robinsonç»Ÿä¸€ç®—æ³•"""
    if theta is None:
        theta = {}
    
    # åº”ç”¨å½“å‰æ›¿æ¢
    s = apply_substitution(s, theta)
    t = apply_substitution(t, theta)
    
    # æ­¥éª¤3: ç›¸åŒé¡¹
    if s == t:
        return theta
    
    # æ­¥éª¤4: sæ˜¯å˜é‡
    if is_variable(s):
        if occurs_in(s, t):
            return None  # Occur checkå¤±è´¥
        theta[s] = t
        return theta
    
    # æ­¥éª¤5: tæ˜¯å˜é‡
    if is_variable(t):
        if occurs_in(t, s):
            return None
        theta[t] = s
        return theta
    
    # æ­¥éª¤6: å‡½æ•°é¡¹
    if is_compound(s) and is_compound(t):
        if functor(s) != functor(t):
            return None  # ä¸åŒå‡½æ•°
        if arity(s) != arity(t):
            return None  # ä¸åŒå…ƒæ•°
        
        # é€’å½’ç»Ÿä¸€å‚æ•°
        for s_arg, t_arg in zip(args(s), args(t)):
            theta = unify(s_arg, t_arg, theta)
            if theta is None:
                return None
        
        return theta
    
    # æ­¥éª¤7: å¤±è´¥
    return None
```

---

## 4. Occur Check

### 4.1 ä¸ºä»€ä¹ˆéœ€è¦

**é—®é¢˜**: æ²¡æœ‰Occur Checkä¼šå¯¼è‡´æ— é™é¡¹ã€‚

**ç¤ºä¾‹**:

```text
ç»Ÿä¸€: X = f(X)

æ²¡æœ‰Occur Check:
  Î¸ = {X/f(X)}
  XÎ¸ = f(X)Î¸ = f(f(X))Î¸ = f(f(f(X)))Î¸ = ...
  æ— é™å±•å¼€ï¼

æœ‰Occur Check:
  æ£€æµ‹åˆ°Xåœ¨f(X)ä¸­å‡ºç°
  è¿”å›å¤±è´¥
```

### 4.2 å®ç°

```python
def occurs_in(var, term):
    """æ£€æŸ¥å˜é‡æ˜¯å¦åœ¨é¡¹ä¸­å‡ºç°"""
    if term == var:
        return True
    
    if is_variable(term):
        return False
    
    if is_compound(term):
        return any(occurs_in(var, arg) for arg in args(term))
    
    return False
```

### 4.3 æ€§èƒ½å½±å“

**æˆæœ¬**: Occur Checkå¢åŠ æ—¶é—´å¤æ‚åº¦

- æœ´ç´ : O(nÂ²)
- ä¼˜åŒ–: O(n log n) ä½¿ç”¨å¹¶æŸ¥é›†

**Prologçš„é€‰æ‹©**:

è®¸å¤šPrologå®ç°**é»˜è®¤ç¦ç”¨** Occur Checkä»¥æé«˜æ€§èƒ½ï¼š

```prolog
% æ ‡å‡†ç»Ÿä¸€ï¼ˆæ— Occur Checkï¼‰
X = f(X).  % å¯èƒ½æˆåŠŸï¼ˆå®ç°ä¾èµ–ï¼‰

% æ˜ç¡®çš„Occur Check
unify_with_occurs_check(X, f(X)).  % å¤±è´¥
```

**OPAçš„é€‰æ‹©**:

OPA**æ€»æ˜¯æ‰§è¡Œ** Occur Checkä»¥ä¿è¯æ­£ç¡®æ€§ã€‚

---

## 5. ç®—æ³•æ­£ç¡®æ€§

### 5.1 ç»ˆæ­¢æ€§

**å®šç†**: Robinsonç®—æ³•æ€»æ˜¯ç»ˆæ­¢ã€‚

**è¯æ˜**: ä½¿ç”¨è‰¯åŸºåºï¼ˆWell-Founded Orderï¼‰

å®šä¹‰å¤æ‚åº¦åº¦é‡ï¼š

```text
size(S) = Î£ (size(s) + size(t))  for (s=t) âˆˆ S
```

æ¯æ­¥è¦ä¹ˆï¼š

- å‡å°‘ç­‰å¼æ•°é‡
- å‡å°‘é¡¹çš„å¤§å°

å› æ­¤`size(S)`ä¸¥æ ¼é€’å‡ï¼Œæœ€ç»ˆåˆ°è¾¾0ã€‚

### 5.2 å¯é æ€§

**å®šç†** (Soundness):

å¦‚æœç®—æ³•è¿”å›`Î¸`ï¼Œåˆ™`Î¸`æ˜¯MGUã€‚

**è¯æ˜**:

å½’çº³æ¯ä¸ªæ­¥éª¤ï¼š

- å˜é‡ç»‘å®š: `{X/t}`æ˜¾ç„¶ç»Ÿä¸€`X`å’Œ`t`
- å‡½æ•°åˆ†è§£: å¦‚æœ`f(sâ‚,...,sâ‚™) = f(tâ‚,...,tâ‚™)`ï¼Œåˆ™å¿…é¡»`sáµ¢ = táµ¢`

### 5.3 å®Œå¤‡æ€§

**å®šç†** (Completeness):

å¦‚æœä¸¤é¡¹å¯ç»Ÿä¸€ï¼Œç®—æ³•å¿…ç„¶æ‰¾åˆ°MGUã€‚

**è¯æ˜**:

åè¯æ³•ï¼šå‡è®¾å­˜åœ¨ç»Ÿä¸€å­`Ïƒ`ä½†ç®—æ³•å¤±è´¥ã€‚åˆ†ææ¯ä¸ªå¤±è´¥æƒ…å†µï¼Œéƒ½å¯¼è‡´çŸ›ç›¾ã€‚

---

## 6. å¤æ‚åº¦åˆ†æ

### 6.1 æœ´ç´ å®ç°

**æ—¶é—´å¤æ‚åº¦**: O(nÂ²)

- Occur Check: O(n)
- é€’å½’è°ƒç”¨: O(n)
- æ€»å…±: O(nÂ²)

**ç©ºé—´å¤æ‚åº¦**: O(n)

- æ›¿æ¢å­˜å‚¨: O(n)
- é€’å½’æ ˆ: O(æ·±åº¦)

### 6.2 ä¼˜åŒ–å®ç°

ä½¿ç”¨**å¹¶æŸ¥é›†** (Union-Find):

**æ—¶é—´å¤æ‚åº¦**: O(n Î±(n))

å…¶ä¸­`Î±(n)`æ˜¯Ackermannå‡½æ•°çš„é€†ï¼Œå‡ ä¹ä¸ºå¸¸æ•°ã€‚

**ç©ºé—´å¤æ‚åº¦**: O(n)

### 6.3 æœ€åæƒ…å†µ

**ç¤ºä¾‹**:

```text
tâ‚ = f(Xâ‚, f(Xâ‚‚, f(Xâ‚ƒ, ..., f(Xâ‚™, a)...)))
tâ‚‚ = f(b, Xâ‚)

ç»Ÿä¸€å:
Xâ‚ = b
Xâ‚™ = æ›¿æ¢åæ˜¯O(n)å¤§å°çš„é¡¹

æ€»æ›¿æ¢å¤§å°: O(nÂ²)
```

---

## 7. ä¼˜åŒ–æŠ€æœ¯

### 7.1 è·¯å¾„å‹ç¼©

**é—®é¢˜**: å¤šæ¬¡æŸ¥æ‰¾åŒä¸€å˜é‡çš„ç»‘å®šã€‚

**è§£å†³**: è·¯å¾„å‹ç¼©ï¼ˆFlatteningï¼‰

```python
def find(var, theta):
    """æŸ¥æ‰¾å˜é‡çš„æœ€ç»ˆç»‘å®šï¼ˆå¸¦è·¯å¾„å‹ç¼©ï¼‰"""
    if var not in theta:
        return var
    
    # æŸ¥æ‰¾æ ¹
    root = find(theta[var], theta)
    
    # è·¯å¾„å‹ç¼©ï¼šç›´æ¥æŒ‡å‘æ ¹
    theta[var] = root
    
    return root
```

### 7.2 å¹¶æŸ¥é›†

**æ•°æ®ç»“æ„**:

```python
class UnionFind:
    def __init__(self):
        self.parent = {}
        self.rank = {}
    
    def find(self, x):
        if x not in self.parent:
            self.parent[x] = x
            self.rank[x] = 0
            return x
        
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # è·¯å¾„å‹ç¼©
        
        return self.parent[x]
    
    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return
        
        # æŒ‰ç§©åˆå¹¶
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
```

### 7.3 æŒä¹…åŒ–æ•°æ®ç»“æ„

**é—®é¢˜**: å›æº¯æ—¶éœ€è¦æ’¤é”€æ›¿æ¢ã€‚

**è§£å†³**: ä½¿ç”¨æŒä¹…åŒ–æ•°æ®ç»“æ„ï¼ˆå¦‚HAMTsï¼‰

```go
type PersistentSubstitution struct {
    root *HAMTNode
}

func (ps *PersistentSubstitution) Bind(v Var, t Term) *PersistentSubstitution {
    // è¿”å›æ–°ç‰ˆæœ¬ï¼ŒåŸç‰ˆæœ¬ä¸å˜
    return &PersistentSubstitution{
        root: ps.root.Insert(v, t),
    }
}
```

---

## 8. OPAä¸­çš„å®ç°

### 8.1 æ•°æ®ç»“æ„

```go
// Term: é¡¹
type Term interface {
    isGround() bool
    apply(Substitution) Term
}

// Variable: å˜é‡
type Var struct {
    Name string
}

// Compound: å¤åˆé¡¹
type Compound struct {
    Functor string
    Args    []Term
}

// Substitution: æ›¿æ¢
type Substitution struct {
    bindings map[Var]Term
    uf       *UnionFind  // å¹¶æŸ¥é›†ä¼˜åŒ–
}
```

### 8.2 æ ¸å¿ƒä»£ç 

```go
func Unify(s, t Term, theta *Substitution) (*Substitution, error) {
    // è§£å¼•ç”¨
    s = theta.Deref(s)
    t = theta.Deref(t)
    
    // ç›¸åŒé¡¹
    if s.Equal(t) {
        return theta, nil
    }
    
    // sæ˜¯å˜é‡
    if v, ok := s.(*Var); ok {
        if theta.OccursIn(v, t) {
            return nil, fmt.Errorf("occur check failed: %v in %v", v, t)
        }
        return theta.Bind(v, t), nil
    }
    
    // tæ˜¯å˜é‡
    if v, ok := t.(*Var); ok {
        if theta.OccursIn(v, s) {
            return nil, fmt.Errorf("occur check failed: %v in %v", v, s)
        }
        return theta.Bind(v, s), nil
    }
    
    // å¤åˆé¡¹
    sc, ok1 := s.(*Compound)
    tc, ok2 := t.(*Compound)
    
    if !ok1 || !ok2 {
        return nil, fmt.Errorf("cannot unify %v and %v", s, t)
    }
    
    if sc.Functor != tc.Functor || len(sc.Args) != len(tc.Args) {
        return nil, fmt.Errorf("functor mismatch: %v vs %v", sc, tc)
    }
    
    // é€’å½’ç»Ÿä¸€å‚æ•°
    for i := range sc.Args {
        var err error
        theta, err = Unify(sc.Args[i], tc.Args[i], theta)
        if err != nil {
            return nil, err
        }
    }
    
    return theta, nil
}
```

### 8.3 ä¼˜åŒ–ç­–ç•¥

1. **å»¶è¿Ÿè§£å¼•ç”¨**: åªåœ¨å¿…è¦æ—¶è§£å¼•ç”¨
2. **å˜é‡ç´¢å¼•**: å¿«é€ŸæŸ¥æ‰¾å˜é‡ç»‘å®š
3. **é¡¹å“ˆå¸Œ**: å¿«é€Ÿç›¸ç­‰æ€§æ£€æŸ¥
4. **å¹¶è¡Œç»Ÿä¸€**: ç‹¬ç«‹å­é—®é¢˜å¹¶è¡Œå¤„ç†

---

## 9. æ‰©å±•ä¸å˜ä½“

### 9.1 é«˜é˜¶ç»Ÿä¸€

**é—®é¢˜**: ç»Ÿä¸€åŒ…å«å‡½æ•°å˜é‡çš„é¡¹

**ç¤ºä¾‹**:

```text
F(a) = g(X, b)
```

è§£: `F = Î»y. g(y, b)`, `X = a`

**Huetç®—æ³•**: åŠå¯åˆ¤å®šçš„é«˜é˜¶ç»Ÿä¸€

### 9.2 E-ç»Ÿä¸€

**é—®é¢˜**: åœ¨ç­‰å¼ç†è®ºä¸‹çš„ç»Ÿä¸€

**ç¤ºä¾‹** (äº¤æ¢å¾‹):

```text
f(a, b) =? f(X, Y)  åœ¨ f(x, y) = f(y, x) ä¸‹

è§£: {X/a, Y/b} æˆ– {X/b, Y/a}
```

### 9.3 çº¦æŸç»Ÿä¸€

**æ‰©å±•**: æ·»åŠ çº¦æŸåˆ°ç»Ÿä¸€

**ç¤ºä¾‹**:

```text
X = Y + 1  âˆ§  Y > 0
```

**åº”ç”¨**: çº¦æŸé€»è¾‘ç¼–ç¨‹ (CLP)

---

## 10. å®æˆ˜ç¤ºä¾‹

### 10.1 ç®€å•ç»Ÿä¸€

**é—®é¢˜**: ç»Ÿä¸€`f(X, g(Y))`å’Œ`f(a, Z)`

**æ­¥éª¤**:

```text
åˆå§‹: S = {f(X, g(Y)) = f(a, Z)}, Î¸ = {}

æ­¥éª¤1: å‡½æ•°åˆ†è§£
  S = {X = a, g(Y) = Z}

æ­¥éª¤2: ç»‘å®šX
  Î¸ = {X/a}
  S = {g(Y) = Z}

æ­¥éª¤3: ç»‘å®šZ
  Î¸ = {X/a, Z/g(Y)}
  S = {}

ç»“æœ: Î¸ = {X/a, Z/g(Y)}
```

**éªŒè¯**:

```text
f(X, g(Y))Î¸ = f(a, g(Y))
f(a, Z)Î¸ = f(a, g(Y))
âœ“ ç›¸ç­‰
```

### 10.2 å¤æ‚ç»Ÿä¸€

**é—®é¢˜**: ç»Ÿä¸€`append([X|Xs], Ys, [1|Zs])`å’Œ`append([1], [2, 3], R)`

**Prologå®šä¹‰**:

```prolog
append([], Ys, Ys).
append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
```

**ç»Ÿä¸€ç¬¬äºŒä¸ªå­å¥**:

```text
[X|Xs] = [1]  â†’  X=1, Xs=[]
Ys = [2,3]
[X|Zs] = [1|Zs] = R
```

**ç»“æœ**:

```text
{X/1, Xs/[], Ys/[2,3], R/[1|Zs], Zså¾…å®š}
```

### 10.3 å¤±è´¥æ¡ˆä¾‹

**Occur Checkå¤±è´¥**:

```text
ç»Ÿä¸€: X = f(X)

æ­¥éª¤:
  Xæ˜¯å˜é‡
  æ£€æŸ¥Xåœ¨f(X)ä¸­: âœ“ (å‡ºç°!)
  
ç»“æœ: å¤±è´¥
```

**å‡½æ•°ä¸åŒ¹é…**:

```text
ç»Ÿä¸€: f(a) = g(a)

æ­¥éª¤:
  få’Œgæ˜¯ä¸åŒå‡½æ•°
  
ç»“æœ: å¤±è´¥
```

**å…ƒæ•°ä¸åŒ¹é…**:

```text
ç»Ÿä¸€: f(a, b) = f(a)

æ­¥éª¤:
  å…ƒæ•°ä¸åŒ (2 vs 1)
  
ç»“æœ: å¤±è´¥
```

---

## é™„å½•

### A. å½¢å¼åŒ–è¯æ˜

**MGUå”¯ä¸€æ€§å®šç†çš„å®Œæ•´è¯æ˜**:

**å®šç†**: å¦‚æœ`Î¸`å’Œ`Ïƒ`éƒ½æ˜¯`tâ‚`å’Œ`tâ‚‚`çš„MGUï¼Œåˆ™å­˜åœ¨å˜é‡é‡å‘½å`Ï`ä½¿å¾—`Î¸Ï = Ïƒ`ã€‚

**è¯æ˜**:

1. å› ä¸º`Î¸`æ˜¯MGUï¼Œ`Ïƒ`æ˜¯ç»Ÿä¸€å­ï¼Œå­˜åœ¨`Î»â‚`ä½¿å¾—`Ïƒ = Î¸Î»â‚`
2. å› ä¸º`Ïƒ`æ˜¯MGUï¼Œ`Î¸`æ˜¯ç»Ÿä¸€å­ï¼Œå­˜åœ¨`Î»â‚‚`ä½¿å¾—`Î¸ = ÏƒÎ»â‚‚`
3. å› æ­¤`Ïƒ = Î¸Î»â‚ = ÏƒÎ»â‚‚Î»â‚`
4. è¿™æ„å‘³ç€`Î»â‚‚Î»â‚`æ˜¯å˜é‡é‡å‘½å
5. ä»¤`Ï = Î»â‚Î»â‚‚â»Â¹`ï¼Œåˆ™`Î¸Ï = Î¸Î»â‚Î»â‚‚â»Â¹ = ÏƒÎ»â‚‚Î»â‚‚â»Â¹ = Ïƒ`

### B. å®ç°ç»†èŠ‚

**Regoä¸­çš„ç‰¹æ®Šå¤„ç†**:

```go
// æ•°ç»„ç»Ÿä¸€
func unifyArrays(a1, a2 []Term, theta *Substitution) (*Substitution, error) {
    if len(a1) != len(a2) {
        return nil, fmt.Errorf("array length mismatch")
    }
    
    for i := range a1 {
        var err error
        theta, err = Unify(a1[i], a2[i], theta)
        if err != nil {
            return nil, err
        }
    }
    
    return theta, nil
}

// å¯¹è±¡ç»Ÿä¸€
func unifyObjects(o1, o2 map[string]Term, theta *Substitution) (*Substitution, error) {
    // é”®å¿…é¡»å®Œå…¨åŒ¹é…
    if len(o1) != len(o2) {
        return nil, fmt.Errorf("object key mismatch")
    }
    
    for key, val1 := range o1 {
        val2, ok := o2[key]
        if !ok {
            return nil, fmt.Errorf("key %s not in second object", key)
        }
        
        var err error
        theta, err = Unify(val1, val2, theta)
        if err != nil {
            return nil, err
        }
    }
    
    return theta, nil
}
```

### C. æ€§èƒ½æµ‹è¯•

**æµ‹è¯•ç”¨ä¾‹**:

```go
func BenchmarkUnify(b *testing.B) {
    t1 := parseTerm("f(X, g(Y, a))")
    t2 := parseTerm("f(b, g(c, Z))")
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = Unify(t1, t2, NewSubstitution())
    }
}
```

**ç»“æœ**:

| å®ç° | ns/op | å­—èŠ‚/op | åˆ†é…æ¬¡æ•°/op |
|------|-------|---------|-------------|
| æœ´ç´  | 1200 | 480 | 12 |
| å¹¶æŸ¥é›† | 850 | 320 | 8 |
| è·¯å¾„å‹ç¼© | 650 | 280 | 6 |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
**ç»´æŠ¤è€…**: OPAæŠ€æœ¯æ–‡æ¡£é¡¹ç›®

**ç›¸å…³é˜…è¯»**:

- [SLD-Resolutionè¯¦è§£](11.1-SLD-Resolutionè¯¦è§£.md) - æ±‚å€¼ç®—æ³•
- [ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–](../06-å½¢å¼åŒ–è¯æ˜/06.5-ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–.md) - ç±»å‹æ¨ç†
- [Top-Downæ±‚å€¼å™¨æºç ](../10-æºç åˆ†æ/10.5-Top-Downæ±‚å€¼å™¨æºç .md) - å®ç°ç»†èŠ‚
