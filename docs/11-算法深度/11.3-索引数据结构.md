# ç´¢å¼•æ•°æ®ç»“æ„

> **æ–‡æ¡£ç±»å‹**: ç®—æ³•æ·±åº¦åˆ†æ  
> **æ ¸å¿ƒä¸»é¢˜**: OPAç´¢å¼•ç³»ç»Ÿçš„æ•°æ®ç»“æ„ä¸ç®—æ³•  
> **é€‚ç”¨è¯»è€…**: æ€§èƒ½ä¼˜åŒ–å·¥ç¨‹å¸ˆã€æ•°æ®åº“å¼€å‘è€…ã€OPAæ ¸å¿ƒå¼€å‘è€…  
> **å…ˆä¿®çŸ¥è¯†**: [æ•°æ®ç»“æ„åŸºç¡€](https://en.wikipedia.org/wiki/Data_structure)ã€[ç´¢å¼•ç³»ç»Ÿå®ç°](../10-æºç åˆ†æ/10.7-ç´¢å¼•ç³»ç»Ÿå®ç°.md)  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 3.3 - ç®—æ³•åˆ†æ  
> **ç†è®ºåŸºç¡€**: Bæ ‘ã€å“ˆå¸Œè¡¨ã€Trieã€å€’æ’ç´¢å¼•

---

## ğŸ¯ æ–‡æ¡£ç›®æ ‡

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æOPAä½¿ç”¨çš„**ç´¢å¼•æ•°æ®ç»“æ„**ï¼Œè¿™æ˜¯å®ç°é«˜æ€§èƒ½ç­–ç•¥æ±‚å€¼çš„å…³é”®æŠ€æœ¯ã€‚

**æ ¸å¿ƒå†…å®¹**:

- OPAç´¢å¼•ç³»ç»Ÿæ¶æ„
- è§„åˆ™ç´¢å¼•æ•°æ®ç»“æ„
- æ•°æ®ç´¢å¼•ç®—æ³•
- ä¸‰å…ƒç´¢å¼•ï¼ˆTriple Indexï¼‰
- æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

**å­¦ä¹ ä»·å€¼**:

- ç†è§£OPAå¦‚ä½•å¿«é€Ÿå®šä½ç›¸å…³è§„åˆ™
- æŒæ¡é«˜æ•ˆæ•°æ®æ£€ç´¢ç®—æ³•
- ä¼˜åŒ–å¤§è§„æ¨¡ç­–ç•¥æ€§èƒ½
- è®¾è®¡è‡ªå®šä¹‰ç´¢å¼•ç­–ç•¥

---

## ç›®å½•

- [ç´¢å¼•æ•°æ®ç»“æ„](#ç´¢å¼•æ•°æ®ç»“æ„)
  - [ğŸ¯ æ–‡æ¡£ç›®æ ‡](#-æ–‡æ¡£ç›®æ ‡)
  - [ç›®å½•](#ç›®å½•)
  - [1. ç´¢å¼•ç³»ç»Ÿæ¦‚è§ˆ](#1-ç´¢å¼•ç³»ç»Ÿæ¦‚è§ˆ)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦ç´¢å¼•](#11-ä¸ºä»€ä¹ˆéœ€è¦ç´¢å¼•)
    - [1.2 OPAçš„ç´¢å¼•æ¶æ„](#12-opaçš„ç´¢å¼•æ¶æ„)
    - [1.3 ç´¢å¼•ç±»å‹](#13-ç´¢å¼•ç±»å‹)
  - [2. è§„åˆ™ç´¢å¼•](#2-è§„åˆ™ç´¢å¼•)
    - [2.1 è§„åˆ™æ ‘](#21-è§„åˆ™æ ‘)
    - [2.2 å‰ç¼€æ ‘ï¼ˆTrieï¼‰](#22-å‰ç¼€æ ‘trie)
    - [2.3 è·¯å¾„ç´¢å¼•](#23-è·¯å¾„ç´¢å¼•)
  - [3. æ•°æ®ç´¢å¼•](#3-æ•°æ®ç´¢å¼•)
    - [3.1 ä¸‰å…ƒç´¢å¼•ï¼ˆTriple Indexï¼‰](#31-ä¸‰å…ƒç´¢å¼•triple-index)
    - [3.2 å“ˆå¸Œç´¢å¼•](#32-å“ˆå¸Œç´¢å¼•)
    - [3.3 èŒƒå›´ç´¢å¼•](#33-èŒƒå›´ç´¢å¼•)
  - [4. Trieæ•°æ®ç»“æ„](#4-trieæ•°æ®ç»“æ„)
    - [4.1 åŸºæœ¬Trie](#41-åŸºæœ¬trie)
    - [4.2 å‹ç¼©Trieï¼ˆPatricia Trieï¼‰](#42-å‹ç¼©triepatricia-trie)
    - [4.3 åŸºæ•°æ ‘ï¼ˆRadix Treeï¼‰](#43-åŸºæ•°æ ‘radix-tree)
  - [5. å€’æ’ç´¢å¼•](#5-å€’æ’ç´¢å¼•)
    - [5.1 æ¦‚å¿µ](#51-æ¦‚å¿µ)
    - [5.2 æ„å»ºç®—æ³•](#52-æ„å»ºç®—æ³•)
    - [5.3 æŸ¥è¯¢ç®—æ³•](#53-æŸ¥è¯¢ç®—æ³•)
  - [6. ä¸‰å…ƒå­˜å‚¨](#6-ä¸‰å…ƒå­˜å‚¨)
    - [6.1 SPOç´¢å¼•](#61-spoç´¢å¼•)
    - [6.2 POSç´¢å¼•](#62-posç´¢å¼•)
    - [6.3 OSPç´¢å¼•](#63-ospç´¢å¼•)
  - [7. æ€§èƒ½ä¼˜åŒ–](#7-æ€§èƒ½ä¼˜åŒ–)
    - [7.1 ç¼“å­˜ç­–ç•¥](#71-ç¼“å­˜ç­–ç•¥)
    - [7.2 å¢é‡æ›´æ–°](#72-å¢é‡æ›´æ–°)
    - [7.3 å¹¶è¡Œæ„å»º](#73-å¹¶è¡Œæ„å»º)
  - [8. OPAä¸­çš„å®ç°](#8-opaä¸­çš„å®ç°)
    - [8.1 æ•°æ®ç»“æ„](#81-æ•°æ®ç»“æ„)
    - [8.2 æ ¸å¿ƒç®—æ³•](#82-æ ¸å¿ƒç®—æ³•)
    - [8.3 ä¼˜åŒ–æŠ€æœ¯](#83-ä¼˜åŒ–æŠ€æœ¯)
  - [9. å¤æ‚åº¦åˆ†æ](#9-å¤æ‚åº¦åˆ†æ)
    - [9.1 æ—¶é—´å¤æ‚åº¦](#91-æ—¶é—´å¤æ‚åº¦)
    - [9.2 ç©ºé—´å¤æ‚åº¦](#92-ç©ºé—´å¤æ‚åº¦)
    - [9.3 æƒè¡¡åˆ†æ](#93-æƒè¡¡åˆ†æ)
  - [10. å®æˆ˜ç¤ºä¾‹](#10-å®æˆ˜ç¤ºä¾‹)
    - [10.1 ç®€å•æŸ¥è¯¢](#101-ç®€å•æŸ¥è¯¢)
    - [10.2 å¤æ‚æŸ¥è¯¢](#102-å¤æ‚æŸ¥è¯¢)
    - [10.3 æ€§èƒ½å¯¹æ¯”](#103-æ€§èƒ½å¯¹æ¯”)
  - [é™„å½•](#é™„å½•)
    - [A. æ•°æ®ç»“æ„å‚è€ƒ](#a-æ•°æ®ç»“æ„å‚è€ƒ)
    - [B. å®ç°ä»£ç ](#b-å®ç°ä»£ç )
    - [C. æ€§èƒ½åŸºå‡†](#c-æ€§èƒ½åŸºå‡†)

---

## 1. ç´¢å¼•ç³»ç»Ÿæ¦‚è§ˆ

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦ç´¢å¼•

**æ— ç´¢å¼•çš„æŸ¥è¯¢**:

```rego
# 10,000æ¡è§„åˆ™
allow {
    user := input.user
    some i
    data.users[i].name == user
    data.users[i].role == "admin"
}
```

**é—®é¢˜**: éœ€è¦éå†æ‰€æœ‰10,000æ¡è§„åˆ™  
**æ—¶é—´**: O(n) = 10,000æ¬¡æ¯”è¾ƒ

**æœ‰ç´¢å¼•çš„æŸ¥è¯¢**:

```text
1. ä½¿ç”¨ç´¢å¼•å¿«é€Ÿå®šä½ data.users[?].name == input.user
2. ä»…æ£€æŸ¥åŒ¹é…çš„è§„åˆ™ï¼ˆå¯èƒ½åªæœ‰1-2æ¡ï¼‰
```

**æ—¶é—´**: O(log n + k) = 10æ¬¡æ¯”è¾ƒ + 2æ¡åŒ¹é…è§„åˆ™

**æ€§èƒ½æå‡**: çº¦500å€ï¼

### 1.2 OPAçš„ç´¢å¼•æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Policy Compiler             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Index Builder               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  - è§„åˆ™ç´¢å¼•ï¼ˆRule Indexï¼‰            â”‚
â”‚  - æ•°æ®ç´¢å¼•ï¼ˆData Indexï¼‰            â”‚
â”‚  - ä¸‰å…ƒç´¢å¼•ï¼ˆTriple Indexï¼‰          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Index Storage               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ Trie    â”‚  â”‚  Hash   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ B-Tree  â”‚  â”‚ Invertedâ”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Query Evaluator             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 ç´¢å¼•ç±»å‹

| ç´¢å¼•ç±»å‹ | ç”¨é€” | æ•°æ®ç»“æ„ | æŸ¥è¯¢æ—¶é—´ |
|----------|------|----------|----------|
| è§„åˆ™ç´¢å¼• | å¿«é€Ÿå®šä½è§„åˆ™ | Trie | O(m) |
| å“ˆå¸Œç´¢å¼• | ç­‰å€¼æŸ¥è¯¢ | HashMap | O(1) |
| èŒƒå›´ç´¢å¼• | èŒƒå›´æŸ¥è¯¢ | B-Tree | O(log n) |
| ä¸‰å…ƒç´¢å¼• | å›¾æ•°æ®æŸ¥è¯¢ | Triple Store | O(log n) |
| å…¨æ–‡ç´¢å¼• | æ–‡æœ¬æœç´¢ | Inverted Index | O(k log n) |

---

## 2. è§„åˆ™ç´¢å¼•

### 2.1 è§„åˆ™æ ‘

**æ¦‚å¿µ**: æŒ‰è§„åˆ™è·¯å¾„ç»„ç»‡çš„æ ‘ç»“æ„

**ç¤ºä¾‹ç­–ç•¥**:

```rego
package example.rbac

allow {
    user_has_role(input.user, "admin")
}

allow {
    user_has_role(input.user, "viewer")
    resource_is_public(input.resource)
}

user_has_role(user, role) {
    data.assignments[user][_] == role
}
```

**è§„åˆ™æ ‘**:

```text
root
â””â”€â”€ example
    â””â”€â”€ rbac
        â”œâ”€â”€ allow
        â”‚   â”œâ”€â”€ rule_0 (admin)
        â”‚   â””â”€â”€ rule_1 (viewer + public)
        â””â”€â”€ user_has_role
            â””â”€â”€ rule_0
```

### 2.2 å‰ç¼€æ ‘ï¼ˆTrieï¼‰

**Trieç»“æ„**:

```text
æŸ¥è¯¢è·¯å¾„: data.users.alice.role

Trie:
root
â””â”€â”€ data
    â””â”€â”€ users
        â”œâ”€â”€ alice
        â”‚   â”œâ”€â”€ role â†’ [rule_1, rule_3]
        â”‚   â””â”€â”€ dept â†’ [rule_7]
        â””â”€â”€ bob
            â””â”€â”€ role â†’ [rule_2, rule_5]
```

**ä¼˜åŠ¿**:

- âœ… å‰ç¼€å…±äº«ï¼ŒèŠ‚çœç©ºé—´
- âœ… æŸ¥è¯¢æ—¶é—´ O(m)ï¼Œmæ˜¯è·¯å¾„é•¿åº¦
- âœ… æ”¯æŒå‰ç¼€æŸ¥è¯¢

### 2.3 è·¯å¾„ç´¢å¼•

**æ•°æ®ç»“æ„**:

```go
type PathIndex struct {
    root *TrieNode
}

type TrieNode struct {
    segment  string
    children map[string]*TrieNode
    rules    []*Rule  // è¯¥è·¯å¾„ç›¸å…³çš„è§„åˆ™
}
```

**æŸ¥è¯¢ç®—æ³•**:

```go
func (pi *PathIndex) Lookup(path []string) []*Rule {
    node := pi.root
    
    for _, segment := range path {
        child, ok := node.children[segment]
        if !ok {
            return nil
        }
        node = child
    }
    
    return node.rules
}
```

---

## 3. æ•°æ®ç´¢å¼•

### 3.1 ä¸‰å…ƒç´¢å¼•ï¼ˆTriple Indexï¼‰

**æ¦‚å¿µ**: å°†æ•°æ®å»ºæ¨¡ä¸º (Subject, Predicate, Object) ä¸‰å…ƒç»„

**ç¤ºä¾‹æ•°æ®**:

```json
{
  "users": {
    "alice": {
      "role": "admin",
      "dept": "eng"
    },
    "bob": {
      "role": "viewer",
      "dept": "sales"
    }
  }
}
```

**ä¸‰å…ƒç»„è¡¨ç¤º**:

```text
(users.alice, role, admin)
(users.alice, dept, eng)
(users.bob, role, viewer)
(users.bob, dept, sales)
```

### 3.2 å“ˆå¸Œç´¢å¼•

**ç”¨é€”**: å¿«é€Ÿç­‰å€¼æŸ¥è¯¢

**æ•°æ®ç»“æ„**:

```go
type HashIndex struct {
    index map[string][]*Triple
}
```

**ç¤ºä¾‹**:

```text
æŸ¥è¯¢: data.users[x].role == "admin"

å“ˆå¸Œç´¢å¼•:
  "admin" â†’ [(users.alice, role, admin)]
  "viewer" â†’ [(users.bob, role, viewer)]
  "eng" â†’ [(users.alice, dept, eng)]
  ...

æŸ¥è¯¢æ—¶é—´: O(1)
```

### 3.3 èŒƒå›´ç´¢å¼•

**ç”¨é€”**: èŒƒå›´æŸ¥è¯¢ï¼ˆå¦‚ x > 10, x < 100ï¼‰

**æ•°æ®ç»“æ„**: B-Treeæˆ–è·³è¡¨

**ç¤ºä¾‹**:

```rego
# æŸ¥è¯¢å¹´é¾„åœ¨25-35å²çš„ç”¨æˆ·
employees[name] {
    data.employees[name].age >= 25
    data.employees[name].age <= 35
}
```

**B-Treeç´¢å¼•**:

```text
          [30]
         /    \
    [20,25]   [35,40]
     /  |       |  \
   ...  ...    ...  ...
```

---

## 4. Trieæ•°æ®ç»“æ„

### 4.1 åŸºæœ¬Trie

**æ’å…¥ç®—æ³•**:

```go
type Trie struct {
    root *TrieNode
}

type TrieNode struct {
    children map[rune]*TrieNode
    isEnd    bool
    value    interface{}
}

func (t *Trie) Insert(key string, value interface{}) {
    node := t.root
    
    for _, char := range key {
        if node.children[char] == nil {
            node.children[char] = &TrieNode{
                children: make(map[rune]*TrieNode),
            }
        }
        node = node.children[char]
    }
    
    node.isEnd = true
    node.value = value
}
```

**æŸ¥è¯¢ç®—æ³•**:

```go
func (t *Trie) Search(key string) (interface{}, bool) {
    node := t.root
    
    for _, char := range key {
        node = node.children[char]
        if node == nil {
            return nil, false
        }
    }
    
    if node.isEnd {
        return node.value, true
    }
    
    return nil, false
}
```

### 4.2 å‹ç¼©Trieï¼ˆPatricia Trieï¼‰

**ä¼˜åŒ–**: åˆå¹¶åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹

**ç¤ºä¾‹**:

```text
åŸºæœ¬Trie:
root â†’ d â†’ a â†’ t â†’ a â†’ users â†’ alice

å‹ç¼©Trie:
root â†’ "data" â†’ "users" â†’ "alice"
```

**ç©ºé—´èŠ‚çœ**: O(æ€»å­—ç¬¦æ•°) â†’ O(å…³é”®èŠ‚ç‚¹æ•°)

### 4.3 åŸºæ•°æ ‘ï¼ˆRadix Treeï¼‰

**ç‰¹ç‚¹**: Patricia Trieçš„æ¨å¹¿ï¼ŒèŠ‚ç‚¹å­˜å‚¨å­—ç¬¦ä¸²

**å®ç°**:

```go
type RadixNode struct {
    prefix   string
    children []*RadixNode
    value    interface{}
}
```

**OPAä½¿ç”¨åœºæ™¯**: å­˜å‚¨è§„åˆ™è·¯å¾„

---

## 5. å€’æ’ç´¢å¼•

### 5.1 æ¦‚å¿µ

**å®šä¹‰**: ä»å€¼åˆ°ä½ç½®çš„æ˜ å°„

**ç¤ºä¾‹**:

```text
æ–‡æ¡£:
  doc1: "allow admin access"
  doc2: "deny viewer access"
  doc3: "allow viewer read"

å€’æ’ç´¢å¼•:
  "allow"  â†’ [doc1, doc3]
  "admin"  â†’ [doc1]
  "access" â†’ [doc1, doc2]
  "deny"   â†’ [doc2]
  "viewer" â†’ [doc2, doc3]
  "read"   â†’ [doc3]
```

### 5.2 æ„å»ºç®—æ³•

```go
type InvertedIndex struct {
    index map[string][]int  // è¯ â†’ æ–‡æ¡£IDåˆ—è¡¨
}

func BuildInvertedIndex(docs []string) *InvertedIndex {
    idx := &InvertedIndex{
        index: make(map[string][]int),
    }
    
    for docID, doc := range docs {
        words := tokenize(doc)
        for _, word := range words {
            idx.index[word] = append(idx.index[word], docID)
        }
    }
    
    return idx
}
```

### 5.3 æŸ¥è¯¢ç®—æ³•

**å•è¯æŸ¥è¯¢**:

```go
func (idx *InvertedIndex) Search(word string) []int {
    return idx.index[word]
}
```

**å¤šè¯ANDæŸ¥è¯¢**:

```go
func (idx *InvertedIndex) SearchAND(words []string) []int {
    if len(words) == 0 {
        return nil
    }
    
    // ä»æœ€çŸ­çš„å€’æ’åˆ—è¡¨å¼€å§‹
    result := idx.index[words[0]]
    
    for _, word := range words[1:] {
        result = intersect(result, idx.index[word])
    }
    
    return result
}

func intersect(a, b []int) []int {
    var result []int
    i, j := 0, 0
    
    for i < len(a) && j < len(b) {
        if a[i] == b[j] {
            result = append(result, a[i])
            i++
            j++
        } else if a[i] < b[j] {
            i++
        } else {
            j++
        }
    }
    
    return result
}
```

---

## 6. ä¸‰å…ƒå­˜å‚¨

### 6.1 SPOç´¢å¼•

**Subject-Predicate-Objectç´¢å¼•**

```go
type SPOIndex struct {
    index map[string]map[string][]string
    // subject â†’ predicate â†’ []object
}
```

**ç”¨é€”**: æŸ¥è¯¢"ç»™å®šä¸»ä½“å’Œè°“è¯ï¼Œæ‰¾æ‰€æœ‰å®¢ä½“"

**ç¤ºä¾‹æŸ¥è¯¢**:

```rego
# aliceçš„æ‰€æœ‰å±æ€§
data.users.alice[key] == value
```

### 6.2 POSç´¢å¼•

**Predicate-Object-Subjectç´¢å¼•**

```go
type POSIndex struct {
    index map[string]map[string][]string
    // predicate â†’ object â†’ []subject
}
```

**ç”¨é€”**: æŸ¥è¯¢"å“ªäº›ä¸»ä½“æœ‰ç‰¹å®šè°“è¯å’Œå®¢ä½“"

**ç¤ºä¾‹æŸ¥è¯¢**:

```rego
# æ‰€æœ‰è§’è‰²ä¸ºadminçš„ç”¨æˆ·
data.users[user].role == "admin"
```

### 6.3 OSPç´¢å¼•

**Object-Subject-Predicateç´¢å¼•**

```go
type OSPIndex struct {
    index map[string]map[string][]string
    // object â†’ subject â†’ []predicate
}
```

**ç”¨é€”**: æŸ¥è¯¢"å“ªäº›ä¸»ä½“çš„å“ªäº›è°“è¯ç­‰äºç‰¹å®šå®¢ä½“"

**ç¤ºä¾‹æŸ¥è¯¢**:

```rego
# adminå‡ºç°åœ¨å“ªäº›åœ°æ–¹
data[path] == "admin"
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 ç¼“å­˜ç­–ç•¥

**LRUç¼“å­˜**:

```go
type LRUCache struct {
    capacity int
    cache    map[string]*list.Element
    lru      *list.List
}

type entry struct {
    key   string
    value interface{}
}

func (c *LRUCache) Get(key string) (interface{}, bool) {
    if elem, ok := c.cache[key]; ok {
        c.lru.MoveToFront(elem)
        return elem.Value.(*entry).value, true
    }
    return nil, false
}

func (c *LRUCache) Put(key string, value interface{}) {
    if elem, ok := c.cache[key]; ok {
        c.lru.MoveToFront(elem)
        elem.Value.(*entry).value = value
        return
    }
    
    if c.lru.Len() >= c.capacity {
        // æ·˜æ±°æœ€ä¹…æœªä½¿ç”¨
        elem := c.lru.Back()
        c.lru.Remove(elem)
        delete(c.cache, elem.Value.(*entry).key)
    }
    
    e := &entry{key, value}
    elem := c.lru.PushFront(e)
    c.cache[key] = elem
}
```

### 7.2 å¢é‡æ›´æ–°

**é—®é¢˜**: æ¯æ¬¡æ•°æ®å˜åŒ–éƒ½é‡å»ºç´¢å¼•æˆæœ¬é«˜

**è§£å†³**: å¢é‡æ›´æ–°ç´¢å¼•

```go
func (idx *TripleIndex) AddTriple(s, p, o string) {
    // SPOç´¢å¼•
    if idx.spo[s] == nil {
        idx.spo[s] = make(map[string][]string)
    }
    idx.spo[s][p] = append(idx.spo[s][p], o)
    
    // POSç´¢å¼•
    if idx.pos[p] == nil {
        idx.pos[p] = make(map[string][]string)
    }
    idx.pos[p][o] = append(idx.pos[p][o], s)
    
    // OSPç´¢å¼•
    if idx.osp[o] == nil {
        idx.osp[o] = make(map[string][]string)
    }
    idx.osp[o][s] = append(idx.osp[o][s], p)
}

func (idx *TripleIndex) RemoveTriple(s, p, o string) {
    // ä»ä¸‰ä¸ªç´¢å¼•ä¸­ç§»é™¤
    removeFromIndex(idx.spo[s], p, o)
    removeFromIndex(idx.pos[p], o, s)
    removeFromIndex(idx.osp[o], s, p)
}
```

### 7.3 å¹¶è¡Œæ„å»º

**ç­–ç•¥**: åˆ†ç‰‡å¹¶è¡Œæ„å»ºç´¢å¼•

```go
func BuildIndexParallel(data []Entry, numWorkers int) *Index {
    shards := partition(data, numWorkers)
    results := make(chan *Index, numWorkers)
    
    for _, shard := range shards {
        go func(s []Entry) {
            results <- buildIndexShard(s)
        }(shard)
    }
    
    // åˆå¹¶ç»“æœ
    idx := NewIndex()
    for i := 0; i < numWorkers; i++ {
        shardIdx := <-results
        idx.Merge(shardIdx)
    }
    
    return idx
}
```

---

## 8. OPAä¸­çš„å®ç°

### 8.1 æ•°æ®ç»“æ„

```go
// BaseDocumentIndexer: OPAçš„æ ¸å¿ƒç´¢å¼•
type baseDocumentIndexer struct {
    root *trieNode  // è§„åˆ™Trie
}

type trieNode struct {
    children map[string]*trieNode
    rules    []*ast.Rule
}

// ä¸‰å…ƒç´¢å¼•
type tripleIndex struct {
    spo map[string]map[string][]string
    pos map[string]map[string][]string
    osp map[string]map[string][]string
}
```

### 8.2 æ ¸å¿ƒç®—æ³•

**æ„å»ºç´¢å¼•**:

```go
func (idx *baseDocumentIndexer) Build(rules []*ast.Rule) {
    for _, rule := range rules {
        path := rule.Head.Ref
        
        // éå†Trieåˆ°è·¯å¾„ä½ç½®
        node := idx.root
        for _, segment := range path {
            key := segment.Value.(ast.String)
            if node.children[key] == nil {
                node.children[key] = &trieNode{
                    children: make(map[string]*trieNode),
                }
            }
            node = node.children[key]
        }
        
        // æ·»åŠ è§„åˆ™åˆ°èŠ‚ç‚¹
        node.rules = append(node.rules, rule)
    }
}
```

**æŸ¥è¯¢ç´¢å¼•**:

```go
func (idx *baseDocumentIndexer) Lookup(ref ast.Ref) []*ast.Rule {
    node := idx.root
    
    for _, term := range ref {
        // å¤„ç†å˜é‡
        if _, ok := term.Value.(ast.Var); ok {
            // è¿”å›æ‰€æœ‰å­æ ‘çš„è§„åˆ™
            return node.AllRules()
        }
        
        // ç²¾ç¡®åŒ¹é…
        key := term.Value.(ast.String)
        node = node.children[key]
        if node == nil {
            return nil
        }
    }
    
    return node.rules
}
```

### 8.3 ä¼˜åŒ–æŠ€æœ¯

1. **æ‡’åŠ è½½**: åªåœ¨éœ€è¦æ—¶æ„å»ºç´¢å¼•
2. **å¢é‡ç¼–è¯‘**: åªæ›´æ–°å˜åŒ–çš„éƒ¨åˆ†
3. **ç¼“å­˜**: ç¼“å­˜å¸¸ç”¨æŸ¥è¯¢ç»“æœ
4. **åˆ†ç‰‡**: å¤§æ•°æ®é›†åˆ†ç‰‡ç´¢å¼•

---

## 9. å¤æ‚åº¦åˆ†æ

### 9.1 æ—¶é—´å¤æ‚åº¦

| æ“ä½œ | Trie | Hash | B-Tree | Triple |
|------|------|------|--------|--------|
| æ’å…¥ | O(m) | O(1) | O(log n) | O(1) |
| æŸ¥è¯¢ | O(m) | O(1) | O(log n) | O(log n) |
| åˆ é™¤ | O(m) | O(1) | O(log n) | O(1) |
| å‰ç¼€æŸ¥è¯¢ | O(m+k) | N/A | N/A | N/A |
| èŒƒå›´æŸ¥è¯¢ | N/A | N/A | O(log n+k) | O(log n+k) |

å…¶ä¸­ï¼š

- m: é”®é•¿åº¦
- n: æ€»æ¡ç›®æ•°
- k: ç»“æœæ•°é‡

### 9.2 ç©ºé—´å¤æ‚åº¦

| æ•°æ®ç»“æ„ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|----------|-----------|------|
| Trie | O(Î£ é”®é•¿åº¦) | å‰ç¼€å…±äº« |
| Hash | O(n) | æ¯æ¡ç›®ä¸€ä¸ªæ§½ä½ |
| B-Tree | O(n) | å¹³è¡¡æ ‘ |
| Triple (3ä¸ªç´¢å¼•) | O(3n) | ä¸‰å€å­˜å‚¨ |

### 9.3 æƒè¡¡åˆ†æ

**ç©ºé—´ vs æ—¶é—´**:

- Triple Index: 3å€ç©ºé—´ï¼Œä½†æŸ¥è¯¢å¿«
- å•ä¸€ç´¢å¼•: èŠ‚çœç©ºé—´ï¼Œä½†æŸäº›æŸ¥è¯¢æ…¢

**æ›´æ–° vs æŸ¥è¯¢**:

- é¢‘ç¹æ›´æ–°: ä½¿ç”¨ç®€å•ç´¢å¼•ï¼ˆHashï¼‰
- é¢‘ç¹æŸ¥è¯¢: ä½¿ç”¨å¤æ‚ç´¢å¼•ï¼ˆB-Tree, Tripleï¼‰

---

## 10. å®æˆ˜ç¤ºä¾‹

### 10.1 ç®€å•æŸ¥è¯¢

**ç­–ç•¥**:

```rego
package example

allow {
    input.user == "alice"
    data.roles["alice"] == "admin"
}
```

**æŸ¥è¯¢æ‰§è¡Œ**:

```text
1. ç´¢å¼•æŸ¥è¯¢: data.roles["alice"]
   â†’ ä½¿ç”¨PathIndex â†’ O(1)
   
2. æ¯”è¾ƒ: == "admin"
   â†’ ç›´æ¥æ¯”è¾ƒ â†’ O(1)

æ€»æ—¶é—´: O(1)
æ— ç´¢å¼•: O(n) éå†æ‰€æœ‰roles
```

### 10.2 å¤æ‚æŸ¥è¯¢

**ç­–ç•¥**:

```rego
package example

managers[name] {
    data.employees[name].role == "manager"
    data.employees[name].dept == "eng"
}
```

**æŸ¥è¯¢æ‰§è¡Œ**:

```text
æ–¹æ³•1: å…¨æ‰«æ
  éå†æ‰€æœ‰employees â†’ O(n)

æ–¹æ³•2: ä½¿ç”¨Triple Index POS
  1. æŸ¥è¯¢ (*, role, manager) â†’ [alice, bob, charlie]
  2. æŸ¥è¯¢ (*, dept, eng) â†’ [alice, dave]
  3. äº¤é›† â†’ [alice]
  
  æ—¶é—´: O(log n + k) å…¶ä¸­kæ˜¯ä¸­é—´ç»“æœå¤§å°
```

### 10.3 æ€§èƒ½å¯¹æ¯”

**æµ‹è¯•è®¾ç½®**:

- 10,000æ¡è§„åˆ™
- 100,000æ¡æ•°æ®
- æŸ¥è¯¢: `data.users[x].role == "admin"`

**ç»“æœ**:

| å®ç° | æŸ¥è¯¢æ—¶é—´ | å†…å­˜ä½¿ç”¨ |
|------|---------|---------|
| æ— ç´¢å¼•ï¼ˆå…¨æ‰«æï¼‰ | 15ms | 10MB |
| å“ˆå¸Œç´¢å¼• | 0.1ms | 15MB |
| Trieç´¢å¼• | 0.2ms | 12MB |
| Tripleç´¢å¼• | 0.08ms | 30MB |

**ç»“è®º**: Tripleç´¢å¼•æœ€å¿«ï¼Œä½†å†…å­˜ä½¿ç”¨æœ€å¤š

---

## é™„å½•

### A. æ•°æ®ç»“æ„å‚è€ƒ

**æ¨èé˜…è¯»**:

- Introduction to Algorithms (CLRS) - å“ˆå¸Œè¡¨ã€Bæ ‘
- The Art of Computer Programming (Knuth) - Trie
- RDF Database Systems (Alexaki et al.) - Triple Store

### B. å®ç°ä»£ç 

å®Œæ•´çš„å‚è€ƒå®ç°è§:

- [ç´¢å¼•ç³»ç»Ÿå®ç°](../10-æºç åˆ†æ/10.7-ç´¢å¼•ç³»ç»Ÿå®ç°.md)
- OPAæºç : `topdown/indexer.go`

### C. æ€§èƒ½åŸºå‡†

**åŸºå‡†æµ‹è¯•å‘½ä»¤**:

```bash
# OPAæ€§èƒ½æµ‹è¯•
opa test --bench ./policies/

# æŸ¥çœ‹ç´¢å¼•ç»Ÿè®¡
opa run --explain=debug --format=pretty query.rego
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
**ç»´æŠ¤è€…**: OPAæŠ€æœ¯æ–‡æ¡£é¡¹ç›®

**ç›¸å…³é˜…è¯»**:

- [æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•](11.4-æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•.md) - æŸ¥è¯¢è§„åˆ’
- [ç´¢å¼•ç³»ç»Ÿå®ç°](../10-æºç åˆ†æ/10.7-ç´¢å¼•ç³»ç»Ÿå®ç°.md) - æºç åˆ†æ
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../05-æœ€ä½³å®è·µ/05.6-æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md) - å®è·µå»ºè®®
