# Top-Downæ±‚å€¼å™¨æºç 

> **æ–‡æ¡£ç±»å‹**: æºç å®ç°åˆ†æ  
> **æ ¸å¿ƒæ¨¡å—**: `topdown/topdown.go`, `topdown/eval.go`  
> **é€‚ç”¨è¯»è€…**: è¿è¡Œæ—¶å¼€å‘è€…ã€æ€§èƒ½ä¼˜åŒ–å·¥ç¨‹å¸ˆ  
> **å…ˆä¿®çŸ¥è¯†**: [Top-Downæ±‚å€¼å™¨åŸç†](../03-å®ç°æ¶æ„/03.4-Top-Downæ±‚å€¼å™¨.md)  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 2.5 - æ±‚å€¼å™¨æºç   
> **OPAç‰ˆæœ¬**: v0.68.0

---

## ğŸ“‹ æ–‡æ¡£æ‘˜è¦

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æOPA Top-Downæ±‚å€¼å™¨çš„æºç å®ç°ï¼ŒåŒ…æ‹¬ï¼š

- **æ±‚å€¼å™¨æ¶æ„**: æ ¸å¿ƒæ•°æ®ç»“æ„å’Œæ¥å£
- **SLD-Resolution**: ç®—æ³•å®ç°ç»†èŠ‚
- **ç»Ÿä¸€ä¸å›æº¯**: Robinsonç»Ÿä¸€ç®—æ³•
- **å˜é‡ç»‘å®š**: ç¯å¢ƒç®¡ç†æœºåˆ¶
- **ä¼˜åŒ–æŠ€æœ¯**: ç´¢å¼•ã€ç¼“å­˜ã€å‰ªæ

**æ ¸å¿ƒæ–‡ä»¶**:

- `topdown/topdown.go` - æ±‚å€¼å™¨ä¸»ä½“
- `topdown/eval.go` - è¡¨è¾¾å¼æ±‚å€¼
- `topdown/unify.go` - ç»Ÿä¸€ç®—æ³•
- `topdown/bindings.go` - å˜é‡ç»‘å®š

---

## 1. æ±‚å€¼å™¨æ¶æ„

### 1.1 Queryå‡½æ•°

```go
// Query: æŸ¥è¯¢å…¥å£
func Query(ctx context.Context, q QueryParams) (QueryResult, error) {
    // åˆ›å»ºæ±‚å€¼å™¨
    eval := &eval{
        ctx:         ctx,
        query:       q.Query,
        input:       q.Input,
        store:       q.Store,
        txn:         q.Transaction,
        compiler:    q.Compiler,
        bindings:    newBindings(),
        traceStack:  make([]Event, 0),
    }
    
    // æ‰§è¡Œæ±‚å€¼
    return eval.run()
}

// QueryParams: æŸ¥è¯¢å‚æ•°
type QueryParams struct {
    Query      Body              // æŸ¥è¯¢
    Input      *interface{}      // è¾“å…¥
    Store      storage.Store     // å­˜å‚¨
    Transaction storage.Transaction
    Compiler   *ast.Compiler     // ç¼–è¯‘å™¨
    Tracer     Tracer           // è·Ÿè¸ªå™¨
    Metrics    metrics.Metrics   // æŒ‡æ ‡
}
```

### 1.2 evalç»“æ„

```go
// eval: æ±‚å€¼å™¨çŠ¶æ€
type eval struct {
    // ä¸Šä¸‹æ–‡
    ctx context.Context
    
    // æŸ¥è¯¢
    query Body
    input *interface{}
    
    // å­˜å‚¨
    store storage.Store
    txn   storage.Transaction
    
    // ç¼–è¯‘å™¨
    compiler *ast.Compiler
    
    // å˜é‡ç»‘å®š
    bindings *bindings
    
    // å›æº¯æ ˆ
    choiceStack []choice
    
    // è·Ÿè¸ª
    traceStack []Event
    tracer     Tracer
    
    // ç¼“å­˜
    cache *cache
    
    // ç»“æœ
    results []map[Var]Value
}
```

---

## 2. æ±‚å€¼ä¸»å¾ªç¯

### 2.1 runæ–¹æ³•

```go
// run: æ‰§è¡Œæ±‚å€¼
func (e *eval) run() (QueryResult, error) {
    // åˆå§‹åŒ–
    e.cache = newCache()
    
    // ä¸»å¾ªç¯
    for {
        // æ±‚å€¼æŸ¥è¯¢
        err := e.evalQuery(e.query, 0)
        
        if err == errBacktrack {
            // å›æº¯åˆ°ä¸Šä¸€ä¸ªé€‰æ‹©ç‚¹
            if !e.backtrack() {
                // æ²¡æœ‰æ›´å¤šé€‰æ‹©ç‚¹ï¼Œç»“æŸ
                break
            }
            continue
        }
        
        if err != nil {
            return QueryResult{}, err
        }
        
        // æ‰¾åˆ°ä¸€ä¸ªè§£
        solution := e.bindings.export()
        e.results = append(e.results, solution)
        
        // è§¦å‘å›æº¯å¯»æ‰¾ä¸‹ä¸€ä¸ªè§£
        if !e.backtrack() {
            break
        }
    }
    
    return QueryResult{
        Results: e.results,
    }, nil
}
```

### 2.2 evalQueryæ–¹æ³•

```go
// evalQuery: æ±‚å€¼æŸ¥è¯¢ï¼ˆè¡¨è¾¾å¼åˆ—è¡¨ï¼‰
func (e *eval) evalQuery(query Body, index int) error {
    // æ£€æŸ¥æ˜¯å¦å®Œæˆ
    if index >= len(query) {
        return nil  // æˆåŠŸ
    }
    
    // æ±‚å€¼å½“å‰è¡¨è¾¾å¼
    expr := query[index]
    
    if err := e.evalExpr(expr); err != nil {
        return err
    }
    
    // é€’å½’æ±‚å€¼å‰©ä½™è¡¨è¾¾å¼
    return e.evalQuery(query, index+1)
}
```

---

## 3. è¡¨è¾¾å¼æ±‚å€¼

### 3.1 evalExpræ–¹æ³•

```go
// evalExpr: æ±‚å€¼è¡¨è¾¾å¼
func (e *eval) evalExpr(expr *Expr) error {
    // åº”ç”¨å½“å‰ç»‘å®š
    expr = e.bindings.plug(expr)
    
    // å¤„ç†å¦å®š
    if expr.Negated {
        return e.evalNegation(expr)
    }
    
    // å¤„ç†withè¯­å¥
    if len(expr.With) > 0 {
        return e.evalWith(expr)
    }
    
    // æ ¹æ®è¡¨è¾¾å¼ç±»å‹æ±‚å€¼
    switch terms := expr.Terms.(type) {
    case *Term:
        // å•é¡¹è¡¨è¾¾å¼
        return e.evalTerm(terms)
        
    case []*Term:
        // å¤šé¡¹è¡¨è¾¾å¼ï¼ˆå†…ç½®å‡½æ•°æˆ–è¿ç®—ç¬¦ï¼‰
        return e.evalCall(terms)
        
    case Call:
        // å‡½æ•°è°ƒç”¨
        return e.evalBuiltin(terms)
    }
    
    return nil
}
```

### 3.2 evalCallæ–¹æ³•

```go
// evalCall: æ±‚å€¼å‡½æ•°è°ƒç”¨
func (e *eval) evalCall(terms []*Term) error {
    if len(terms) == 0 {
        return nil
    }
    
    // ç¬¬ä¸€é¡¹æ˜¯å‡½æ•°å
    op := terms[0]
    args := terms[1:]
    
    // åº”ç”¨ç»‘å®šåˆ°å‚æ•°
    for i, arg := range args {
        args[i] = e.bindings.plug(arg)
    }
    
    // æŸ¥æ‰¾å†…ç½®å‡½æ•°
    builtin := getBuiltin(op)
    if builtin == nil {
        return fmt.Errorf("unknown function: %v", op)
    }
    
    // è°ƒç”¨å†…ç½®å‡½æ•°
    return e.evalBuiltinFunc(builtin, args)
}
```

---

## 4. ç»Ÿä¸€ç®—æ³•

### 4.1 unifyæ–¹æ³•

```go
// unify: ç»Ÿä¸€ä¸¤ä¸ªterm
func (e *eval) unify(a, b *Term) error {
    // åº”ç”¨å½“å‰ç»‘å®š
    a = e.bindings.plug(a)
    b = e.bindings.plug(b)
    
    // å¦‚æœç›¸ç­‰ï¼Œç»Ÿä¸€æˆåŠŸ
    if a.Equal(b) {
        return nil
    }
    
    // å¦‚æœaæ˜¯å˜é‡ï¼Œç»‘å®šåˆ°b
    if v, ok := a.Value.(Var); ok {
        return e.bindings.bind(v, b)
    }
    
    // å¦‚æœbæ˜¯å˜é‡ï¼Œç»‘å®šåˆ°a
    if v, ok := b.Value.(Var); ok {
        return e.bindings.bind(v, a)
    }
    
    // é€’å½’ç»Ÿä¸€å¤åˆç±»å‹
    switch aVal := a.Value.(type) {
    case Ref:
        bVal, ok := b.Value.(Ref)
        if !ok || len(aVal) != len(bVal) {
            return errUnifyFailed
        }
        return e.unifyRefs(aVal, bVal)
        
    case Array:
        bVal, ok := b.Value.(Array)
        if !ok || len(aVal) != len(bVal) {
            return errUnifyFailed
        }
        return e.unifyArrays(aVal, bVal)
        
    case Object:
        bVal, ok := b.Value.(Object)
        if !ok {
            return errUnifyFailed
        }
        return e.unifyObjects(aVal, bVal)
        
    default:
        return errUnifyFailed
    }
}
```

### 4.2 å˜é‡ç»‘å®š

```go
// bindings: å˜é‡ç»‘å®šç¯å¢ƒ
type bindings struct {
    values map[Var]*Term
    trail  []Var  // ç»‘å®šå†å²ï¼ˆç”¨äºå›æº¯ï¼‰
}

// newBindings: åˆ›å»ºç»‘å®šç¯å¢ƒ
func newBindings() *bindings {
    return &bindings{
        values: make(map[Var]*Term),
        trail:  []Var{},
    }
}

// bind: ç»‘å®šå˜é‡
func (b *bindings) bind(v Var, term *Term) error {
    // å‘ç”Ÿæ£€æŸ¥ï¼ˆé˜²æ­¢å¾ªç¯ç»‘å®šï¼‰
    if occursIn(v, term) {
        return errOccursCheck
    }
    
    b.values[v] = term
    b.trail = append(b.trail, v)
    
    return nil
}

// plug: åº”ç”¨ç»‘å®šåˆ°term
func (b *bindings) plug(term *Term) *Term {
    switch val := term.Value.(type) {
    case Var:
        if bound, ok := b.values[val]; ok {
            // é€’å½’åº”ç”¨ï¼ˆå¤„ç†ä¼ é€’ç»‘å®šï¼‰
            return b.plug(bound)
        }
        return term
        
    case Ref:
        // åº”ç”¨åˆ°å¼•ç”¨çš„æ¯ä¸ªå…ƒç´ 
        ref := make(Ref, len(val))
        for i, t := range val {
            ref[i] = b.plug(t)
        }
        return &Term{Value: ref}
        
    // ... å…¶ä»–ç±»å‹ ...
    }
    
    return term
}

// checkpoint: åˆ›å»ºæ£€æŸ¥ç‚¹ï¼ˆç”¨äºå›æº¯ï¼‰
func (b *bindings) checkpoint() int {
    return len(b.trail)
}

// restore: æ¢å¤åˆ°æ£€æŸ¥ç‚¹
func (b *bindings) restore(cp int) {
    // æ’¤é”€checkpointä¹‹åçš„æ‰€æœ‰ç»‘å®š
    for i := len(b.trail) - 1; i >= cp; i-- {
        v := b.trail[i]
        delete(b.values, v)
    }
    b.trail = b.trail[:cp]
}
```

---

## 5. å›æº¯æœºåˆ¶

### 5.1 choiceç»“æ„

```go
// choice: é€‰æ‹©ç‚¹
type choice struct {
    expr        *Expr          // è¡¨è¾¾å¼
    alternatives []alternative // å¯é€‰åˆ†æ”¯
    index       int            // å½“å‰åˆ†æ”¯ç´¢å¼•
    checkpoint  int            // ç»‘å®šæ£€æŸ¥ç‚¹
}

// alternative: å¯é€‰åˆ†æ”¯
type alternative struct {
    rule    *Rule    // è§„åˆ™
    bindings map[Var]*Term  // é¢å¤–ç»‘å®š
}
```

### 5.2 backtrackæ–¹æ³•

```go
// backtrack: å›æº¯
func (e *eval) backtrack() bool {
    // æ£€æŸ¥é€‰æ‹©æ ˆ
    if len(e.choiceStack) == 0 {
        return false  // æ²¡æœ‰é€‰æ‹©ç‚¹
    }
    
    // å¼¹å‡ºæœ€è¿‘çš„é€‰æ‹©ç‚¹
    choice := e.choiceStack[len(e.choiceStack)-1]
    
    // æ¢å¤å˜é‡ç»‘å®š
    e.bindings.restore(choice.checkpoint)
    
    // å°è¯•ä¸‹ä¸€ä¸ªå¯é€‰åˆ†æ”¯
    choice.index++
    
    if choice.index >= len(choice.alternatives) {
        // æ­¤é€‰æ‹©ç‚¹çš„æ‰€æœ‰åˆ†æ”¯éƒ½å°è¯•è¿‡äº†
        e.choiceStack = e.choiceStack[:len(e.choiceStack)-1]
        
        // ç»§ç»­å›æº¯
        return e.backtrack()
    }
    
    // åº”ç”¨ä¸‹ä¸€ä¸ªåˆ†æ”¯
    alt := choice.alternatives[choice.index]
    
    // åº”ç”¨è§„åˆ™å¤´éƒ¨çš„ç»‘å®š
    for v, term := range alt.bindings {
        e.bindings.bind(v, term)
    }
    
    // æ±‚å€¼è§„åˆ™ä½“
    if err := e.evalQuery(alt.rule.Body, 0); err != nil {
        if err == errBacktrack {
            return e.backtrack()
        }
        return false
    }
    
    return true
}
```

---

## 6. è§„åˆ™åŒ¹é…

### 6.1 evalRefæ–¹æ³•

```go
// evalRef: æ±‚å€¼å¼•ç”¨ï¼ˆæŸ¥æ‰¾è§„åˆ™ï¼‰
func (e *eval) evalRef(ref Ref) error {
    // æŸ¥æ‰¾åŒ¹é…çš„è§„åˆ™
    rules := e.compiler.ModuleTree.Lookup(ref)
    
    if len(rules) == 0 {
        // å°è¯•ä»å­˜å‚¨ä¸­è¯»å–
        return e.evalData(ref)
    }
    
    // åˆ›å»ºé€‰æ‹©ç‚¹
    cp := e.bindings.checkpoint()
    
    alternatives := make([]alternative, len(rules))
    for i, rule := range rules {
        // å°è¯•ç»Ÿä¸€è§„åˆ™å¤´éƒ¨
        bindings, err := e.matchRuleHead(rule.Head, ref)
        if err != nil {
            continue
        }
        
        alternatives[i] = alternative{
            rule:     rule,
            bindings: bindings,
        }
    }
    
    if len(alternatives) == 0 {
        return errBacktrack
    }
    
    // å¦‚æœæœ‰å¤šä¸ªå¯é€‰è§„åˆ™ï¼Œåˆ›å»ºé€‰æ‹©ç‚¹
    if len(alternatives) > 1 {
        e.choiceStack = append(e.choiceStack, choice{
            alternatives: alternatives,
            index:       -1,
            checkpoint:  cp,
        })
    }
    
    // å°è¯•ç¬¬ä¸€ä¸ªè§„åˆ™
    alt := alternatives[0]
    for v, term := range alt.bindings {
        e.bindings.bind(v, term)
    }
    
    return e.evalQuery(alt.rule.Body, 0)
}
```

### 6.2 matchRuleHeadæ–¹æ³•

```go
// matchRuleHead: åŒ¹é…è§„åˆ™å¤´éƒ¨
func (e *eval) matchRuleHead(head *Head, ref Ref) (map[Var]*Term, error) {
    // æ„å»ºè§„åˆ™å¤´éƒ¨çš„å®Œæ•´å¼•ç”¨
    headRef := head.Reference
    
    // å°è¯•ç»Ÿä¸€
    bindings := make(map[Var]*Term)
    
    if len(headRef) != len(ref) {
        return nil, errMatchFailed
    }
    
    for i := range headRef {
        a := headRef[i]
        b := ref[i]
        
        // åº”ç”¨ç»‘å®š
        a = e.bindings.plug(a)
        b = e.bindings.plug(b)
        
        if a.Equal(b) {
            continue
        }
        
        // å¦‚æœaæ˜¯å˜é‡ï¼Œè®°å½•ç»‘å®š
        if v, ok := a.Value.(Var); ok {
            bindings[v] = b
            continue
        }
        
        // å¦‚æœbæ˜¯å˜é‡ï¼Œè®°å½•ç»‘å®š
        if v, ok := b.Value.(Var); ok {
            bindings[v] = a
            continue
        }
        
        // æ— æ³•åŒ¹é…
        return nil, errMatchFailed
    }
    
    return bindings, nil
}
```

---

## 7. æ•°æ®è¯»å–

### 7.1 evalDataæ–¹æ³•

```go
// evalData: ä»å­˜å‚¨è¯»å–æ•°æ®
func (e *eval) evalData(ref Ref) error {
    // æ„å»ºå­˜å‚¨è·¯å¾„
    path := refToPath(ref)
    
    // ä»å­˜å‚¨è¯»å–
    value, err := e.store.Read(e.ctx, e.txn, path)
    if err != nil {
        if storage.IsNotFound(err) {
            return errBacktrack  // æœªæ‰¾åˆ°è§†ä¸ºå¤±è´¥
        }
        return err
    }
    
    // å°†JSONå€¼è½¬æ¢ä¸ºTerm
    term := jsonToTerm(value)
    
    // ç»Ÿä¸€è¯»å–çš„å€¼
    refTerm := &Term{Value: ref}
    return e.unify(refTerm, term)
}

// refToPath: å¼•ç”¨è½¬è·¯å¾„
func refToPath(ref Ref) storage.Path {
    path := make(storage.Path, len(ref))
    
    for i, term := range ref {
        // åªæ”¯æŒground term
        if !term.IsGround() {
            return nil
        }
        
        path[i] = termToPathElement(term)
    }
    
    return path
}
```

---

## 8. å¦å®šä¸with

### 8.1 evalNegationæ–¹æ³•

```go
// evalNegation: æ±‚å€¼å¦å®šè¡¨è¾¾å¼
func (e *eval) evalNegation(expr *Expr) error {
    // åˆ›å»ºå­æ±‚å€¼å™¨
    subEval := e.clone()
    
    // å°è¯•æ±‚å€¼å†…éƒ¨è¡¨è¾¾å¼
    posExpr := *expr
    posExpr.Negated = false
    
    err := subEval.evalExpr(&posExpr)
    
    if err == errBacktrack {
        // å†…éƒ¨å¤±è´¥ï¼Œå¦å®šæˆåŠŸ
        return nil
    }
    
    if err != nil {
        return err
    }
    
    // å†…éƒ¨æˆåŠŸï¼Œå¦å®šå¤±è´¥
    return errBacktrack
}
```

### 8.2 evalWithæ–¹æ³•

```go
// evalWith: æ±‚å€¼withè¯­å¥
func (e *eval) evalWith(expr *Expr) error {
    // ä¿å­˜å½“å‰çŠ¶æ€
    savedInput := e.input
    savedStore := e.store
    
    // åº”ç”¨withæ›¿æ¢
    for _, with := range expr.With {
        target := e.bindings.plug(with.Target)
        value := e.bindings.plug(with.Value)
        
        // ä¸´æ—¶æ›¿æ¢
        if isInputRef(target) {
            e.input = termToJSON(value)
        } else if isDataRef(target) {
            // åˆ›å»ºè™šæ‹Ÿå­˜å‚¨å±‚
            e.store = newVirtualStore(e.store, target, value)
        }
    }
    
    // æ±‚å€¼è¡¨è¾¾å¼
    baseExpr := *expr
    baseExpr.With = nil
    err := e.evalExpr(&baseExpr)
    
    // æ¢å¤çŠ¶æ€
    e.input = savedInput
    e.store = savedStore
    
    return err
}
```

---

## 9. å†…ç½®å‡½æ•°

### 9.1 å†…ç½®å‡½æ•°æ³¨å†Œ

```go
// builtinRegistry: å†…ç½®å‡½æ•°æ³¨å†Œè¡¨
var builtinRegistry = map[string]BuiltinFunc{}

// BuiltinFunc: å†…ç½®å‡½æ•°ç±»å‹
type BuiltinFunc func(*eval, []*Term) error

// RegisterBuiltin: æ³¨å†Œå†…ç½®å‡½æ•°
func RegisterBuiltin(name string, fn BuiltinFunc) {
    builtinRegistry[name] = fn
}

// getBuiltin: è·å–å†…ç½®å‡½æ•°
func getBuiltin(op *Term) BuiltinFunc {
    ref, ok := op.Value.(Ref)
    if !ok || len(ref) == 0 {
        return nil
    }
    
    name := ref[0].String()
    return builtinRegistry[name]
}
```

### 9.2 ç¤ºä¾‹å†…ç½®å‡½æ•°

```go
// count: è®¡æ•°å‡½æ•°
func builtinCount(e *eval, args []*Term) error {
    if len(args) != 2 {
        return fmt.Errorf("count requires 2 arguments")
    }
    
    coll := e.bindings.plug(args[0])
    out := args[1]
    
    var count int
    
    switch val := coll.Value.(type) {
    case Array:
        count = len(val)
    case Set:
        count = len(val)
    case Object:
        count = len(val)
    case String:
        count = len(val)
    default:
        return fmt.Errorf("count: unsupported type")
    }
    
    // ç»Ÿä¸€è¾“å‡º
    return e.unify(out, IntNumberTerm(int64(count)))
}

// æ³¨å†Œ
func init() {
    RegisterBuiltin("count", builtinCount)
}
```

---

## 10. æ€§èƒ½ä¼˜åŒ–

### 10.1 ç¼“å­˜æœºåˆ¶

```go
// cache: æ±‚å€¼ç¼“å­˜
type cache struct {
    rules  map[string][]Result  // è§„åˆ™ç»“æœç¼“å­˜
    exprs  map[string][]Result  // è¡¨è¾¾å¼ç»“æœç¼“å­˜
}

// Result: ç¼“å­˜ç»“æœ
type Result struct {
    bindings map[Var]*Term
    success  bool
}

// lookup: æŸ¥æ‰¾ç¼“å­˜
func (c *cache) lookup(key string) ([]Result, bool) {
    results, ok := c.rules[key]
    return results, ok
}

// store: å­˜å‚¨åˆ°ç¼“å­˜
func (c *cache) store(key string, results []Result) {
    c.rules[key] = results
}
```

### 10.2 ç´¢å¼•åŠ é€Ÿ

```go
// ä½¿ç”¨ç´¢å¼•åŠ é€Ÿè§„åˆ™æŸ¥æ‰¾
func (e *eval) evalRefWithIndex(ref Ref) error {
    // æŸ¥æ‰¾ç´¢å¼•
    index := e.compiler.RuleIndex.Lookup(ref)
    
    if index != nil {
        // ä½¿ç”¨ç´¢å¼•å¿«é€ŸæŸ¥æ‰¾
        rules := index.Match(ref)
        return e.evalRules(rules)
    }
    
    // å›é€€åˆ°çº¿æ€§æŸ¥æ‰¾
    return e.evalRef(ref)
}
```

---

## 11. è·Ÿè¸ªä¸è°ƒè¯•

### 11.1 Traceræ¥å£

```go
// Tracer: è·Ÿè¸ªå™¨æ¥å£
type Tracer interface {
    Trace(*Event)
}

// Event: è·Ÿè¸ªäº‹ä»¶
type Event struct {
    Op       string      // æ“ä½œï¼šenter, exit, redo
    Node     *Expr       // å½“å‰è¡¨è¾¾å¼
    Bindings map[Var]*Term  // å½“å‰ç»‘å®š
    Time     time.Time   // æ—¶é—´æˆ³
}

// trace: è®°å½•è·Ÿè¸ªäº‹ä»¶
func (e *eval) trace(op string, expr *Expr) {
    if e.tracer == nil {
        return
    }
    
    event := &Event{
        Op:       op,
        Node:     expr,
        Bindings: e.bindings.export(),
        Time:     time.Now(),
    }
    
    e.tracer.Trace(event)
}
```

---

## 12. å®Œæ•´ç¤ºä¾‹

### 12.1 ç®€å•æŸ¥è¯¢æ‰§è¡Œ

```go
// æŸ¥è¯¢: input.method == "GET"
func ExampleSimpleQuery() {
    // åˆ›å»ºç¼–è¯‘å™¨
    compiler := ast.NewCompiler()
    compiler.Compile(modules)
    
    // è§£ææŸ¥è¯¢
    query, _ := ast.ParseBody(`input.method == "GET"`)
    
    // å‡†å¤‡è¾“å…¥
    input := map[string]interface{}{
        "method": "GET",
    }
    
    // æ‰§è¡ŒæŸ¥è¯¢
    ctx := context.Background()
    result, err := Query(ctx, QueryParams{
        Query:    query,
        Input:    &input,
        Compiler: compiler,
    })
    
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Results: %d\n", len(result.Results))
    // è¾“å‡º: Results: 1
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥

**ç›¸å…³é˜…è¯»**:

- [Top-Downæ±‚å€¼å™¨åŸç†](../03-å®ç°æ¶æ„/03.4-Top-Downæ±‚å€¼å™¨.md)
- [å†…ç½®å‡½æ•°å®ç°æœºåˆ¶](10.6-å†…ç½®å‡½æ•°å®ç°æœºåˆ¶.md)
- [æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜](../06-å½¢å¼åŒ–è¯æ˜/06.4-æ±‚å€¼ç®—æ³•æ­£ç¡®æ€§è¯æ˜.md)
