# Top-Down求值器源码

> **文档类型**: 源码实现分析  
> **核心模块**: `topdown/topdown.go`, `topdown/eval.go`  
> **适用读者**: 运行时开发者、性能优化工程师  
> **先修知识**: [Top-Down求值器原理](../03-实现架构/03.4-Top-Down求值器.md)  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 2.5 - 求值器源码  
> **OPA版本**: v0.68.0

---

## 📋 文档摘要

本文档深入分析OPA Top-Down求值器的源码实现，包括：

- **求值器架构**: 核心数据结构和接口
- **SLD-Resolution**: 算法实现细节
- **统一与回溯**: Robinson统一算法
- **变量绑定**: 环境管理机制
- **优化技术**: 索引、缓存、剪枝

**核心文件**:

- `topdown/topdown.go` - 求值器主体
- `topdown/eval.go` - 表达式求值
- `topdown/unify.go` - 统一算法
- `topdown/bindings.go` - 变量绑定

---

## 1. 求值器架构

### 1.1 Query函数

```go
// Query: 查询入口
func Query(ctx context.Context, q QueryParams) (QueryResult, error) {
    // 创建求值器
    eval := &eval{
        ctx:         ctx,
        query:       q.Query,
        input:       q.Input,
        store:       q.Store,
        txn:         q.Transaction,
        compiler:    q.Compiler,
        bindings:    newBindings(),
        traceStack:  make([]Event, 0),
    }
    
    // 执行求值
    return eval.run()
}

// QueryParams: 查询参数
type QueryParams struct {
    Query      Body              // 查询
    Input      *interface{}      // 输入
    Store      storage.Store     // 存储
    Transaction storage.Transaction
    Compiler   *ast.Compiler     // 编译器
    Tracer     Tracer           // 跟踪器
    Metrics    metrics.Metrics   // 指标
}
```

### 1.2 eval结构

```go
// eval: 求值器状态
type eval struct {
    // 上下文
    ctx context.Context
    
    // 查询
    query Body
    input *interface{}
    
    // 存储
    store storage.Store
    txn   storage.Transaction
    
    // 编译器
    compiler *ast.Compiler
    
    // 变量绑定
    bindings *bindings
    
    // 回溯栈
    choiceStack []choice
    
    // 跟踪
    traceStack []Event
    tracer     Tracer
    
    // 缓存
    cache *cache
    
    // 结果
    results []map[Var]Value
}
```

---

## 2. 求值主循环

### 2.1 run方法

```go
// run: 执行求值
func (e *eval) run() (QueryResult, error) {
    // 初始化
    e.cache = newCache()
    
    // 主循环
    for {
        // 求值查询
        err := e.evalQuery(e.query, 0)
        
        if err == errBacktrack {
            // 回溯到上一个选择点
            if !e.backtrack() {
                // 没有更多选择点，结束
                break
            }
            continue
        }
        
        if err != nil {
            return QueryResult{}, err
        }
        
        // 找到一个解
        solution := e.bindings.export()
        e.results = append(e.results, solution)
        
        // 触发回溯寻找下一个解
        if !e.backtrack() {
            break
        }
    }
    
    return QueryResult{
        Results: e.results,
    }, nil
}
```

### 2.2 evalQuery方法

```go
// evalQuery: 求值查询（表达式列表）
func (e *eval) evalQuery(query Body, index int) error {
    // 检查是否完成
    if index >= len(query) {
        return nil  // 成功
    }
    
    // 求值当前表达式
    expr := query[index]
    
    if err := e.evalExpr(expr); err != nil {
        return err
    }
    
    // 递归求值剩余表达式
    return e.evalQuery(query, index+1)
}
```

---

## 3. 表达式求值

### 3.1 evalExpr方法

```go
// evalExpr: 求值表达式
func (e *eval) evalExpr(expr *Expr) error {
    // 应用当前绑定
    expr = e.bindings.plug(expr)
    
    // 处理否定
    if expr.Negated {
        return e.evalNegation(expr)
    }
    
    // 处理with语句
    if len(expr.With) > 0 {
        return e.evalWith(expr)
    }
    
    // 根据表达式类型求值
    switch terms := expr.Terms.(type) {
    case *Term:
        // 单项表达式
        return e.evalTerm(terms)
        
    case []*Term:
        // 多项表达式（内置函数或运算符）
        return e.evalCall(terms)
        
    case Call:
        // 函数调用
        return e.evalBuiltin(terms)
    }
    
    return nil
}
```

### 3.2 evalCall方法

```go
// evalCall: 求值函数调用
func (e *eval) evalCall(terms []*Term) error {
    if len(terms) == 0 {
        return nil
    }
    
    // 第一项是函数名
    op := terms[0]
    args := terms[1:]
    
    // 应用绑定到参数
    for i, arg := range args {
        args[i] = e.bindings.plug(arg)
    }
    
    // 查找内置函数
    builtin := getBuiltin(op)
    if builtin == nil {
        return fmt.Errorf("unknown function: %v", op)
    }
    
    // 调用内置函数
    return e.evalBuiltinFunc(builtin, args)
}
```

---

## 4. 统一算法

### 4.1 unify方法

```go
// unify: 统一两个term
func (e *eval) unify(a, b *Term) error {
    // 应用当前绑定
    a = e.bindings.plug(a)
    b = e.bindings.plug(b)
    
    // 如果相等，统一成功
    if a.Equal(b) {
        return nil
    }
    
    // 如果a是变量，绑定到b
    if v, ok := a.Value.(Var); ok {
        return e.bindings.bind(v, b)
    }
    
    // 如果b是变量，绑定到a
    if v, ok := b.Value.(Var); ok {
        return e.bindings.bind(v, a)
    }
    
    // 递归统一复合类型
    switch aVal := a.Value.(type) {
    case Ref:
        bVal, ok := b.Value.(Ref)
        if !ok || len(aVal) != len(bVal) {
            return errUnifyFailed
        }
        return e.unifyRefs(aVal, bVal)
        
    case Array:
        bVal, ok := b.Value.(Array)
        if !ok || len(aVal) != len(bVal) {
            return errUnifyFailed
        }
        return e.unifyArrays(aVal, bVal)
        
    case Object:
        bVal, ok := b.Value.(Object)
        if !ok {
            return errUnifyFailed
        }
        return e.unifyObjects(aVal, bVal)
        
    default:
        return errUnifyFailed
    }
}
```

### 4.2 变量绑定

```go
// bindings: 变量绑定环境
type bindings struct {
    values map[Var]*Term
    trail  []Var  // 绑定历史（用于回溯）
}

// newBindings: 创建绑定环境
func newBindings() *bindings {
    return &bindings{
        values: make(map[Var]*Term),
        trail:  []Var{},
    }
}

// bind: 绑定变量
func (b *bindings) bind(v Var, term *Term) error {
    // 发生检查（防止循环绑定）
    if occursIn(v, term) {
        return errOccursCheck
    }
    
    b.values[v] = term
    b.trail = append(b.trail, v)
    
    return nil
}

// plug: 应用绑定到term
func (b *bindings) plug(term *Term) *Term {
    switch val := term.Value.(type) {
    case Var:
        if bound, ok := b.values[val]; ok {
            // 递归应用（处理传递绑定）
            return b.plug(bound)
        }
        return term
        
    case Ref:
        // 应用到引用的每个元素
        ref := make(Ref, len(val))
        for i, t := range val {
            ref[i] = b.plug(t)
        }
        return &Term{Value: ref}
        
    // ... 其他类型 ...
    }
    
    return term
}

// checkpoint: 创建检查点（用于回溯）
func (b *bindings) checkpoint() int {
    return len(b.trail)
}

// restore: 恢复到检查点
func (b *bindings) restore(cp int) {
    // 撤销checkpoint之后的所有绑定
    for i := len(b.trail) - 1; i >= cp; i-- {
        v := b.trail[i]
        delete(b.values, v)
    }
    b.trail = b.trail[:cp]
}
```

---

## 5. 回溯机制

### 5.1 choice结构

```go
// choice: 选择点
type choice struct {
    expr        *Expr          // 表达式
    alternatives []alternative // 可选分支
    index       int            // 当前分支索引
    checkpoint  int            // 绑定检查点
}

// alternative: 可选分支
type alternative struct {
    rule    *Rule    // 规则
    bindings map[Var]*Term  // 额外绑定
}
```

### 5.2 backtrack方法

```go
// backtrack: 回溯
func (e *eval) backtrack() bool {
    // 检查选择栈
    if len(e.choiceStack) == 0 {
        return false  // 没有选择点
    }
    
    // 弹出最近的选择点
    choice := e.choiceStack[len(e.choiceStack)-1]
    
    // 恢复变量绑定
    e.bindings.restore(choice.checkpoint)
    
    // 尝试下一个可选分支
    choice.index++
    
    if choice.index >= len(choice.alternatives) {
        // 此选择点的所有分支都尝试过了
        e.choiceStack = e.choiceStack[:len(e.choiceStack)-1]
        
        // 继续回溯
        return e.backtrack()
    }
    
    // 应用下一个分支
    alt := choice.alternatives[choice.index]
    
    // 应用规则头部的绑定
    for v, term := range alt.bindings {
        e.bindings.bind(v, term)
    }
    
    // 求值规则体
    if err := e.evalQuery(alt.rule.Body, 0); err != nil {
        if err == errBacktrack {
            return e.backtrack()
        }
        return false
    }
    
    return true
}
```

---

## 6. 规则匹配

### 6.1 evalRef方法

```go
// evalRef: 求值引用（查找规则）
func (e *eval) evalRef(ref Ref) error {
    // 查找匹配的规则
    rules := e.compiler.ModuleTree.Lookup(ref)
    
    if len(rules) == 0 {
        // 尝试从存储中读取
        return e.evalData(ref)
    }
    
    // 创建选择点
    cp := e.bindings.checkpoint()
    
    alternatives := make([]alternative, len(rules))
    for i, rule := range rules {
        // 尝试统一规则头部
        bindings, err := e.matchRuleHead(rule.Head, ref)
        if err != nil {
            continue
        }
        
        alternatives[i] = alternative{
            rule:     rule,
            bindings: bindings,
        }
    }
    
    if len(alternatives) == 0 {
        return errBacktrack
    }
    
    // 如果有多个可选规则，创建选择点
    if len(alternatives) > 1 {
        e.choiceStack = append(e.choiceStack, choice{
            alternatives: alternatives,
            index:       -1,
            checkpoint:  cp,
        })
    }
    
    // 尝试第一个规则
    alt := alternatives[0]
    for v, term := range alt.bindings {
        e.bindings.bind(v, term)
    }
    
    return e.evalQuery(alt.rule.Body, 0)
}
```

### 6.2 matchRuleHead方法

```go
// matchRuleHead: 匹配规则头部
func (e *eval) matchRuleHead(head *Head, ref Ref) (map[Var]*Term, error) {
    // 构建规则头部的完整引用
    headRef := head.Reference
    
    // 尝试统一
    bindings := make(map[Var]*Term)
    
    if len(headRef) != len(ref) {
        return nil, errMatchFailed
    }
    
    for i := range headRef {
        a := headRef[i]
        b := ref[i]
        
        // 应用绑定
        a = e.bindings.plug(a)
        b = e.bindings.plug(b)
        
        if a.Equal(b) {
            continue
        }
        
        // 如果a是变量，记录绑定
        if v, ok := a.Value.(Var); ok {
            bindings[v] = b
            continue
        }
        
        // 如果b是变量，记录绑定
        if v, ok := b.Value.(Var); ok {
            bindings[v] = a
            continue
        }
        
        // 无法匹配
        return nil, errMatchFailed
    }
    
    return bindings, nil
}
```

---

## 7. 数据读取

### 7.1 evalData方法

```go
// evalData: 从存储读取数据
func (e *eval) evalData(ref Ref) error {
    // 构建存储路径
    path := refToPath(ref)
    
    // 从存储读取
    value, err := e.store.Read(e.ctx, e.txn, path)
    if err != nil {
        if storage.IsNotFound(err) {
            return errBacktrack  // 未找到视为失败
        }
        return err
    }
    
    // 将JSON值转换为Term
    term := jsonToTerm(value)
    
    // 统一读取的值
    refTerm := &Term{Value: ref}
    return e.unify(refTerm, term)
}

// refToPath: 引用转路径
func refToPath(ref Ref) storage.Path {
    path := make(storage.Path, len(ref))
    
    for i, term := range ref {
        // 只支持ground term
        if !term.IsGround() {
            return nil
        }
        
        path[i] = termToPathElement(term)
    }
    
    return path
}
```

---

## 8. 否定与with

### 8.1 evalNegation方法

```go
// evalNegation: 求值否定表达式
func (e *eval) evalNegation(expr *Expr) error {
    // 创建子求值器
    subEval := e.clone()
    
    // 尝试求值内部表达式
    posExpr := *expr
    posExpr.Negated = false
    
    err := subEval.evalExpr(&posExpr)
    
    if err == errBacktrack {
        // 内部失败，否定成功
        return nil
    }
    
    if err != nil {
        return err
    }
    
    // 内部成功，否定失败
    return errBacktrack
}
```

### 8.2 evalWith方法

```go
// evalWith: 求值with语句
func (e *eval) evalWith(expr *Expr) error {
    // 保存当前状态
    savedInput := e.input
    savedStore := e.store
    
    // 应用with替换
    for _, with := range expr.With {
        target := e.bindings.plug(with.Target)
        value := e.bindings.plug(with.Value)
        
        // 临时替换
        if isInputRef(target) {
            e.input = termToJSON(value)
        } else if isDataRef(target) {
            // 创建虚拟存储层
            e.store = newVirtualStore(e.store, target, value)
        }
    }
    
    // 求值表达式
    baseExpr := *expr
    baseExpr.With = nil
    err := e.evalExpr(&baseExpr)
    
    // 恢复状态
    e.input = savedInput
    e.store = savedStore
    
    return err
}
```

---

## 9. 内置函数

### 9.1 内置函数注册

```go
// builtinRegistry: 内置函数注册表
var builtinRegistry = map[string]BuiltinFunc{}

// BuiltinFunc: 内置函数类型
type BuiltinFunc func(*eval, []*Term) error

// RegisterBuiltin: 注册内置函数
func RegisterBuiltin(name string, fn BuiltinFunc) {
    builtinRegistry[name] = fn
}

// getBuiltin: 获取内置函数
func getBuiltin(op *Term) BuiltinFunc {
    ref, ok := op.Value.(Ref)
    if !ok || len(ref) == 0 {
        return nil
    }
    
    name := ref[0].String()
    return builtinRegistry[name]
}
```

### 9.2 示例内置函数

```go
// count: 计数函数
func builtinCount(e *eval, args []*Term) error {
    if len(args) != 2 {
        return fmt.Errorf("count requires 2 arguments")
    }
    
    coll := e.bindings.plug(args[0])
    out := args[1]
    
    var count int
    
    switch val := coll.Value.(type) {
    case Array:
        count = len(val)
    case Set:
        count = len(val)
    case Object:
        count = len(val)
    case String:
        count = len(val)
    default:
        return fmt.Errorf("count: unsupported type")
    }
    
    // 统一输出
    return e.unify(out, IntNumberTerm(int64(count)))
}

// 注册
func init() {
    RegisterBuiltin("count", builtinCount)
}
```

---

## 10. 性能优化

### 10.1 缓存机制

```go
// cache: 求值缓存
type cache struct {
    rules  map[string][]Result  // 规则结果缓存
    exprs  map[string][]Result  // 表达式结果缓存
}

// Result: 缓存结果
type Result struct {
    bindings map[Var]*Term
    success  bool
}

// lookup: 查找缓存
func (c *cache) lookup(key string) ([]Result, bool) {
    results, ok := c.rules[key]
    return results, ok
}

// store: 存储到缓存
func (c *cache) store(key string, results []Result) {
    c.rules[key] = results
}
```

### 10.2 索引加速

```go
// 使用索引加速规则查找
func (e *eval) evalRefWithIndex(ref Ref) error {
    // 查找索引
    index := e.compiler.RuleIndex.Lookup(ref)
    
    if index != nil {
        // 使用索引快速查找
        rules := index.Match(ref)
        return e.evalRules(rules)
    }
    
    // 回退到线性查找
    return e.evalRef(ref)
}
```

---

## 11. 跟踪与调试

### 11.1 Tracer接口

```go
// Tracer: 跟踪器接口
type Tracer interface {
    Trace(*Event)
}

// Event: 跟踪事件
type Event struct {
    Op       string      // 操作：enter, exit, redo
    Node     *Expr       // 当前表达式
    Bindings map[Var]*Term  // 当前绑定
    Time     time.Time   // 时间戳
}

// trace: 记录跟踪事件
func (e *eval) trace(op string, expr *Expr) {
    if e.tracer == nil {
        return
    }
    
    event := &Event{
        Op:       op,
        Node:     expr,
        Bindings: e.bindings.export(),
        Time:     time.Now(),
    }
    
    e.tracer.Trace(event)
}
```

---

## 12. 完整示例

### 12.1 简单查询执行

```go
// 查询: input.method == "GET"
func ExampleSimpleQuery() {
    // 创建编译器
    compiler := ast.NewCompiler()
    compiler.Compile(modules)
    
    // 解析查询
    query, _ := ast.ParseBody(`input.method == "GET"`)
    
    // 准备输入
    input := map[string]interface{}{
        "method": "GET",
    }
    
    // 执行查询
    ctx := context.Background()
    result, err := Query(ctx, QueryParams{
        Query:    query,
        Input:    &input,
        Compiler: compiler,
    })
    
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Results: %d\n", len(result.Results))
    // 输出: Results: 1
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日

**相关阅读**:

- [Top-Down求值器原理](../03-实现架构/03.4-Top-Down求值器.md)
- [内置函数实现机制](10.6-内置函数实现机制.md)
- [求值算法正确性证明](../06-形式化证明/06.4-求值算法正确性证明.md)
