# Bundle管理实现

> **文档类型**: 源码实现分析  
> **核心模块**: `bundle/bundle.go`, `plugins/bundle/`  
> **适用读者**: OPA集成开发者、DevOps工程师  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 2.9 - Bundle管理  
> **OPA版本**: v0.68.0

---

## 📋 文档概述

Bundle是OPA策略和数据的打包分发格式，支持版本管理、签名验证和增量更新。

**核心功能**:

- Bundle构建与打包
- 签名与验证
- 增量更新
- 插件化加载

---

## 1. Bundle结构

### 1.1 Bundle定义

```go
// Bundle: OPA Bundle
type Bundle struct {
    Manifest  Manifest              // 清单
    Data      map[string]interface{} // 数据
    Modules   []ModuleFile          // 策略模块
    Wasm      []byte                // WASM模块（可选）
}

// Manifest: Bundle清单
type Manifest struct {
    Revision  string                 // 版本号
    Roots     []string               // 根路径
    Metadata  map[string]interface{} // 元数据
}

// ModuleFile: 模块文件
type ModuleFile struct {
    Path   string       // 文件路径
    Raw    []byte       // 原始内容
    Parsed *ast.Module  // 解析后的AST
}
```

### 1.2 Bundle格式

```text
bundle.tar.gz
├── .manifest      # JSON清单
├── data.json      # 数据文件
├── policy/        # 策略目录
│   ├── authz.rego
│   └── rbac.rego
└── .signatures.json  # 签名（可选）
```

---

## 2. Bundle构建

### 2.1 Build函数

```go
// Build: 构建Bundle
func Build(opts BuildOptions) (*Bundle, error) {
    b := &Bundle{
        Manifest: Manifest{
            Revision: opts.Revision,
            Roots:    opts.Roots,
        },
        Modules: []ModuleFile{},
        Data:    make(map[string]interface{}),
    }
    
    // 加载策略文件
    if err := loadModules(b, opts.Paths); err != nil {
        return nil, err
    }
    
    // 加载数据文件
    if err := loadData(b, opts.DataPaths); err != nil {
        return nil, err
    }
    
    return b, nil
}

// loadModules: 加载模块
func loadModules(b *Bundle, paths []string) error {
    for _, path := range paths {
        raw, err := ioutil.ReadFile(path)
        if err != nil {
            return err
        }
        
        parsed, err := ast.ParseModule(path, raw)
        if err != nil {
            return err
        }
        
        b.Modules = append(b.Modules, ModuleFile{
            Path:   path,
            Raw:    raw,
            Parsed: parsed,
        })
    }
    
    return nil
}
```

---

## 3. 签名与验证

### 3.1 签名

```go
// Sign: 签名Bundle
func (b *Bundle) Sign(key *rsa.PrivateKey) error {
    // 计算Bundle hash
    hash, err := b.Hash()
    if err != nil {
        return err
    }
    
    // RSA签名
    signature, err := rsa.SignPKCS1v15(rand.Reader, key, crypto.SHA256, hash)
    if err != nil {
        return err
    }
    
    // 保存签名
    b.Signatures = []Signature{
        {
            Algorithm: "RS256",
            Value:     base64.StdEncoding.EncodeToString(signature),
        },
    }
    
    return nil
}
```

### 3.2 验证

```go
// Verify: 验证Bundle签名
func (b *Bundle) Verify(publicKey *rsa.PublicKey) error {
    if len(b.Signatures) == 0 {
        return fmt.Errorf("no signatures found")
    }
    
    // 计算hash
    hash, err := b.Hash()
    if err != nil {
        return err
    }
    
    // 解码签名
    sig, err := base64.StdEncoding.DecodeString(b.Signatures[0].Value)
    if err != nil {
        return err
    }
    
    // 验证
    return rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash, sig)
}
```

---

## 4. 插件系统

### 4.1 BundlePlugin

```go
// Plugin: Bundle插件
type Plugin struct {
    manager *plugins.Manager
    config  *Config
    
    // 当前bundle
    current *Bundle
    
    // 下载器
    downloader *Downloader
}

// Start: 启动插件
func (p *Plugin) Start(ctx context.Context) error {
    // 启动定期拉取
    go p.loop(ctx)
    
    return nil
}

// loop: 拉取循环
func (p *Plugin) loop(ctx context.Context) {
    ticker := time.NewTicker(p.config.PollingInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            if err := p.pull(ctx); err != nil {
                log.Errorf("bundle pull failed: %v", err)
            }
        }
    }
}

// pull: 拉取Bundle
func (p *Plugin) pull(ctx context.Context) error {
    // 下载Bundle
    bundle, err := p.downloader.Download(ctx)
    if err != nil {
        return err
    }
    
    // 验证签名
    if err := bundle.Verify(p.config.PublicKey); err != nil {
        return err
    }
    
    // 激活Bundle
    return p.activate(ctx, bundle)
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日

**相关阅读**:

- [Bundle格式规范](../01-技术规范/01.2-Bundle格式规范.md)
- [OPA架构总览](10.1-OPA架构总览与代码结构.md)
