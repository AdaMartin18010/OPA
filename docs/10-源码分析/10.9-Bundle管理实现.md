# Bundleç®¡ç†å®ç°

> **æ–‡æ¡£ç±»å‹**: æºç å®ç°åˆ†æ  
> **æ ¸å¿ƒæ¨¡å—**: `bundle/bundle.go`, `plugins/bundle/`  
> **é€‚ç”¨è¯»è€…**: OPAé›†æˆå¼€å‘è€…ã€DevOpså·¥ç¨‹å¸ˆ  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 2.9 - Bundleç®¡ç†  
> **OPAç‰ˆæœ¬**: v0.68.0

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

Bundleæ˜¯OPAç­–ç•¥å’Œæ•°æ®çš„æ‰“åŒ…åˆ†å‘æ ¼å¼ï¼Œæ”¯æŒç‰ˆæœ¬ç®¡ç†ã€ç­¾åéªŒè¯å’Œå¢é‡æ›´æ–°ã€‚

**æ ¸å¿ƒåŠŸèƒ½**:

- Bundleæ„å»ºä¸æ‰“åŒ…
- ç­¾åä¸éªŒè¯
- å¢é‡æ›´æ–°
- æ’ä»¶åŒ–åŠ è½½

---

## 1. Bundleç»“æ„

### 1.1 Bundleå®šä¹‰

```go
// Bundle: OPA Bundle
type Bundle struct {
    Manifest  Manifest              // æ¸…å•
    Data      map[string]interface{} // æ•°æ®
    Modules   []ModuleFile          // ç­–ç•¥æ¨¡å—
    Wasm      []byte                // WASMæ¨¡å—ï¼ˆå¯é€‰ï¼‰
}

// Manifest: Bundleæ¸…å•
type Manifest struct {
    Revision  string                 // ç‰ˆæœ¬å·
    Roots     []string               // æ ¹è·¯å¾„
    Metadata  map[string]interface{} // å…ƒæ•°æ®
}

// ModuleFile: æ¨¡å—æ–‡ä»¶
type ModuleFile struct {
    Path   string       // æ–‡ä»¶è·¯å¾„
    Raw    []byte       // åŸå§‹å†…å®¹
    Parsed *ast.Module  // è§£æåçš„AST
}
```

### 1.2 Bundleæ ¼å¼

```text
bundle.tar.gz
â”œâ”€â”€ .manifest      # JSONæ¸…å•
â”œâ”€â”€ data.json      # æ•°æ®æ–‡ä»¶
â”œâ”€â”€ policy/        # ç­–ç•¥ç›®å½•
â”‚   â”œâ”€â”€ authz.rego
â”‚   â””â”€â”€ rbac.rego
â””â”€â”€ .signatures.json  # ç­¾åï¼ˆå¯é€‰ï¼‰
```

---

## 2. Bundleæ„å»º

### 2.1 Buildå‡½æ•°

```go
// Build: æ„å»ºBundle
func Build(opts BuildOptions) (*Bundle, error) {
    b := &Bundle{
        Manifest: Manifest{
            Revision: opts.Revision,
            Roots:    opts.Roots,
        },
        Modules: []ModuleFile{},
        Data:    make(map[string]interface{}),
    }
    
    // åŠ è½½ç­–ç•¥æ–‡ä»¶
    if err := loadModules(b, opts.Paths); err != nil {
        return nil, err
    }
    
    // åŠ è½½æ•°æ®æ–‡ä»¶
    if err := loadData(b, opts.DataPaths); err != nil {
        return nil, err
    }
    
    return b, nil
}

// loadModules: åŠ è½½æ¨¡å—
func loadModules(b *Bundle, paths []string) error {
    for _, path := range paths {
        raw, err := ioutil.ReadFile(path)
        if err != nil {
            return err
        }
        
        parsed, err := ast.ParseModule(path, raw)
        if err != nil {
            return err
        }
        
        b.Modules = append(b.Modules, ModuleFile{
            Path:   path,
            Raw:    raw,
            Parsed: parsed,
        })
    }
    
    return nil
}
```

---

## 3. ç­¾åä¸éªŒè¯

### 3.1 ç­¾å

```go
// Sign: ç­¾åBundle
func (b *Bundle) Sign(key *rsa.PrivateKey) error {
    // è®¡ç®—Bundle hash
    hash, err := b.Hash()
    if err != nil {
        return err
    }
    
    // RSAç­¾å
    signature, err := rsa.SignPKCS1v15(rand.Reader, key, crypto.SHA256, hash)
    if err != nil {
        return err
    }
    
    // ä¿å­˜ç­¾å
    b.Signatures = []Signature{
        {
            Algorithm: "RS256",
            Value:     base64.StdEncoding.EncodeToString(signature),
        },
    }
    
    return nil
}
```

### 3.2 éªŒè¯

```go
// Verify: éªŒè¯Bundleç­¾å
func (b *Bundle) Verify(publicKey *rsa.PublicKey) error {
    if len(b.Signatures) == 0 {
        return fmt.Errorf("no signatures found")
    }
    
    // è®¡ç®—hash
    hash, err := b.Hash()
    if err != nil {
        return err
    }
    
    // è§£ç ç­¾å
    sig, err := base64.StdEncoding.DecodeString(b.Signatures[0].Value)
    if err != nil {
        return err
    }
    
    // éªŒè¯
    return rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash, sig)
}
```

---

## 4. æ’ä»¶ç³»ç»Ÿ

### 4.1 BundlePlugin

```go
// Plugin: Bundleæ’ä»¶
type Plugin struct {
    manager *plugins.Manager
    config  *Config
    
    // å½“å‰bundle
    current *Bundle
    
    // ä¸‹è½½å™¨
    downloader *Downloader
}

// Start: å¯åŠ¨æ’ä»¶
func (p *Plugin) Start(ctx context.Context) error {
    // å¯åŠ¨å®šæœŸæ‹‰å–
    go p.loop(ctx)
    
    return nil
}

// loop: æ‹‰å–å¾ªç¯
func (p *Plugin) loop(ctx context.Context) {
    ticker := time.NewTicker(p.config.PollingInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            if err := p.pull(ctx); err != nil {
                log.Errorf("bundle pull failed: %v", err)
            }
        }
    }
}

// pull: æ‹‰å–Bundle
func (p *Plugin) pull(ctx context.Context) error {
    // ä¸‹è½½Bundle
    bundle, err := p.downloader.Download(ctx)
    if err != nil {
        return err
    }
    
    // éªŒè¯ç­¾å
    if err := bundle.Verify(p.config.PublicKey); err != nil {
        return err
    }
    
    // æ¿€æ´»Bundle
    return p.activate(ctx, bundle)
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥

**ç›¸å…³é˜…è¯»**:

- [Bundleæ ¼å¼è§„èŒƒ](../01-æŠ€æœ¯è§„èŒƒ/01.2-Bundleæ ¼å¼è§„èŒƒ.md)
- [OPAæ¶æ„æ€»è§ˆ](10.1-OPAæ¶æ„æ€»è§ˆä¸ä»£ç ç»“æ„.md)
