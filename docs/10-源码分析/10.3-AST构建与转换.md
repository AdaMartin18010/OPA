# AST构建与转换

> **文档类型**: 源码实现分析  
> **核心模块**: `ast/ast.go`, `ast/transform.go`, `ast/visitor.go`  
> **适用读者**: 编译器开发者、OPA贡献者、高级用户  
> **先修知识**: [词法器与语法解析器](10.2-词法器与语法解析器实现.md)、[Rego语法](../02-语言模型/02.1-Rego语法规范.md)  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 2.3 - AST操作  
> **OPA版本**: v0.68.0

---

## 🎯 实现分析说明

> **本文档目标**:
>
> - ✅ 深入理解OPA AST的完整结构
> - ✅ 掌握AST构建和转换的实现技术
> - ✅ 学习Visitor模式在编译器中的应用
> - ✅ 理解各种AST重写和优化技术
>
> **技术亮点**:
>
> - **不可变AST**: 函数式设计理念
> - **Visitor模式**: 灵活的遍历机制
> - **转换管道**: 模块化的AST重写
> - **类型安全**: Go类型系统保证
>
> **实战价值**:
>
> - AST操作和分析
> - 自定义Rego转换
> - 代码优化实现
> - 静态分析工具

---

## 目录

- [AST构建与转换](#ast构建与转换)
  - [🎯 实现分析说明](#-实现分析说明)
  - [目录](#目录)
  - [1. AST架构总览](#1-ast架构总览)
    - [1.1 设计原则](#11-设计原则)
    - [1.2 核心类型层次](#12-核心类型层次)
    - [1.3 节点关系图](#13-节点关系图)
  - [2. AST节点定义](#2-ast节点定义)
    - [2.1 基础接口](#21-基础接口)
    - [2.2 Value类型](#22-value类型)
    - [2.3 Term节点](#23-term节点)
    - [2.4 Expr节点](#24-expr节点)
    - [2.5 Rule节点](#25-rule节点)
    - [2.6 Module节点](#26-module节点)
  - [3. AST构建](#3-ast构建)
    - [3.1 构建器模式](#31-构建器模式)
    - [3.2 辅助构造函数](#32-辅助构造函数)
    - [3.3 从零构建AST](#33-从零构建ast)
    - [3.4 AST验证](#34-ast验证)
  - [4. AST遍历](#4-ast遍历)
    - [4.1 Visitor接口](#41-visitor接口)
    - [4.2 Walk函数](#42-walk函数)
    - [4.3 遍历策略](#43-遍历策略)
    - [4.4 实用遍历器](#44-实用遍历器)
  - [5. AST转换](#5-ast转换)
    - [5.1 Transform接口](#51-transform接口)
    - [5.2 通用转换函数](#52-通用转换函数)
    - [5.3 转换器组合](#53-转换器组合)
    - [5.4 常用转换](#54-常用转换)
  - [6. 重要AST操作](#6-重要ast操作)
    - [6.1 变量提取](#61-变量提取)
    - [6.2 引用重写](#62-引用重写)
    - [6.3 表达式简化](#63-表达式简化)
    - [6.4 安全性检查](#64-安全性检查)
  - [7. 编译器使用的转换](#7-编译器使用的转换)
    - [7.1 局部变量重写](#71-局部变量重写)
    - [7.2 推导式展开](#72-推导式展开)
    - [7.3 动态项重写](#73-动态项重写)
    - [7.4 With语句转换](#74-with语句转换)
  - [8. AST比较与统一](#8-ast比较与统一)
    - [8.1 结构比较](#81-结构比较)
    - [8.2 统一算法](#82-统一算法)
    - [8.3 替换（Substitution）](#83-替换substitution)
  - [9. 性能优化](#9-性能优化)
    - [9.1 内存池](#91-内存池)
    - [9.2 缓存机制](#92-缓存机制)
    - [9.3 延迟计算](#93-延迟计算)
  - [10. 实战示例](#10-实战示例)
    - [10.1 自定义转换器](#101-自定义转换器)
    - [10.2 AST分析工具](#102-ast分析工具)
    - [10.3 代码生成](#103-代码生成)
  - [附录](#附录)
    - [A. 完整AST类型参考](#a-完整ast类型参考)
    - [B. 转换器清单](#b-转换器清单)
    - [C. 调试工具](#c-调试工具)

---

## 1. AST架构总览

### 1.1 设计原则

OPA的AST设计遵循以下原则：

**1. 不可变性（Immutability）**:

```go
// AST节点一旦创建就不可修改
// 所有"修改"操作返回新节点

rule := &Rule{Head: head, Body: body}
// 不能: rule.Body = newBody  ❌
// 正确: newRule := rule.Copy()  ✅
```

**2. 类型安全**:

```go
// 使用Go接口实现多态
type Value interface {
    String() string
    Compare(Value) int
}

// 每种值类型都实现Value接口
type String string
type Number json.Number
type Boolean bool
```

**3. 位置追踪**:

```go
// 每个节点保存源码位置
type Rule struct {
    Location *Location  // 文件名、行号、列号
    Head     *Head
    Body     Body
}
```

**4. 自描述**:

```go
// 节点包含足够的元信息
type Builtin struct {
    Name string
    Decl *types.Function  // 类型签名
    // ...
}
```

### 1.2 核心类型层次

```text
Node (interface)
├── Value (interface)
│   ├── Null
│   ├── Boolean
│   ├── Number
│   ├── String
│   ├── Var          # 变量
│   ├── Ref          # 引用
│   ├── Array        # 数组
│   ├── Object       # 对象
│   ├── Set          # 集合
│   ├── Call         # 函数调用
│   ├── ArrayComprehension
│   ├── ObjectComprehension
│   └── SetComprehension
│
├── Term             # 带位置的Value
├── Expr             # 表达式
├── With             # With语句
├── Body             # 表达式列表
├── Head             # 规则头部
├── Rule             # 规则
├── Import           # Import语句
├── Package          # Package声明
└── Module           # 模块
```

### 1.3 节点关系图

```text
Module
├── Package
│   └── Path: Ref
│
├── Imports []
│   └── Import
│       ├── Path: Ref
│       └── Alias: Var
│
└── Rules []
    └── Rule
        ├── Head
        │   ├── Name: Var
        │   ├── Args: []Term
        │   ├── Key: Term
        │   └── Value: Term
        │
        ├── Body: []Expr
        │   └── Expr
        │       ├── Terms: []Term
        │       ├── With: []With
        │       └── Negated: bool
        │
        └── Else: *Rule
```

---

## 2. AST节点定义

### 2.1 基础接口

**Node接口**:

```go
// Node: AST节点基础接口
type Node interface {
    // Loc: 返回源码位置
    Loc() *Location
    
    // String: 返回节点的字符串表示
    String() string
}

// Location: 源码位置
type Location struct {
    File   string  // 文件名
    Row    int     // 行号（从1开始）
    Col    int     // 列号（从1开始）
    Text   []byte  // 原始文本
}
```

**Value接口**:

```go
// Value: Rego值接口
type Value interface {
    // Compare: 与另一个Value比较
    // 返回: -1 (小于), 0 (等于), 1 (大于)
    Compare(Value) int
    
    // String: 字符串表示
    String() string
    
    // IsGround: 是否是ground（不含变量）
    IsGround() bool
    
    // Hash: 计算哈希值
    Hash() int
}
```

### 2.2 Value类型

**标量类型**:

```go
// Null: 空值
type Null struct{}

func (Null) Compare(other Value) int {
    if _, ok := other.(Null); ok {
        return 0
    }
    return -1
}

// Boolean: 布尔值
type Boolean bool

func (a Boolean) Compare(other Value) int {
    if b, ok := other.(Boolean); ok {
        if a == b {
            return 0
        }
        if a {
            return 1
        }
        return -1
    }
    return -1
}

// Number: 数字（使用json.Number表示）
type Number json.Number

func (a Number) Compare(other Value) int {
    b, ok := other.(Number)
    if !ok {
        return 1
    }
    
    // 转为float64比较
    af, _ := a.Float64()
    bf, _ := b.Float64()
    
    if af < bf {
        return -1
    } else if af > bf {
        return 1
    }
    return 0
}

// String: 字符串
type String string

func (a String) Compare(other Value) int {
    b, ok := other.(String)
    if !ok {
        return 1
    }
    
    if a < b {
        return -1
    } else if a > b {
        return 1
    }
    return 0
}
```

**变量类型**:

```go
// Var: 变量
type Var string

func (v Var) IsGround() bool {
    return false  // 变量不是ground
}

func (a Var) Compare(other Value) int {
    b, ok := other.(Var)
    if !ok {
        return 1
    }
    
    if a < b {
        return -1
    } else if a > b {
        return 1
    }
    return 0
}

// IsWildcard: 是否是通配符 (_)
func (v Var) IsWildcard() bool {
    return strings.HasPrefix(string(v), "$")
}

// IsGenerated: 是否是生成的变量
func (v Var) IsGenerated() bool {
    return strings.HasPrefix(string(v), "__")
}
```

**引用类型**:

```go
// Ref: 引用（路径）
type Ref []*Term

// 示例: data.users[0].name
// Ref{
//     VarTerm("data"),
//     StringTerm("users"),
//     IntNumberTerm(0),
//     StringTerm("name"),
// }

func (ref Ref) IsGround() bool {
    for _, term := range ref {
        if !term.IsGround() {
            return false
        }
    }
    return true
}

func (ref Ref) String() string {
    if len(ref) == 0 {
        return ""
    }
    
    var buf strings.Builder
    buf.WriteString(ref[0].String())
    
    for i := 1; i < len(ref); i++ {
        term := ref[i]
        
        // 如果是字符串，使用点号
        if str, ok := term.Value.(String); ok {
            buf.WriteByte('.')
            buf.WriteString(string(str))
        } else {
            // 否则使用方括号
            buf.WriteByte('[')
            buf.WriteString(term.String())
            buf.WriteByte(']')
        }
    }
    
    return buf.String()
}

// Append: 追加路径元素
func (ref Ref) Append(term *Term) Ref {
    result := make(Ref, len(ref)+1)
    copy(result, ref)
    result[len(ref)] = term
    return result
}

// GroundPrefix: 返回ground前缀
func (ref Ref) GroundPrefix() Ref {
    for i, term := range ref {
        if !term.IsGround() {
            return ref[:i]
        }
    }
    return ref
}
```

**复合类型**:

```go
// Array: 数组
type Array []*Term

func (arr Array) IsGround() bool {
    for _, term := range arr {
        if !term.IsGround() {
            return false
        }
    }
    return true
}

// Object: 对象
type Object [][2]*Term  // 键值对数组

// 示例: {a: 1, b: 2}
// Object{
//     {StringTerm("a"), IntNumberTerm(1)},
//     {StringTerm("b"), IntNumberTerm(2)},
// }

func (obj Object) IsGround() bool {
    for _, pair := range obj {
        if !pair[0].IsGround() || !pair[1].IsGround() {
            return false
        }
    }
    return true
}

// Get: 获取键对应的值
func (obj Object) Get(key *Term) *Term {
    for _, pair := range obj {
        if pair[0].Equal(key) {
            return pair[1]
        }
    }
    return nil
}

// Set: 集合
type Set []*Term

func (set Set) IsGround() bool {
    for _, term := range set {
        if !term.IsGround() {
            return false
        }
    }
    return true
}

// Contains: 是否包含元素
func (set Set) Contains(term *Term) bool {
    for _, elem := range set {
        if elem.Equal(term) {
            return true
        }
    }
    return false
}
```

**推导式类型**:

```go
// ArrayComprehension: 数组推导式
// [x | x = arr[_]; x > 5]
type ArrayComprehension struct {
    Term *Term  // 结果项
    Body Body   // 推导体
}

// ObjectComprehension: 对象推导式
// {k: v | k = keys[_]; v = values[k]}
type ObjectComprehension struct {
    Key   *Term  // 键项
    Value *Term  // 值项
    Body  Body   // 推导体
}

// SetComprehension: 集合推导式
// {x | x = arr[_]; x > 5}
type SetComprehension struct {
    Term *Term  // 项
    Body Body   // 推导体
}
```

### 2.3 Term节点

```go
// Term: 带位置信息的Value
type Term struct {
    Value    Value      // 实际值
    Location *Location  // 源码位置
}

// NewTerm: 创建Term
func NewTerm(value Value) *Term {
    return &Term{Value: value}
}

// IsGround: 是否是ground
func (term *Term) IsGround() bool {
    return term.Value.IsGround()
}

// Equal: 是否相等
func (term *Term) Equal(other *Term) bool {
    return term.Value.Compare(other.Value) == 0
}

// String: 字符串表示
func (term *Term) String() string {
    return term.Value.String()
}

// Copy: 深拷贝
func (term *Term) Copy() *Term {
    return &Term{
        Value:    copyValue(term.Value),
        Location: term.Location,
    }
}
```

**辅助构造函数**:

```go
// 标量构造函数
func NullTerm() *Term {
    return &Term{Value: Null{}}
}

func BooleanTerm(b bool) *Term {
    return &Term{Value: Boolean(b)}
}

func IntNumberTerm(i int64) *Term {
    return &Term{Value: Number(strconv.FormatInt(i, 10))}
}

func FloatNumberTerm(f float64) *Term {
    return &Term{Value: Number(strconv.FormatFloat(f, 'f', -1, 64))}
}

func StringTerm(s string) *Term {
    return &Term{Value: String(s)}
}

// 变量和引用
func VarTerm(name string) *Term {
    return &Term{Value: Var(name)}
}

func RefTerm(terms ...*Term) *Term {
    return &Term{Value: Ref(terms)}
}

// 复合类型
func ArrayTerm(terms ...*Term) *Term {
    return &Term{Value: Array(terms)}
}

func ObjectTerm(pairs ...[2]*Term) *Term {
    return &Term{Value: Object(pairs)}
}

func SetTerm(terms ...*Term) *Term {
    return &Term{Value: Set(terms)}
}
```

### 2.4 Expr节点

```go
// Expr: 表达式
type Expr struct {
    Location *Location  // 源码位置
    Index    int        // 在Body中的索引
    Terms    interface{} // *Term, []*Term, 或 Call
    With     []*With    // with语句
    Negated  bool       // 是否被否定
}

// NewExpr: 创建表达式
func NewExpr(terms interface{}) *Expr {
    return &Expr{Terms: terms}
}

// IsCall: 是否是函数调用
func (expr *Expr) IsCall() bool {
    _, ok := expr.Terms.(Call)
    return ok
}

// IsEquality: 是否是等式（x = y）
func (expr *Expr) IsEquality() bool {
    terms, ok := expr.Terms.([]*Term)
    if !ok || len(terms) != 2 {
        return false
    }
    
    // 检查是否是内置的等于操作
    if ref, ok := terms[0].Value.(Ref); ok {
        return ref.IsBuiltin("eq") || ref.IsBuiltin("equal")
    }
    
    return false
}

// Operands: 返回操作数
func (expr *Expr) Operands() []*Term {
    switch terms := expr.Terms.(type) {
    case *Term:
        return []*Term{terms}
    case []*Term:
        return terms
    case Call:
        result := make([]*Term, 0, len(terms)+1)
        result = append(result, NewTerm(Ref{VarTerm(terms[0].Name)}))
        result = append(result, terms...)
        return result
    }
    return nil
}

// String: 字符串表示
func (expr *Expr) String() string {
    var buf strings.Builder
    
    if expr.Negated {
        buf.WriteString("not ")
    }
    
    // Terms
    switch terms := expr.Terms.(type) {
    case *Term:
        buf.WriteString(terms.String())
    case []*Term:
        for i, term := range terms {
            if i > 0 {
                buf.WriteString(", ")
            }
            buf.WriteString(term.String())
        }
    case Call:
        buf.WriteString(terms[0].String())
        buf.WriteString("(")
        for i := 1; i < len(terms); i++ {
            if i > 1 {
                buf.WriteString(", ")
            }
            buf.WriteString(terms[i].String())
        }
        buf.WriteString(")")
    }
    
    // With语句
    for _, with := range expr.With {
        buf.WriteString(" with ")
        buf.WriteString(with.String())
    }
    
    return buf.String()
}
```

**Call类型**:

```go
// Call: 函数调用
type Call []*Term  // [函数名, 参数1, 参数2, ...]

// 示例: count(arr, n)
// Call{
//     RefTerm(VarTerm("count")),
//     VarTerm("arr"),
//     VarTerm("n"),
// }
```

**With类型**:

```go
// With: with语句
type With struct {
    Location *Location  // 源码位置
    Target   *Term      // 目标引用
    Value    *Term      // 替换值
}

// 示例: data.config with input.user as "admin"
// With{
//     Target: RefTerm(VarTerm("input"), StringTerm("user")),
//     Value:  StringTerm("admin"),
// }

func (with *With) String() string {
    return fmt.Sprintf("%s as %s", with.Target, with.Value)
}
```

### 2.5 Rule节点

```go
// Rule: 规则
type Rule struct {
    Location *Location  // 源码位置
    Default  bool       // 是否是default规则
    Head     *Head      // 规则头部
    Body     Body       // 规则体
    Else     *Rule      // else分支
    Module   *Module    // 所属模块
}

// Head: 规则头部
type Head struct {
    Location  *Location  // 源码位置
    Name      Var        // 规则名称
    Args      Args       // 函数参数（可选）
    Key       *Term      // 部分规则的key（可选）
    Value     *Term      // 规则值（可选）
    Assign    bool       // 是否是赋值（:= vs =）
    Reference Ref        // 完整引用路径
}

// Args: 函数参数
type Args []*Term

// Body: 规则体（表达式列表）
type Body []*Expr

// NewBody: 创建Body
func NewBody(exprs ...*Expr) Body {
    return Body(exprs)
}

// Append: 追加表达式
func (body Body) Append(expr *Expr) Body {
    result := make(Body, len(body)+1)
    copy(result, body)
    result[len(body)] = expr
    return result
}

// IsGround: 是否所有表达式都是ground
func (body Body) IsGround() bool {
    for _, expr := range body {
        for _, term := range expr.Operands() {
            if !term.IsGround() {
                return false
            }
        }
    }
    return true
}

// Vars: 提取所有变量
func (body Body) Vars() VarSet {
    vars := NewVarSet()
    for _, expr := range body {
        for _, term := range expr.Operands() {
            collectVars(term, vars)
        }
    }
    return vars
}
```

**规则类型判断**:

```go
// IsComplete: 是否是完全规则
// 完全规则: p = true if { ... }
func (rule *Rule) IsComplete() bool {
    return rule.Head.Key == nil && rule.Head.Value != nil
}

// IsPartial: 是否是部分规则
// 部分规则: p[k] = v if { ... }
func (rule *Rule) IsPartial() bool {
    return rule.Head.Key != nil
}

// IsFunction: 是否是函数
// 函数: f(x, y) = z if { ... }
func (rule *Rule) IsFunction() bool {
    return len(rule.Head.Args) > 0
}

// IsDefault: 是否是default规则
// default p = false
func (rule *Rule) IsDefault() bool {
    return rule.Default
}
```

### 2.6 Module节点

```go
// Module: Rego模块
type Module struct {
    Location *Location  // 源码位置
    Package  *Package   // package声明
    Imports  []*Import  // import语句
    Rules    []*Rule    // 规则列表
    Comments []*Comment // 注释
}

// Package: package声明
type Package struct {
    Location *Location  // 源码位置
    Path     Ref        // 包路径
}

// Import: import语句
type Import struct {
    Location *Location  // 源码位置
    Path     *Term      // 导入路径
    Alias    Var        // 别名（可选）
}

// Comment: 注释
type Comment struct {
    Location *Location  // 源码位置
    Text     []byte     // 注释内容
}
```

---

## 3. AST构建

### 3.1 构建器模式

**ModuleBuilder**:

```go
// ModuleBuilder: 模块构建器
type ModuleBuilder struct {
    module *Module
}

// NewModuleBuilder: 创建构建器
func NewModuleBuilder() *ModuleBuilder {
    return &ModuleBuilder{
        module: &Module{},
    }
}

// Package: 设置package
func (b *ModuleBuilder) Package(path string) *ModuleBuilder {
    b.module.Package = &Package{
        Path: ParseRef(path),
    }
    return b
}

// Import: 添加import
func (b *ModuleBuilder) Import(path string, alias string) *ModuleBuilder {
    imp := &Import{
        Path: StringTerm(path),
    }
    if alias != "" {
        imp.Alias = Var(alias)
    }
    b.module.Imports = append(b.module.Imports, imp)
    return b
}

// Rule: 添加规则
func (b *ModuleBuilder) Rule(rule *Rule) *ModuleBuilder {
    b.module.Rules = append(b.module.Rules, rule)
    return b
}

// Build: 构建模块
func (b *ModuleBuilder) Build() *Module {
    return b.module
}

// 使用示例:
module := NewModuleBuilder().
    Package("example.authz").
    Import("data.users", "").
    Rule(allowRule).
    Build()
```

**RuleBuilder**:

```go
// RuleBuilder: 规则构建器
type RuleBuilder struct {
    rule *Rule
}

// NewRuleBuilder: 创建构建器
func NewRuleBuilder(name string) *RuleBuilder {
    return &RuleBuilder{
        rule: &Rule{
            Head: &Head{
                Name: Var(name),
            },
            Body: NewBody(),
        },
    }
}

// Default: 设置为default规则
func (b *RuleBuilder) Default() *RuleBuilder {
    b.rule.Default = true
    return b
}

// Value: 设置规则值
func (b *RuleBuilder) Value(term *Term) *RuleBuilder {
    b.rule.Head.Value = term
    return b
}

// Key: 设置部分规则的key
func (b *RuleBuilder) Key(term *Term) *RuleBuilder {
    b.rule.Head.Key = term
    return b
}

// Args: 设置函数参数
func (b *RuleBuilder) Args(args ...*Term) *RuleBuilder {
    b.rule.Head.Args = Args(args)
    return b
}

// Body: 添加body表达式
func (b *RuleBuilder) Body(exprs ...*Expr) *RuleBuilder {
    b.rule.Body = append(b.rule.Body, exprs...)
    return b
}

// Else: 添加else分支
func (b *RuleBuilder) Else(rule *Rule) *RuleBuilder {
    b.rule.Else = rule
    return b
}

// Build: 构建规则
func (b *RuleBuilder) Build() *Rule {
    return b.rule
}

// 使用示例:
rule := NewRuleBuilder("allow").
    Value(BooleanTerm(true)).
    Body(
        Equality.Expr(
            RefTerm(VarTerm("input"), StringTerm("method")),
            StringTerm("GET"),
        ),
    ).
    Build()
```

### 3.2 辅助构造函数

**表达式构造**:

```go
// Equality: 等式表达式
var Equality = &Builtin{
    Name: "eq",
}

func (b *Builtin) Expr(a, b *Term) *Expr {
    return &Expr{
        Terms: []*Term{
            RefTerm(VarTerm(b.Name)),
            a,
            b,
        },
    }
}

// 示例:
expr := Equality.Expr(
    VarTerm("x"),
    IntNumberTerm(10),
)
// 等价于: x == 10

// 比较运算符
var (
    Equal          = &Builtin{Name: "eq"}
    NotEqual       = &Builtin{Name: "neq"}
    LessThan       = &Builtin{Name: "lt"}
    LessThanEq     = &Builtin{Name: "lte"}
    GreaterThan    = &Builtin{Name: "gt"}
    GreaterThanEq  = &Builtin{Name: "gte"}
)

// 算术运算符
var (
    Plus     = &Builtin{Name: "plus"}
    Minus    = &Builtin{Name: "minus"}
    Multiply = &Builtin{Name: "mul"}
    Divide   = &Builtin{Name: "div"}
)
```

**引用构造**:

```go
// ParseRef: 解析引用字符串
func ParseRef(s string) Ref {
    // "data.users[0].name" → Ref{...}
    parts := strings.Split(s, ".")
    ref := make(Ref, 0, len(parts))
    
    for _, part := range parts {
        if strings.Contains(part, "[") {
            // 处理数组索引
            // "users[0]" → "users", "[0]"
            // ...
        } else {
            if len(ref) == 0 {
                ref = append(ref, VarTerm(part))
            } else {
                ref = append(ref, StringTerm(part))
            }
        }
    }
    
    return ref
}

// MustParseRef: 解析引用（panic on error）
func MustParseRef(s string) Ref {
    ref, err := ParseRefSafe(s)
    if err != nil {
        panic(err)
    }
    return ref
}
```

### 3.3 从零构建AST

**完整示例**:

```go
// 构建以下Rego策略的AST:
// package example.authz
//
// import data.users
//
// default allow = false
//
// allow if {
//     input.method == "GET"
//     user := users[input.user_id]
//     user.role == "admin"
// }

func buildExampleAST() *Module {
    // 1. 创建模块
    module := &Module{
        Package: &Package{
            Path: MustParseRef("data.example.authz"),
        },
    }
    
    // 2. 添加import
    module.Imports = []*Import{
        {
            Path: StringTerm("data.users"),
        },
    }
    
    // 3. 创建default规则
    defaultRule := &Rule{
        Default: true,
        Head: &Head{
            Name:  Var("allow"),
            Value: BooleanTerm(false),
        },
        Body: NewBody(),
    }
    module.Rules = append(module.Rules, defaultRule)
    
    // 4. 创建allow规则
    allowRule := &Rule{
        Head: &Head{
            Name:  Var("allow"),
            Value: BooleanTerm(true),
        },
        Body: NewBody(
            // input.method == "GET"
            Equality.Expr(
                RefTerm(VarTerm("input"), StringTerm("method")),
                StringTerm("GET"),
            ),
            
            // user := users[input.user_id]
            Equality.Expr(
                VarTerm("user"),
                RefTerm(
                    VarTerm("users"),
                    RefTerm(VarTerm("input"), StringTerm("user_id")),
                ),
            ),
            
            // user.role == "admin"
            Equality.Expr(
                RefTerm(VarTerm("user"), StringTerm("role")),
                StringTerm("admin"),
            ),
        ),
    }
    module.Rules = append(module.Rules, allowRule)
    
    return module
}
```

### 3.4 AST验证

**验证器**:

```go
// Validator: AST验证器
type Validator struct {
    errors Errors
}

// Validate: 验证模块
func (v *Validator) Validate(module *Module) error {
    // 1. 验证package
    if module.Package == nil {
        v.error("missing package declaration")
    }
    
    // 2. 验证imports
    for _, imp := range module.Imports {
        v.validateImport(imp)
    }
    
    // 3. 验证规则
    for _, rule := range module.Rules {
        v.validateRule(rule)
    }
    
    if len(v.errors) > 0 {
        return v.errors
    }
    return nil
}

// validateRule: 验证规则
func (v *Validator) validateRule(rule *Rule) {
    // 检查规则头部
    if rule.Head == nil {
        v.error("missing rule head")
        return
    }
    
    // 检查规则名称
    if rule.Head.Name == "" {
        v.error("missing rule name")
    }
    
    // 检查规则体
    for _, expr := range rule.Body {
        v.validateExpr(expr)
    }
    
    // 检查else分支
    if rule.Else != nil {
        v.validateRule(rule.Else)
    }
}

// validateExpr: 验证表达式
func (v *Validator) validateExpr(expr *Expr) {
    // 检查terms
    for _, term := range expr.Operands() {
        v.validateTerm(term)
    }
    
    // 检查with语句
    for _, with := range expr.With {
        v.validateWith(with)
    }
}
```

---

## 4. AST遍历

### 4.1 Visitor接口

```go
// Visitor: AST访问者接口
type Visitor interface {
    // Visit: 访问节点
    // 返回值: 继续遍历的Visitor（可以是自己或nil）
    Visit(node interface{}) (w Visitor)
}

// GenericVisitor: 通用访问者
type GenericVisitor struct {
    before func(interface{}) bool
    after  func(interface{})
}

// NewGenericVisitor: 创建通用访问者
func NewGenericVisitor(before func(interface{}) bool) *GenericVisitor {
    return &GenericVisitor{before: before}
}

// Visit: 实现Visitor接口
func (v *GenericVisitor) Visit(node interface{}) Visitor {
    if v.before != nil {
        if !v.before(node) {
            return nil  // 停止遍历
        }
    }
    return v
}

// After: 设置后续处理函数
func (v *GenericVisitor) After(f func(interface{})) *GenericVisitor {
    v.after = f
    return v
}
```

### 4.2 Walk函数

```go
// Walk: 遍历AST
func Walk(v Visitor, node interface{}) {
    if v = v.Visit(node); v == nil {
        return
    }
    
    switch n := node.(type) {
    case *Module:
        Walk(v, n.Package)
        for _, imp := range n.Imports {
            Walk(v, imp)
        }
        for _, rule := range n.Rules {
            Walk(v, rule)
        }
        
    case *Rule:
        Walk(v, n.Head)
        Walk(v, n.Body)
        if n.Else != nil {
            Walk(v, n.Else)
        }
        
    case *Head:
        for _, arg := range n.Args {
            Walk(v, arg)
        }
        if n.Key != nil {
            Walk(v, n.Key)
        }
        if n.Value != nil {
            Walk(v, n.Value)
        }
        
    case Body:
        for _, expr := range n {
            Walk(v, expr)
        }
        
    case *Expr:
        for _, term := range n.Operands() {
            Walk(v, term)
        }
        for _, with := range n.With {
            Walk(v, with)
        }
        
    case *Term:
        walkValue(v, n.Value)
        
    case *With:
        Walk(v, n.Target)
        Walk(v, n.Value)
    }
}

// walkValue: 遍历Value
func walkValue(v Visitor, value Value) {
    switch val := value.(type) {
    case Ref:
        for _, term := range val {
            Walk(v, term)
        }
        
    case Array:
        for _, term := range val {
            Walk(v, term)
        }
        
    case Object:
        for _, pair := range val {
            Walk(v, pair[0])
            Walk(v, pair[1])
        }
        
    case Set:
        for _, term := range val {
            Walk(v, term)
        }
        
    case *ArrayComprehension:
        Walk(v, val.Term)
        Walk(v, val.Body)
        
    case *ObjectComprehension:
        Walk(v, val.Key)
        Walk(v, val.Value)
        Walk(v, val.Body)
        
    case *SetComprehension:
        Walk(v, val.Term)
        Walk(v, val.Body)
    }
}
```

### 4.3 遍历策略

**前序遍历**:

```go
// WalkBeforeAfter: 前后遍历
func WalkBeforeAfter(node interface{},
    before func(interface{}) bool,
    after func(interface{})) {
    
    vis := &beforeAfterVisitor{
        before: before,
        after:  after,
    }
    Walk(vis, node)
}

type beforeAfterVisitor struct {
    before func(interface{}) bool
    after  func(interface{})
}

func (v *beforeAfterVisitor) Visit(node interface{}) Visitor {
    if v.before != nil && !v.before(node) {
        return nil
    }
    return v
}
```

**深度优先遍历**:

```go
// WalkDepthFirst: 深度优先遍历
func WalkDepthFirst(node interface{}, f func(interface{})) {
    Walk(NewGenericVisitor(func(n interface{}) bool {
        f(n)
        return true
    }), node)
}
```

### 4.4 实用遍历器

**变量收集器**:

```go
// VarCollector: 变量收集器
type VarCollector struct {
    vars VarSet
}

func NewVarCollector() *VarCollector {
    return &VarCollector{
        vars: NewVarSet(),
    }
}

func (c *VarCollector) Visit(node interface{}) Visitor {
    if term, ok := node.(*Term); ok {
        if v, ok := term.Value.(Var); ok {
            c.vars.Add(v)
        }
    }
    return c
}

func (c *VarCollector) Vars() VarSet {
    return c.vars
}

// 使用:
collector := NewVarCollector()
Walk(collector, rule)
vars := collector.Vars()
```

**引用收集器**:

```go
// RefCollector: 引用收集器
type RefCollector struct {
    refs []Ref
}

func NewRefCollector() *RefCollector {
    return &RefCollector{
        refs: []Ref{},
    }
}

func (c *RefCollector) Visit(node interface{}) Visitor {
    if term, ok := node.(*Term); ok {
        if ref, ok := term.Value.(Ref); ok {
            c.refs = append(c.refs, ref)
        }
    }
    return c
}

func (c *RefCollector) Refs() []Ref {
    return c.refs
}
```

---

## 5. AST转换

### 5.1 Transform接口

```go
// Transformer: AST转换器接口
type Transformer interface {
    // Transform: 转换节点
    // 返回: 转换后的节点，或nil（不变）
    Transform(node interface{}) (interface{}, error)
}

// TransformFunc: 转换函数类型
type TransformFunc func(interface{}) (interface{}, error)

func (f TransformFunc) Transform(node interface{}) (interface{}, error) {
    return f(node)
}
```

### 5.2 通用转换函数

```go
// Transform: 转换AST
func Transform(transformer Transformer, node interface{}) (interface{}, error) {
    // 先转换子节点
    node, err := transformChildren(transformer, node)
    if err != nil {
        return nil, err
    }
    
    // 再转换当前节点
    return transformer.Transform(node)
}

// transformChildren: 转换子节点
func transformChildren(t Transformer, node interface{}) (interface{}, error) {
    switch n := node.(type) {
    case *Module:
        module := *n  // 拷贝
        
        // 转换package
        pkg, err := Transform(t, n.Package)
        if err != nil {
            return nil, err
        }
        module.Package = pkg.(*Package)
        
        // 转换imports
        for i, imp := range n.Imports {
            newImp, err := Transform(t, imp)
            if err != nil {
                return nil, err
            }
            module.Imports[i] = newImp.(*Import)
        }
        
        // 转换rules
        for i, rule := range n.Rules {
            newRule, err := Transform(t, rule)
            if err != nil {
                return nil, err
            }
            module.Rules[i] = newRule.(*Rule)
        }
        
        return &module, nil
        
    case *Rule:
        rule := *n  // 拷贝
        
        // 转换head
        head, err := Transform(t, n.Head)
        if err != nil {
            return nil, err
        }
        rule.Head = head.(*Head)
        
        // 转换body
        body, err := Transform(t, n.Body)
        if err != nil {
            return nil, err
        }
        rule.Body = body.(Body)
        
        // 转换else
        if n.Else != nil {
            elseRule, err := Transform(t, n.Else)
            if err != nil {
                return nil, err
            }
            rule.Else = elseRule.(*Rule)
        }
        
        return &rule, nil
        
    case Body:
        body := make(Body, len(n))
        for i, expr := range n {
            newExpr, err := Transform(t, expr)
            if err != nil {
                return nil, err
            }
            body[i] = newExpr.(*Expr)
        }
        return body, nil
        
    case *Expr:
        expr := *n  // 拷贝
        
        // 转换terms
        newTerms, err := transformTerms(t, n.Terms)
        if err != nil {
            return nil, err
        }
        expr.Terms = newTerms
        
        // 转换with
        for i, with := range n.With {
            newWith, err := Transform(t, with)
            if err != nil {
                return nil, err
            }
            expr.With[i] = newWith.(*With)
        }
        
        return &expr, nil
        
    case *Term:
        // 转换value
        value, err := transformValue(t, n.Value)
        if err != nil {
            return nil, err
        }
        
        if value != n.Value {
            term := *n
            term.Value = value
            return &term, nil
        }
        
        return n, nil
    }
    
    return node, nil
}

// transformValue: 转换Value
func transformValue(t Transformer, value Value) (Value, error) {
    switch val := value.(type) {
    case Ref:
        ref := make(Ref, len(val))
        changed := false
        
        for i, term := range val {
            newTerm, err := Transform(t, term)
            if err != nil {
                return nil, err
            }
            ref[i] = newTerm.(*Term)
            if ref[i] != term {
                changed = true
            }
        }
        
        if changed {
            return ref, nil
        }
        
    case Array:
        arr := make(Array, len(val))
        changed := false
        
        for i, term := range val {
            newTerm, err := Transform(t, term)
            if err != nil {
                return nil, err
            }
            arr[i] = newTerm.(*Term)
            if arr[i] != term {
                changed = true
            }
        }
        
        if changed {
            return arr, nil
        }
        
    // ... 其他类型 ...
    }
    
    return value, nil
}
```

### 5.3 转换器组合

```go
// ComposeTransformers: 组合多个转换器
func ComposeTransformers(transformers ...Transformer) Transformer {
    return TransformFunc(func(node interface{}) (interface{}, error) {
        var err error
        for _, t := range transformers {
            node, err = t.Transform(node)
            if err != nil {
                return nil, err
            }
        }
        return node, nil
    })
}

// 使用:
transformer := ComposeTransformers(
    rewriteLocalVars,
    expandComprehensions,
    rewriteDynamicTerms,
)

newModule, err := Transform(transformer, module)
```

### 5.4 常用转换

**变量重命名**:

```go
// RenameVars: 变量重命名转换器
type RenameVars struct {
    mapping map[Var]Var
}

func NewRenameVars(mapping map[Var]Var) *RenameVars {
    return &RenameVars{mapping: mapping}
}

func (r *RenameVars) Transform(node interface{}) (interface{}, error) {
    if term, ok := node.(*Term); ok {
        if v, ok := term.Value.(Var); ok {
            if newVar, found := r.mapping[v]; found {
                newTerm := *term
                newTerm.Value = newVar
                return &newTerm, nil
            }
        }
    }
    return node, nil
}

// 使用:
renamer := NewRenameVars(map[Var]Var{
    Var("x"): Var("$x_0"),
    Var("y"): Var("$y_0"),
})

newRule, _ := Transform(renamer, rule)
```

**常量折叠**:

```go
// ConstantFolding: 常量折叠转换器
type ConstantFolding struct{}

func (c *ConstantFolding) Transform(node interface{}) (interface{}, error) {
    expr, ok := node.(*Expr)
    if !ok {
        return node, nil
    }
    
    // 检查是否是算术表达式
    if !expr.IsCall() {
        return node, nil
    }
    
    terms := expr.Operands()
    if len(terms) != 3 {
        return node, nil
    }
    
    // 提取运算符和操作数
    op := terms[0]
    left := terms[1]
    right := terms[2]
    
    // 检查操作数是否都是常量
    if !left.IsGround() || !right.IsGround() {
        return node, nil
    }
    
    // 执行常量计算
    switch op.String() {
    case "plus":
        l, _ := left.Value.(Number).Int64()
        r, _ := right.Value.(Number).Int64()
        return IntNumberTerm(l + r), nil
        
    case "minus":
        l, _ := left.Value.(Number).Int64()
        r, _ := right.Value.(Number).Int64()
        return IntNumberTerm(l - r), nil
        
    // ... 其他运算符 ...
    }
    
    return node, nil
}

// 使用:
// 输入: 3 + 5
// 输出: 8
folder := &ConstantFolding{}
newExpr, _ := Transform(folder, expr)
```

---

## 6. 重要AST操作

### 6.1 变量提取

```go
// Vars: 提取所有变量
func Vars(node interface{}) VarSet {
    vis := NewVarCollector()
    Walk(vis, node)
    return vis.Vars()
}

// OutputVars: 提取输出变量（赋值左侧）
func OutputVars(body Body) VarSet {
    outputs := NewVarSet()
    
    for _, expr := range body {
        if expr.IsEquality() {
            terms := expr.Operands()
            left := terms[1]
            
            // 如果左侧是变量，它是输出变量
            if v, ok := left.Value.(Var); ok {
                outputs.Add(v)
            }
        }
    }
    
    return outputs
}

// UnsafeVars: 提取不安全变量
func UnsafeVars(body Body) VarSet {
    all := Vars(body)
    safe := SafeVars(body)
    return all.Diff(safe)
}

// SafeVars: 提取安全变量
func SafeVars(body Body) VarSet {
    safe := NewVarSet()
    
    for _, expr := range body {
        // 等式左侧的变量是安全的
        if expr.IsEquality() {
            terms := expr.Operands()
            collectVars(terms[1], safe)
        }
        
        // ground term中的变量是安全的
        for _, term := range expr.Operands() {
            if term.IsGround() {
                collectVars(term, safe)
            }
        }
    }
    
    return safe
}
```

### 6.2 引用重写

```go
// RewriteRefs: 重写引用
type RewriteRefs struct {
    rewrite func(Ref) (Ref, error)
}

func (r *RewriteRefs) Transform(node interface{}) (interface{}, error) {
    if term, ok := node.(*Term); ok {
        if ref, ok := term.Value.(Ref); ok {
            newRef, err := r.rewrite(ref)
            if err != nil {
                return nil, err
            }
            
            if !newRef.Equal(ref) {
                newTerm := *term
                newTerm.Value = newRef
                return &newTerm, nil
            }
        }
    }
    return node, nil
}

// 示例: 将 data.* 前缀改为 input.*
rewriter := &RewriteRefs{
    rewrite: func(ref Ref) (Ref, error) {
        if len(ref) > 0 {
            if v, ok := ref[0].Value.(Var); ok && v == Var("data") {
                newRef := make(Ref, len(ref))
                newRef[0] = VarTerm("input")
                copy(newRef[1:], ref[1:])
                return newRef, nil
            }
        }
        return ref, nil
    },
}
```

### 6.3 表达式简化

```go
// SimplifyExprs: 简化表达式
func SimplifyExprs(body Body) Body {
    result := make(Body, 0, len(body))
    
    for _, expr := range body {
        // 移除恒真表达式: true
        if isTautology(expr) {
            continue
        }
        
        // 检测矛盾: false
        if isContradiction(expr) {
            // 整个body为false
            return Body{}
        }
        
        result = append(result, expr)
    }
    
    return result
}

// isTautology: 是否是恒真表达式
func isTautology(expr *Expr) bool {
    // true
    if term, ok := expr.Terms.(*Term); ok {
        if b, ok := term.Value.(Boolean); ok && b {
            return true
        }
    }
    
    // x == x
    if expr.IsEquality() {
        terms := expr.Operands()
        if terms[1].Equal(terms[2]) {
            return true
        }
    }
    
    return false
}

// isContradiction: 是否是矛盾
func isContradiction(expr *Expr) bool {
    // false
    if term, ok := expr.Terms.(*Term); ok {
        if b, ok := term.Value.(Boolean); ok && !b {
            return true
        }
    }
    
    // x != x
    if isNotEqual(expr) {
        terms := expr.Operands()
        if terms[1].Equal(terms[2]) {
            return true
        }
    }
    
    return false
}
```

### 6.4 安全性检查

```go
// CheckSafety: 安全性检查
func CheckSafety(module *Module) Errors {
    var errors Errors
    
    for _, rule := range module.Rules {
        // 检查规则体的安全性
        unsafe := UnsafeVars(rule.Body)
        
        if unsafe.Len() > 0 {
            errors = append(errors, &Error{
                Code:     UnsafeVarErr,
                Message:  fmt.Sprintf("unsafe variables: %v", unsafe),
                Location: rule.Location,
            })
        }
        
        // 检查规则头部的安全性
        headVars := Vars(rule.Head.Value)
        bodyVars := SafeVars(rule.Body)
        
        unsafeHead := headVars.Diff(bodyVars)
        if unsafeHead.Len() > 0 {
            errors = append(errors, &Error{
                Code:     UnsafeVarErr,
                Message:  fmt.Sprintf("unsafe variables in head: %v", unsafeHead),
                Location: rule.Head.Location,
            })
        }
    }
    
    return errors
}
```

---

## 7. 编译器使用的转换

### 7.1 局部变量重写

```go
// RewriteLocalVars: 重写局部变量
// 为每个规则的局部变量添加唯一前缀
type RewriteLocalVars struct {
    ruleIndex int
}

func (r *RewriteLocalVars) Transform(node interface{}) (interface{}, error) {
    rule, ok := node.(*Rule)
    if !ok {
        return node, nil
    }
    
    r.ruleIndex++
    
    // 收集局部变量（不包括输入变量）
    locals := r.collectLocalVars(rule)
    
    // 创建重命名映射
    mapping := make(map[Var]Var)
    for v := range locals {
        mapping[v] = Var(fmt.Sprintf("__%s_%d", v, r.ruleIndex))
    }
    
    // 应用重命名
    renamer := NewRenameVars(mapping)
    return Transform(renamer, rule)
}

func (r *RewriteLocalVars) collectLocalVars(rule *Rule) VarSet {
    all := Vars(rule.Body)
    
    // 移除全局变量（input, data等）
    globals := NewVarSet()
    globals.Add(Var("input"))
    globals.Add(Var("data"))
    
    return all.Diff(globals)
}

// 示例:
// 输入:  allow if { x = 1; y = x + 1 }
// 输出:  allow if { __x_1 = 1; __y_1 = __x_1 + 1 }
```

### 7.2 推导式展开

```go
// ExpandComprehensions: 展开推导式
// 将推导式转换为规则
type ExpandComprehensions struct {
    ruleCounter int
}

func (e *ExpandComprehensions) Transform(node interface{}) (interface{}, error) {
    term, ok := node.(*Term)
    if !ok {
        return node, nil
    }
    
    switch comp := term.Value.(type) {
    case *ArrayComprehension:
        return e.expandArrayComp(comp)
    case *SetComprehension:
        return e.expandSetComp(comp)
    case *ObjectComprehension:
        return e.expandObjectComp(comp)
    }
    
    return node, nil
}

func (e *ExpandComprehensions) expandArrayComp(comp *ArrayComprehension) (*Term, error) {
    // [x | x = arr[_]; x > 5]
    // 转换为:
    // __result := [x | __internal_rule]
    // __internal_rule[x] { x = arr[_]; x > 5 }
    
    e.ruleCounter++
    ruleName := Var(fmt.Sprintf("__comp_%d", e.ruleCounter))
    
    // 创建内部规则
    rule := &Rule{
        Head: &Head{
            Name:  ruleName,
            Key:   comp.Term,  // x
        },
        Body: comp.Body,  // x = arr[_]; x > 5
    }
    
    // 返回对规则的引用
    return RefTerm(VarTerm(ruleName)), nil
}

// 示例:
// 输入:  result := [x | x = arr[_]; x > 5]
// 输出:  result := __comp_1
//        __comp_1[x] { x = arr[_]; x > 5 }
```

### 7.3 动态项重写

```go
// RewriteDynamicTerms: 重写动态项
// 将动态计算的项提取为变量
type RewriteDynamicTerms struct {
    varCounter int
}

func (r *RewriteDynamicTerms) Transform(node interface{}) (interface{}, error) {
    expr, ok := node.(*Expr)
    if !ok {
        return node, nil
    }
    
    var newExprs []*Expr
    
    for _, term := range expr.Operands() {
        if r.isDynamic(term) {
            // 创建新变量
            r.varCounter++
            newVar := Var(fmt.Sprintf("__dyn_%d", r.varCounter))
            
            // 创建赋值表达式
            assign := Equality.Expr(VarTerm(newVar.String()), term)
            newExprs = append(newExprs, assign)
            
            // 替换原项为变量
            // ... (实现略)
        }
    }
    
    // ... 返回重写后的表达式
    return expr, nil
}

func (r *RewriteDynamicTerms) isDynamic(term *Term) bool {
    // 检查term是否包含函数调用或推导式
    switch term.Value.(type) {
    case Call, *ArrayComprehension, *SetComprehension, *ObjectComprehension:
        return true
    }
    return false
}

// 示例:
// 输入:  allow if { input.role == upper(data.required_role) }
// 输出:  allow if {
//            __dyn_1 = upper(data.required_role)
//            input.role == __dyn_1
//        }
```

### 7.4 With语句转换

```go
// RewriteWithStatements: 转换with语句
// 将with语句转换为临时赋值
type RewriteWithStatements struct{}

func (r *RewriteWithStatements) Transform(node interface{}) (interface{}, error) {
    expr, ok := node.(*Expr)
    if !ok || len(expr.With) == 0 {
        return node, nil
    }
    
    // data.config with input.user as "admin"
    // 转换为:
    // __with_input_user = input.user   # 保存原值
    // input.user = "admin"             # 替换
    // data.config                      # 执行表达式
    // input.user = __with_input_user   # 恢复原值
    
    var setup []*Expr
    var teardown []*Expr
    
    for i, with := range expr.With {
        // 生成临时变量
        tmpVar := Var(fmt.Sprintf("__with_%d", i))
        
        // 保存原值
        setup = append(setup, Equality.Expr(
            VarTerm(tmpVar.String()),
            with.Target,
        ))
        
        // 替换值
        setup = append(setup, Equality.Expr(
            with.Target,
            with.Value,
        ))
        
        // 恢复原值
        teardown = append(teardown, Equality.Expr(
            with.Target,
            VarTerm(tmpVar.String()),
        ))
    }
    
    // 构建新的表达式序列
    // ... (实现略)
    
    return expr, nil
}
```

---

## 8. AST比较与统一

### 8.1 结构比较

```go
// Equal: 结构相等性比较
func (a *Term) Equal(b *Term) bool {
    return a.Value.Compare(b.Value) == 0
}

// Compare: 比较两个Value
func CompareValues(a, b Value) int {
    // 1. 类型优先级: Null < Boolean < Number < String < Var < Ref < ...
    typeOrder := map[string]int{
        "Null":    0,
        "Boolean": 1,
        "Number":  2,
        "String":  3,
        "Var":     4,
        "Ref":     5,
        "Array":   6,
        "Object":  7,
        "Set":     8,
    }
    
    aType := reflect.TypeOf(a).Name()
    bType := reflect.TypeOf(b).Name()
    
    if typeOrder[aType] < typeOrder[bType] {
        return -1
    } else if typeOrder[aType] > typeOrder[bType] {
        return 1
    }
    
    // 2. 相同类型，调用Compare方法
    return a.Compare(b)
}

// DeepEqual: 深度相等性比较
func DeepEqual(a, b interface{}) bool {
    switch x := a.(type) {
    case *Module:
        y, ok := b.(*Module)
        if !ok {
            return false
        }
        return deepEqualModule(x, y)
        
    case *Rule:
        y, ok := b.(*Rule)
        if !ok {
            return false
        }
        return deepEqualRule(x, y)
        
    // ... 其他类型 ...
    }
    
    return false
}
```

### 8.2 统一算法

```go
// Unify: 统一两个term
// 返回: 统一后的替换（substitution）
func Unify(a, b *Term) (*Subst, error) {
    subst := NewSubst()
    if err := unifyTerms(a, b, subst); err != nil {
        return nil, err
    }
    return subst, nil
}

// unifyTerms: 统一算法核心
func unifyTerms(a, b *Term, subst *Subst) error {
    // 应用当前替换
    a = subst.Apply(a)
    b = subst.Apply(b)
    
    // 如果相等，统一成功
    if a.Equal(b) {
        return nil
    }
    
    // 如果a是变量，绑定到b
    if v, ok := a.Value.(Var); ok {
        return subst.Bind(v, b)
    }
    
    // 如果b是变量，绑定到a
    if v, ok := b.Value.(Var); ok {
        return subst.Bind(v, a)
    }
    
    // 递归统一复合类型
    switch aVal := a.Value.(type) {
    case Ref:
        bVal, ok := b.Value.(Ref)
        if !ok || len(aVal) != len(bVal) {
            return fmt.Errorf("cannot unify %v and %v", a, b)
        }
        
        for i := range aVal {
            if err := unifyTerms(aVal[i], bVal[i], subst); err != nil {
                return err
            }
        }
        return nil
        
    case Array:
        bVal, ok := b.Value.(Array)
        if !ok || len(aVal) != len(bVal) {
            return fmt.Errorf("cannot unify %v and %v", a, b)
        }
        
        for i := range aVal {
            if err := unifyTerms(aVal[i], bVal[i], subst); err != nil {
                return err
            }
        }
        return nil
        
    // ... 其他类型 ...
    }
    
    return fmt.Errorf("cannot unify %v and %v", a, b)
}

// 示例:
// Unify(Var("x"), IntNumberTerm(5))
// 结果: {x → 5}

// Unify(Array{Var("x"), Var("y")}, Array{IntNumberTerm(1), IntNumberTerm(2)})
// 结果: {x → 1, y → 2}
```

### 8.3 替换（Substitution）

```go
// Subst: 替换（变量绑定）
type Subst struct {
    bindings map[Var]*Term
}

func NewSubst() *Subst {
    return &Subst{
        bindings: make(map[Var]*Term),
    }
}

// Bind: 绑定变量
func (s *Subst) Bind(v Var, term *Term) error {
    // 检查循环绑定
    if occursCheck(v, term) {
        return fmt.Errorf("occurs check failed: %v in %v", v, term)
    }
    
    s.bindings[v] = term
    return nil
}

// Apply: 应用替换
func (s *Subst) Apply(term *Term) *Term {
    switch val := term.Value.(type) {
    case Var:
        if bound, ok := s.bindings[val]; ok {
            // 递归应用（处理传递绑定）
            return s.Apply(bound)
        }
        return term
        
    case Ref:
        ref := make(Ref, len(val))
        for i, t := range val {
            ref[i] = s.Apply(t)
        }
        return &Term{Value: ref}
        
    case Array:
        arr := make(Array, len(val))
        for i, t := range val {
            arr[i] = s.Apply(t)
        }
        return &Term{Value: arr}
        
    // ... 其他类型 ...
    }
    
    return term
}

// occursCheck: 循环检查
// 检查变量v是否出现在term中
func occursCheck(v Var, term *Term) bool {
    if varTerm, ok := term.Value.(Var); ok {
        return v == varTerm
    }
    
    vars := Vars(term)
    return vars.Contains(v)
}
```

---

## 9. 性能优化

### 9.1 内存池

```go
// TermPool: Term对象池
var termPool = sync.Pool{
    New: func() interface{} {
        return &Term{}
    },
}

// GetTerm: 从池中获取Term
func GetTerm() *Term {
    return termPool.Get().(*Term)
}

// PutTerm: 归还Term到池
func PutTerm(term *Term) {
    term.Value = nil
    term.Location = nil
    termPool.Put(term)
}

// 使用:
term := GetTerm()
term.Value = String("hello")
// ... 使用term ...
PutTerm(term)
```

### 9.2 缓存机制

```go
// ASTCache: AST缓存
type ASTCache struct {
    mu    sync.RWMutex
    cache map[string]*Module
}

func NewASTCache() *ASTCache {
    return &ASTCache{
        cache: make(map[string]*Module),
    }
}

// Get: 获取缓存的模块
func (c *ASTCache) Get(key string) (*Module, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    module, ok := c.cache[key]
    return module, ok
}

// Put: 缓存模块
func (c *ASTCache) Put(key string, module *Module) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.cache[key] = module
}

// 使用:
cache := NewASTCache()

// 解析时检查缓存
if module, ok := cache.Get(filename); ok {
    return module
}

// 解析并缓存
module, _ := ParseModule(filename, source)
cache.Put(filename, module)
```

### 9.3 延迟计算

```go
// LazyValue: 延迟计算的Value
type LazyValue struct {
    compute func() Value
    value   Value
    once    sync.Once
}

func NewLazyValue(compute func() Value) *LazyValue {
    return &LazyValue{compute: compute}
}

// Get: 获取值（第一次调用时计算）
func (lv *LazyValue) Get() Value {
    lv.once.Do(func() {
        lv.value = lv.compute()
    })
    return lv.value
}

// 使用:
lazy := NewLazyValue(func() Value {
    // 昂贵的计算
    return computeExpensiveValue()
})

// 只在需要时计算
value := lazy.Get()
```

---

## 10. 实战示例

### 10.1 自定义转换器

**删除未使用的规则**:

```go
// RemoveUnusedRules: 删除未使用的规则
type RemoveUnusedRules struct {
    entrypoints []string
}

func NewRemoveUnusedRules(entrypoints []string) *RemoveUnusedRules {
    return &RemoveUnusedRules{entrypoints: entrypoints}
}

func (r *RemoveUnusedRules) Transform(node interface{}) (interface{}, error) {
    module, ok := node.(*Module)
    if !ok {
        return node, nil
    }
    
    // 1. 构建规则依赖图
    graph := r.buildDependencyGraph(module)
    
    // 2. 从入口点开始标记可达规则
    reachable := r.markReachable(graph, r.entrypoints)
    
    // 3. 移除不可达规则
    newRules := make([]*Rule, 0)
    for _, rule := range module.Rules {
        if reachable.Contains(rule.Head.Name) {
            newRules = append(newRules, rule)
        }
    }
    
    newModule := *module
    newModule.Rules = newRules
    return &newModule, nil
}

func (r *RemoveUnusedRules) buildDependencyGraph(module *Module) map[Var][]Var {
    graph := make(map[Var][]Var)
    
    for _, rule := range module.Rules {
        name := rule.Head.Name
        
        // 收集规则体中引用的其他规则
        refs := collectRuleRefs(rule.Body)
        graph[name] = refs
    }
    
    return graph
}

// 使用:
transformer := NewRemoveUnusedRules([]string{"allow", "deny"})
optimizedModule, _ := Transform(transformer, module)
```

### 10.2 AST分析工具

**复杂度分析**:

```go
// ComplexityAnalyzer: 复杂度分析器
type ComplexityAnalyzer struct {
    totalRules int
    totalExprs int
    maxDepth   int
}

func (a *ComplexityAnalyzer) Analyze(module *Module) {
    a.totalRules = len(module.Rules)
    
    for _, rule := range module.Rules {
        a.totalExprs += len(rule.Body)
        depth := a.measureDepth(rule)
        if depth > a.maxDepth {
            a.maxDepth = depth
        }
    }
}

func (a *ComplexityAnalyzer) measureDepth(rule *Rule) int {
    maxDepth := 0
    
    for _, expr := range rule.Body {
        for _, term := range expr.Operands() {
            depth := a.termDepth(term)
            if depth > maxDepth {
                maxDepth = depth
            }
        }
    }
    
    return maxDepth
}

func (a *ComplexityAnalyzer) termDepth(term *Term) int {
    switch val := term.Value.(type) {
    case Ref:
        return len(val)
    case Array:
        maxDepth := 0
        for _, t := range val {
            depth := a.termDepth(t)
            if depth > maxDepth {
                maxDepth = depth
            }
        }
        return maxDepth + 1
    // ... 其他类型 ...
    }
    return 1
}

func (a *ComplexityAnalyzer) Report() string {
    return fmt.Sprintf(`
Complexity Report:
  Total Rules: %d
  Total Expressions: %d
  Max Nesting Depth: %d
`, a.totalRules, a.totalExprs, a.maxDepth)
}

// 使用:
analyzer := &ComplexityAnalyzer{}
analyzer.Analyze(module)
fmt.Println(analyzer.Report())
```

### 10.3 代码生成

**生成Go代码**:

```go
// GoCodeGen: Go代码生成器
type GoCodeGen struct {
    buf strings.Builder
}

func (g *GoCodeGen) Generate(module *Module) string {
    g.buf.WriteString("package main\n\n")
    g.buf.WriteString("import \"fmt\"\n\n")
    
    for _, rule := range module.Rules {
        g.generateRule(rule)
    }
    
    return g.buf.String()
}

func (g *GoCodeGen) generateRule(rule *Rule) {
    // 生成函数签名
    g.buf.WriteString(fmt.Sprintf("func %s(input map[string]interface{}) bool {\n",
        rule.Head.Name))
    
    // 生成规则体
    for _, expr := range rule.Body {
        g.generateExpr(expr)
    }
    
    // 生成返回语句
    if rule.Head.Value != nil {
        g.buf.WriteString(fmt.Sprintf("    return %s\n", g.termToGo(rule.Head.Value)))
    }
    
    g.buf.WriteString("}\n\n")
}

func (g *GoCodeGen) generateExpr(expr *Expr) {
    if expr.IsEquality() {
        terms := expr.Operands()
        left := g.termToGo(terms[1])
        right := g.termToGo(terms[2])
        g.buf.WriteString(fmt.Sprintf("    if %s != %s { return false }\n", left, right))
    }
}

func (g *GoCodeGen) termToGo(term *Term) string {
    switch val := term.Value.(type) {
    case String:
        return fmt.Sprintf("%q", val)
    case Number:
        return string(val)
    case Boolean:
        return fmt.Sprintf("%t", val)
    case Ref:
        return g.refToGo(val)
    // ... 其他类型 ...
    }
    return "nil"
}

func (g *GoCodeGen) refToGo(ref Ref) string {
    // input.method → input["method"]
    result := ref[0].String()
    for i := 1; i < len(ref); i++ {
        result += fmt.Sprintf("[%s]", g.termToGo(ref[i]))
    }
    return result
}

// 使用:
gen := &GoCodeGen{}
code := gen.Generate(module)
fmt.Println(code)
```

---

## 附录

### A. 完整AST类型参考

```go
// 所有AST类型的快速参考

// 顶层
type Module struct {...}
type Package struct {...}
type Import struct {...}
type Comment struct {...}

// 规则
type Rule struct {...}
type Head struct {...}
type Body []*Expr
type Args []*Term

// 表达式
type Expr struct {...}
type With struct {...}

// 项
type Term struct {...}

// 值类型
type Null struct{}
type Boolean bool
type Number json.Number
type String string
type Var string
type Ref []*Term
type Array []*Term
type Object [][2]*Term
type Set []*Term
type Call []*Term

// 推导式
type ArrayComprehension struct {...}
type ObjectComprehension struct {...}
type SetComprehension struct {...}
```

### B. 转换器清单

**OPA内置转换器**:

1. `RewriteLocalVars` - 局部变量重写
2. `CheckTypes` - 类型检查
3. `CheckSafety` - 安全性检查
4. `CheckRecursion` - 递归检查
5. `RewriteComprehensions` - 推导式重写
6. `RewriteDynamicTerms` - 动态项重写
7. `RewriteWith` - With语句转换
8. `RewriteRefsInHead` - 头部引用重写
9. `BuildRuleGraph` - 构建规则图
10. `InlineRules` - 规则内联

### C. 调试工具

**AST打印器**:

```go
// PrettyPrint: 美观打印AST
func PrettyPrint(node interface{}) string {
    var buf bytes.Buffer
    prettyPrintNode(&buf, node, 0)
    return buf.String()
}

func prettyPrintNode(buf *bytes.Buffer, node interface{}, indent int) {
    prefix := strings.Repeat("  ", indent)
    
    switch n := node.(type) {
    case *Module:
        fmt.Fprintf(buf, "%sModule\n", prefix)
        prettyPrintNode(buf, n.Package, indent+1)
        for _, imp := range n.Imports {
            prettyPrintNode(buf, imp, indent+1)
        }
        for _, rule := range n.Rules {
            prettyPrintNode(buf, rule, indent+1)
        }
        
    case *Rule:
        fmt.Fprintf(buf, "%sRule: %s\n", prefix, n.Head.Name)
        for _, expr := range n.Body {
            prettyPrintNode(buf, expr, indent+1)
        }
        
    case *Expr:
        fmt.Fprintf(buf, "%sExpr: %s\n", prefix, n.String())
        
    // ... 其他类型 ...
    }
}

// 使用:
fmt.Println(PrettyPrint(module))
```

**AST差异比较**:

```go
// Diff: 比较两个AST的差异
func Diff(a, b interface{}) []string {
    var diffs []string
    diffNode(a, b, "", &diffs)
    return diffs
}

func diffNode(a, b interface{}, path string, diffs *[]string) {
    if reflect.TypeOf(a) != reflect.TypeOf(b) {
        *diffs = append(*diffs, fmt.Sprintf("%s: type mismatch", path))
        return
    }
    
    switch x := a.(type) {
    case *Module:
        y := b.(*Module)
        if len(x.Rules) != len(y.Rules) {
            *diffs = append(*diffs, fmt.Sprintf("%s.Rules: length mismatch", path))
        }
        // ... 详细比较 ...
        
    // ... 其他类型 ...
    }
}

// 使用:
diffs := Diff(oldModule, newModule)
for _, diff := range diffs {
    fmt.Println(diff)
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日  
**维护者**: OPA技术文档项目  
**反馈**: 欢迎通过GitHub Issues提供建议

**相关阅读**:

- [词法器与语法解析器实现](10.2-词法器与语法解析器实现.md) - 解析器实现
- [编译器实现详解](10.4-编译器实现详解.md) - 编译优化
- [Rego形式化语义](../06-形式化证明/06.2-Rego形式化语义.md) - 形式化定义
