# ASTæ„å»ºä¸è½¬æ¢

> **æ–‡æ¡£ç±»å‹**: æºç å®ç°åˆ†æ  
> **æ ¸å¿ƒæ¨¡å—**: `ast/ast.go`, `ast/transform.go`, `ast/visitor.go`  
> **é€‚ç”¨è¯»è€…**: ç¼–è¯‘å™¨å¼€å‘è€…ã€OPAè´¡çŒ®è€…ã€é«˜çº§ç”¨æˆ·  
> **å…ˆä¿®çŸ¥è¯†**: [è¯æ³•å™¨ä¸è¯­æ³•è§£æå™¨](10.2-è¯æ³•å™¨ä¸è¯­æ³•è§£æå™¨å®ç°.md)ã€[Regoè¯­æ³•](../02-è¯­è¨€æ¨¡å‹/02.1-Regoè¯­æ³•è§„èŒƒ.md)  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 2.3 - ASTæ“ä½œ  
> **OPAç‰ˆæœ¬**: v0.68.0

---

## ğŸ¯ å®ç°åˆ†æè¯´æ˜

> **æœ¬æ–‡æ¡£ç›®æ ‡**:
>
> - âœ… æ·±å…¥ç†è§£OPA ASTçš„å®Œæ•´ç»“æ„
> - âœ… æŒæ¡ASTæ„å»ºå’Œè½¬æ¢çš„å®ç°æŠ€æœ¯
> - âœ… å­¦ä¹ Visitoræ¨¡å¼åœ¨ç¼–è¯‘å™¨ä¸­çš„åº”ç”¨
> - âœ… ç†è§£å„ç§ASTé‡å†™å’Œä¼˜åŒ–æŠ€æœ¯
>
> **æŠ€æœ¯äº®ç‚¹**:
>
> - **ä¸å¯å˜AST**: å‡½æ•°å¼è®¾è®¡ç†å¿µ
> - **Visitoræ¨¡å¼**: çµæ´»çš„éå†æœºåˆ¶
> - **è½¬æ¢ç®¡é“**: æ¨¡å—åŒ–çš„ASTé‡å†™
> - **ç±»å‹å®‰å…¨**: Goç±»å‹ç³»ç»Ÿä¿è¯
>
> **å®æˆ˜ä»·å€¼**:
>
> - ASTæ“ä½œå’Œåˆ†æ
> - è‡ªå®šä¹‰Regoè½¬æ¢
> - ä»£ç ä¼˜åŒ–å®ç°
> - é™æ€åˆ†æå·¥å…·

---

## ç›®å½•

- [ASTæ„å»ºä¸è½¬æ¢](#astæ„å»ºä¸è½¬æ¢)
  - [ğŸ¯ å®ç°åˆ†æè¯´æ˜](#-å®ç°åˆ†æè¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. ASTæ¶æ„æ€»è§ˆ](#1-astæ¶æ„æ€»è§ˆ)
    - [1.1 è®¾è®¡åŸåˆ™](#11-è®¾è®¡åŸåˆ™)
    - [1.2 æ ¸å¿ƒç±»å‹å±‚æ¬¡](#12-æ ¸å¿ƒç±»å‹å±‚æ¬¡)
    - [1.3 èŠ‚ç‚¹å…³ç³»å›¾](#13-èŠ‚ç‚¹å…³ç³»å›¾)
  - [2. ASTèŠ‚ç‚¹å®šä¹‰](#2-astèŠ‚ç‚¹å®šä¹‰)
    - [2.1 åŸºç¡€æ¥å£](#21-åŸºç¡€æ¥å£)
    - [2.2 Valueç±»å‹](#22-valueç±»å‹)
    - [2.3 TermèŠ‚ç‚¹](#23-termèŠ‚ç‚¹)
    - [2.4 ExprèŠ‚ç‚¹](#24-exprèŠ‚ç‚¹)
    - [2.5 RuleèŠ‚ç‚¹](#25-ruleèŠ‚ç‚¹)
    - [2.6 ModuleèŠ‚ç‚¹](#26-moduleèŠ‚ç‚¹)
  - [3. ASTæ„å»º](#3-astæ„å»º)
    - [3.1 æ„å»ºå™¨æ¨¡å¼](#31-æ„å»ºå™¨æ¨¡å¼)
    - [3.2 è¾…åŠ©æ„é€ å‡½æ•°](#32-è¾…åŠ©æ„é€ å‡½æ•°)
    - [3.3 ä»é›¶æ„å»ºAST](#33-ä»é›¶æ„å»ºast)
    - [3.4 ASTéªŒè¯](#34-astéªŒè¯)
  - [4. ASTéå†](#4-astéå†)
    - [4.1 Visitoræ¥å£](#41-visitoræ¥å£)
    - [4.2 Walkå‡½æ•°](#42-walkå‡½æ•°)
    - [4.3 éå†ç­–ç•¥](#43-éå†ç­–ç•¥)
    - [4.4 å®ç”¨éå†å™¨](#44-å®ç”¨éå†å™¨)
  - [5. ASTè½¬æ¢](#5-astè½¬æ¢)
    - [5.1 Transformæ¥å£](#51-transformæ¥å£)
    - [5.2 é€šç”¨è½¬æ¢å‡½æ•°](#52-é€šç”¨è½¬æ¢å‡½æ•°)
    - [5.3 è½¬æ¢å™¨ç»„åˆ](#53-è½¬æ¢å™¨ç»„åˆ)
    - [5.4 å¸¸ç”¨è½¬æ¢](#54-å¸¸ç”¨è½¬æ¢)
  - [6. é‡è¦ASTæ“ä½œ](#6-é‡è¦astæ“ä½œ)
    - [6.1 å˜é‡æå–](#61-å˜é‡æå–)
    - [6.2 å¼•ç”¨é‡å†™](#62-å¼•ç”¨é‡å†™)
    - [6.3 è¡¨è¾¾å¼ç®€åŒ–](#63-è¡¨è¾¾å¼ç®€åŒ–)
    - [6.4 å®‰å…¨æ€§æ£€æŸ¥](#64-å®‰å…¨æ€§æ£€æŸ¥)
  - [7. ç¼–è¯‘å™¨ä½¿ç”¨çš„è½¬æ¢](#7-ç¼–è¯‘å™¨ä½¿ç”¨çš„è½¬æ¢)
    - [7.1 å±€éƒ¨å˜é‡é‡å†™](#71-å±€éƒ¨å˜é‡é‡å†™)
    - [7.2 æ¨å¯¼å¼å±•å¼€](#72-æ¨å¯¼å¼å±•å¼€)
    - [7.3 åŠ¨æ€é¡¹é‡å†™](#73-åŠ¨æ€é¡¹é‡å†™)
    - [7.4 Withè¯­å¥è½¬æ¢](#74-withè¯­å¥è½¬æ¢)
  - [8. ASTæ¯”è¾ƒä¸ç»Ÿä¸€](#8-astæ¯”è¾ƒä¸ç»Ÿä¸€)
    - [8.1 ç»“æ„æ¯”è¾ƒ](#81-ç»“æ„æ¯”è¾ƒ)
    - [8.2 ç»Ÿä¸€ç®—æ³•](#82-ç»Ÿä¸€ç®—æ³•)
    - [8.3 æ›¿æ¢ï¼ˆSubstitutionï¼‰](#83-æ›¿æ¢substitution)
  - [9. æ€§èƒ½ä¼˜åŒ–](#9-æ€§èƒ½ä¼˜åŒ–)
    - [9.1 å†…å­˜æ± ](#91-å†…å­˜æ± )
    - [9.2 ç¼“å­˜æœºåˆ¶](#92-ç¼“å­˜æœºåˆ¶)
    - [9.3 å»¶è¿Ÿè®¡ç®—](#93-å»¶è¿Ÿè®¡ç®—)
  - [10. å®æˆ˜ç¤ºä¾‹](#10-å®æˆ˜ç¤ºä¾‹)
    - [10.1 è‡ªå®šä¹‰è½¬æ¢å™¨](#101-è‡ªå®šä¹‰è½¬æ¢å™¨)
    - [10.2 ASTåˆ†æå·¥å…·](#102-aståˆ†æå·¥å…·)
    - [10.3 ä»£ç ç”Ÿæˆ](#103-ä»£ç ç”Ÿæˆ)
  - [é™„å½•](#é™„å½•)
    - [A. å®Œæ•´ASTç±»å‹å‚è€ƒ](#a-å®Œæ•´astç±»å‹å‚è€ƒ)
    - [B. è½¬æ¢å™¨æ¸…å•](#b-è½¬æ¢å™¨æ¸…å•)
    - [C. è°ƒè¯•å·¥å…·](#c-è°ƒè¯•å·¥å…·)

---

## 1. ASTæ¶æ„æ€»è§ˆ

### 1.1 è®¾è®¡åŸåˆ™

OPAçš„ASTè®¾è®¡éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š

**1. ä¸å¯å˜æ€§ï¼ˆImmutabilityï¼‰**:

```go
// ASTèŠ‚ç‚¹ä¸€æ—¦åˆ›å»ºå°±ä¸å¯ä¿®æ”¹
// æ‰€æœ‰"ä¿®æ”¹"æ“ä½œè¿”å›æ–°èŠ‚ç‚¹

rule := &Rule{Head: head, Body: body}
// ä¸èƒ½: rule.Body = newBody  âŒ
// æ­£ç¡®: newRule := rule.Copy()  âœ…
```

**2. ç±»å‹å®‰å…¨**:

```go
// ä½¿ç”¨Goæ¥å£å®ç°å¤šæ€
type Value interface {
    String() string
    Compare(Value) int
}

// æ¯ç§å€¼ç±»å‹éƒ½å®ç°Valueæ¥å£
type String string
type Number json.Number
type Boolean bool
```

**3. ä½ç½®è¿½è¸ª**:

```go
// æ¯ä¸ªèŠ‚ç‚¹ä¿å­˜æºç ä½ç½®
type Rule struct {
    Location *Location  // æ–‡ä»¶åã€è¡Œå·ã€åˆ—å·
    Head     *Head
    Body     Body
}
```

**4. è‡ªæè¿°**:

```go
// èŠ‚ç‚¹åŒ…å«è¶³å¤Ÿçš„å…ƒä¿¡æ¯
type Builtin struct {
    Name string
    Decl *types.Function  // ç±»å‹ç­¾å
    // ...
}
```

### 1.2 æ ¸å¿ƒç±»å‹å±‚æ¬¡

```text
Node (interface)
â”œâ”€â”€ Value (interface)
â”‚   â”œâ”€â”€ Null
â”‚   â”œâ”€â”€ Boolean
â”‚   â”œâ”€â”€ Number
â”‚   â”œâ”€â”€ String
â”‚   â”œâ”€â”€ Var          # å˜é‡
â”‚   â”œâ”€â”€ Ref          # å¼•ç”¨
â”‚   â”œâ”€â”€ Array        # æ•°ç»„
â”‚   â”œâ”€â”€ Object       # å¯¹è±¡
â”‚   â”œâ”€â”€ Set          # é›†åˆ
â”‚   â”œâ”€â”€ Call         # å‡½æ•°è°ƒç”¨
â”‚   â”œâ”€â”€ ArrayComprehension
â”‚   â”œâ”€â”€ ObjectComprehension
â”‚   â””â”€â”€ SetComprehension
â”‚
â”œâ”€â”€ Term             # å¸¦ä½ç½®çš„Value
â”œâ”€â”€ Expr             # è¡¨è¾¾å¼
â”œâ”€â”€ With             # Withè¯­å¥
â”œâ”€â”€ Body             # è¡¨è¾¾å¼åˆ—è¡¨
â”œâ”€â”€ Head             # è§„åˆ™å¤´éƒ¨
â”œâ”€â”€ Rule             # è§„åˆ™
â”œâ”€â”€ Import           # Importè¯­å¥
â”œâ”€â”€ Package          # Packageå£°æ˜
â””â”€â”€ Module           # æ¨¡å—
```

### 1.3 èŠ‚ç‚¹å…³ç³»å›¾

```text
Module
â”œâ”€â”€ Package
â”‚   â””â”€â”€ Path: Ref
â”‚
â”œâ”€â”€ Imports []
â”‚   â””â”€â”€ Import
â”‚       â”œâ”€â”€ Path: Ref
â”‚       â””â”€â”€ Alias: Var
â”‚
â””â”€â”€ Rules []
    â””â”€â”€ Rule
        â”œâ”€â”€ Head
        â”‚   â”œâ”€â”€ Name: Var
        â”‚   â”œâ”€â”€ Args: []Term
        â”‚   â”œâ”€â”€ Key: Term
        â”‚   â””â”€â”€ Value: Term
        â”‚
        â”œâ”€â”€ Body: []Expr
        â”‚   â””â”€â”€ Expr
        â”‚       â”œâ”€â”€ Terms: []Term
        â”‚       â”œâ”€â”€ With: []With
        â”‚       â””â”€â”€ Negated: bool
        â”‚
        â””â”€â”€ Else: *Rule
```

---

## 2. ASTèŠ‚ç‚¹å®šä¹‰

### 2.1 åŸºç¡€æ¥å£

**Nodeæ¥å£**:

```go
// Node: ASTèŠ‚ç‚¹åŸºç¡€æ¥å£
type Node interface {
    // Loc: è¿”å›æºç ä½ç½®
    Loc() *Location
    
    // String: è¿”å›èŠ‚ç‚¹çš„å­—ç¬¦ä¸²è¡¨ç¤º
    String() string
}

// Location: æºç ä½ç½®
type Location struct {
    File   string  // æ–‡ä»¶å
    Row    int     // è¡Œå·ï¼ˆä»1å¼€å§‹ï¼‰
    Col    int     // åˆ—å·ï¼ˆä»1å¼€å§‹ï¼‰
    Text   []byte  // åŸå§‹æ–‡æœ¬
}
```

**Valueæ¥å£**:

```go
// Value: Regoå€¼æ¥å£
type Value interface {
    // Compare: ä¸å¦ä¸€ä¸ªValueæ¯”è¾ƒ
    // è¿”å›: -1 (å°äº), 0 (ç­‰äº), 1 (å¤§äº)
    Compare(Value) int
    
    // String: å­—ç¬¦ä¸²è¡¨ç¤º
    String() string
    
    // IsGround: æ˜¯å¦æ˜¯groundï¼ˆä¸å«å˜é‡ï¼‰
    IsGround() bool
    
    // Hash: è®¡ç®—å“ˆå¸Œå€¼
    Hash() int
}
```

### 2.2 Valueç±»å‹

**æ ‡é‡ç±»å‹**:

```go
// Null: ç©ºå€¼
type Null struct{}

func (Null) Compare(other Value) int {
    if _, ok := other.(Null); ok {
        return 0
    }
    return -1
}

// Boolean: å¸ƒå°”å€¼
type Boolean bool

func (a Boolean) Compare(other Value) int {
    if b, ok := other.(Boolean); ok {
        if a == b {
            return 0
        }
        if a {
            return 1
        }
        return -1
    }
    return -1
}

// Number: æ•°å­—ï¼ˆä½¿ç”¨json.Numberè¡¨ç¤ºï¼‰
type Number json.Number

func (a Number) Compare(other Value) int {
    b, ok := other.(Number)
    if !ok {
        return 1
    }
    
    // è½¬ä¸ºfloat64æ¯”è¾ƒ
    af, _ := a.Float64()
    bf, _ := b.Float64()
    
    if af < bf {
        return -1
    } else if af > bf {
        return 1
    }
    return 0
}

// String: å­—ç¬¦ä¸²
type String string

func (a String) Compare(other Value) int {
    b, ok := other.(String)
    if !ok {
        return 1
    }
    
    if a < b {
        return -1
    } else if a > b {
        return 1
    }
    return 0
}
```

**å˜é‡ç±»å‹**:

```go
// Var: å˜é‡
type Var string

func (v Var) IsGround() bool {
    return false  // å˜é‡ä¸æ˜¯ground
}

func (a Var) Compare(other Value) int {
    b, ok := other.(Var)
    if !ok {
        return 1
    }
    
    if a < b {
        return -1
    } else if a > b {
        return 1
    }
    return 0
}

// IsWildcard: æ˜¯å¦æ˜¯é€šé…ç¬¦ (_)
func (v Var) IsWildcard() bool {
    return strings.HasPrefix(string(v), "$")
}

// IsGenerated: æ˜¯å¦æ˜¯ç”Ÿæˆçš„å˜é‡
func (v Var) IsGenerated() bool {
    return strings.HasPrefix(string(v), "__")
}
```

**å¼•ç”¨ç±»å‹**:

```go
// Ref: å¼•ç”¨ï¼ˆè·¯å¾„ï¼‰
type Ref []*Term

// ç¤ºä¾‹: data.users[0].name
// Ref{
//     VarTerm("data"),
//     StringTerm("users"),
//     IntNumberTerm(0),
//     StringTerm("name"),
// }

func (ref Ref) IsGround() bool {
    for _, term := range ref {
        if !term.IsGround() {
            return false
        }
    }
    return true
}

func (ref Ref) String() string {
    if len(ref) == 0 {
        return ""
    }
    
    var buf strings.Builder
    buf.WriteString(ref[0].String())
    
    for i := 1; i < len(ref); i++ {
        term := ref[i]
        
        // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œä½¿ç”¨ç‚¹å·
        if str, ok := term.Value.(String); ok {
            buf.WriteByte('.')
            buf.WriteString(string(str))
        } else {
            // å¦åˆ™ä½¿ç”¨æ–¹æ‹¬å·
            buf.WriteByte('[')
            buf.WriteString(term.String())
            buf.WriteByte(']')
        }
    }
    
    return buf.String()
}

// Append: è¿½åŠ è·¯å¾„å…ƒç´ 
func (ref Ref) Append(term *Term) Ref {
    result := make(Ref, len(ref)+1)
    copy(result, ref)
    result[len(ref)] = term
    return result
}

// GroundPrefix: è¿”å›groundå‰ç¼€
func (ref Ref) GroundPrefix() Ref {
    for i, term := range ref {
        if !term.IsGround() {
            return ref[:i]
        }
    }
    return ref
}
```

**å¤åˆç±»å‹**:

```go
// Array: æ•°ç»„
type Array []*Term

func (arr Array) IsGround() bool {
    for _, term := range arr {
        if !term.IsGround() {
            return false
        }
    }
    return true
}

// Object: å¯¹è±¡
type Object [][2]*Term  // é”®å€¼å¯¹æ•°ç»„

// ç¤ºä¾‹: {a: 1, b: 2}
// Object{
//     {StringTerm("a"), IntNumberTerm(1)},
//     {StringTerm("b"), IntNumberTerm(2)},
// }

func (obj Object) IsGround() bool {
    for _, pair := range obj {
        if !pair[0].IsGround() || !pair[1].IsGround() {
            return false
        }
    }
    return true
}

// Get: è·å–é”®å¯¹åº”çš„å€¼
func (obj Object) Get(key *Term) *Term {
    for _, pair := range obj {
        if pair[0].Equal(key) {
            return pair[1]
        }
    }
    return nil
}

// Set: é›†åˆ
type Set []*Term

func (set Set) IsGround() bool {
    for _, term := range set {
        if !term.IsGround() {
            return false
        }
    }
    return true
}

// Contains: æ˜¯å¦åŒ…å«å…ƒç´ 
func (set Set) Contains(term *Term) bool {
    for _, elem := range set {
        if elem.Equal(term) {
            return true
        }
    }
    return false
}
```

**æ¨å¯¼å¼ç±»å‹**:

```go
// ArrayComprehension: æ•°ç»„æ¨å¯¼å¼
// [x | x = arr[_]; x > 5]
type ArrayComprehension struct {
    Term *Term  // ç»“æœé¡¹
    Body Body   // æ¨å¯¼ä½“
}

// ObjectComprehension: å¯¹è±¡æ¨å¯¼å¼
// {k: v | k = keys[_]; v = values[k]}
type ObjectComprehension struct {
    Key   *Term  // é”®é¡¹
    Value *Term  // å€¼é¡¹
    Body  Body   // æ¨å¯¼ä½“
}

// SetComprehension: é›†åˆæ¨å¯¼å¼
// {x | x = arr[_]; x > 5}
type SetComprehension struct {
    Term *Term  // é¡¹
    Body Body   // æ¨å¯¼ä½“
}
```

### 2.3 TermèŠ‚ç‚¹

```go
// Term: å¸¦ä½ç½®ä¿¡æ¯çš„Value
type Term struct {
    Value    Value      // å®é™…å€¼
    Location *Location  // æºç ä½ç½®
}

// NewTerm: åˆ›å»ºTerm
func NewTerm(value Value) *Term {
    return &Term{Value: value}
}

// IsGround: æ˜¯å¦æ˜¯ground
func (term *Term) IsGround() bool {
    return term.Value.IsGround()
}

// Equal: æ˜¯å¦ç›¸ç­‰
func (term *Term) Equal(other *Term) bool {
    return term.Value.Compare(other.Value) == 0
}

// String: å­—ç¬¦ä¸²è¡¨ç¤º
func (term *Term) String() string {
    return term.Value.String()
}

// Copy: æ·±æ‹·è´
func (term *Term) Copy() *Term {
    return &Term{
        Value:    copyValue(term.Value),
        Location: term.Location,
    }
}
```

**è¾…åŠ©æ„é€ å‡½æ•°**:

```go
// æ ‡é‡æ„é€ å‡½æ•°
func NullTerm() *Term {
    return &Term{Value: Null{}}
}

func BooleanTerm(b bool) *Term {
    return &Term{Value: Boolean(b)}
}

func IntNumberTerm(i int64) *Term {
    return &Term{Value: Number(strconv.FormatInt(i, 10))}
}

func FloatNumberTerm(f float64) *Term {
    return &Term{Value: Number(strconv.FormatFloat(f, 'f', -1, 64))}
}

func StringTerm(s string) *Term {
    return &Term{Value: String(s)}
}

// å˜é‡å’Œå¼•ç”¨
func VarTerm(name string) *Term {
    return &Term{Value: Var(name)}
}

func RefTerm(terms ...*Term) *Term {
    return &Term{Value: Ref(terms)}
}

// å¤åˆç±»å‹
func ArrayTerm(terms ...*Term) *Term {
    return &Term{Value: Array(terms)}
}

func ObjectTerm(pairs ...[2]*Term) *Term {
    return &Term{Value: Object(pairs)}
}

func SetTerm(terms ...*Term) *Term {
    return &Term{Value: Set(terms)}
}
```

### 2.4 ExprèŠ‚ç‚¹

```go
// Expr: è¡¨è¾¾å¼
type Expr struct {
    Location *Location  // æºç ä½ç½®
    Index    int        // åœ¨Bodyä¸­çš„ç´¢å¼•
    Terms    interface{} // *Term, []*Term, æˆ– Call
    With     []*With    // withè¯­å¥
    Negated  bool       // æ˜¯å¦è¢«å¦å®š
}

// NewExpr: åˆ›å»ºè¡¨è¾¾å¼
func NewExpr(terms interface{}) *Expr {
    return &Expr{Terms: terms}
}

// IsCall: æ˜¯å¦æ˜¯å‡½æ•°è°ƒç”¨
func (expr *Expr) IsCall() bool {
    _, ok := expr.Terms.(Call)
    return ok
}

// IsEquality: æ˜¯å¦æ˜¯ç­‰å¼ï¼ˆx = yï¼‰
func (expr *Expr) IsEquality() bool {
    terms, ok := expr.Terms.([]*Term)
    if !ok || len(terms) != 2 {
        return false
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å†…ç½®çš„ç­‰äºæ“ä½œ
    if ref, ok := terms[0].Value.(Ref); ok {
        return ref.IsBuiltin("eq") || ref.IsBuiltin("equal")
    }
    
    return false
}

// Operands: è¿”å›æ“ä½œæ•°
func (expr *Expr) Operands() []*Term {
    switch terms := expr.Terms.(type) {
    case *Term:
        return []*Term{terms}
    case []*Term:
        return terms
    case Call:
        result := make([]*Term, 0, len(terms)+1)
        result = append(result, NewTerm(Ref{VarTerm(terms[0].Name)}))
        result = append(result, terms...)
        return result
    }
    return nil
}

// String: å­—ç¬¦ä¸²è¡¨ç¤º
func (expr *Expr) String() string {
    var buf strings.Builder
    
    if expr.Negated {
        buf.WriteString("not ")
    }
    
    // Terms
    switch terms := expr.Terms.(type) {
    case *Term:
        buf.WriteString(terms.String())
    case []*Term:
        for i, term := range terms {
            if i > 0 {
                buf.WriteString(", ")
            }
            buf.WriteString(term.String())
        }
    case Call:
        buf.WriteString(terms[0].String())
        buf.WriteString("(")
        for i := 1; i < len(terms); i++ {
            if i > 1 {
                buf.WriteString(", ")
            }
            buf.WriteString(terms[i].String())
        }
        buf.WriteString(")")
    }
    
    // Withè¯­å¥
    for _, with := range expr.With {
        buf.WriteString(" with ")
        buf.WriteString(with.String())
    }
    
    return buf.String()
}
```

**Callç±»å‹**:

```go
// Call: å‡½æ•°è°ƒç”¨
type Call []*Term  // [å‡½æ•°å, å‚æ•°1, å‚æ•°2, ...]

// ç¤ºä¾‹: count(arr, n)
// Call{
//     RefTerm(VarTerm("count")),
//     VarTerm("arr"),
//     VarTerm("n"),
// }
```

**Withç±»å‹**:

```go
// With: withè¯­å¥
type With struct {
    Location *Location  // æºç ä½ç½®
    Target   *Term      // ç›®æ ‡å¼•ç”¨
    Value    *Term      // æ›¿æ¢å€¼
}

// ç¤ºä¾‹: data.config with input.user as "admin"
// With{
//     Target: RefTerm(VarTerm("input"), StringTerm("user")),
//     Value:  StringTerm("admin"),
// }

func (with *With) String() string {
    return fmt.Sprintf("%s as %s", with.Target, with.Value)
}
```

### 2.5 RuleèŠ‚ç‚¹

```go
// Rule: è§„åˆ™
type Rule struct {
    Location *Location  // æºç ä½ç½®
    Default  bool       // æ˜¯å¦æ˜¯defaultè§„åˆ™
    Head     *Head      // è§„åˆ™å¤´éƒ¨
    Body     Body       // è§„åˆ™ä½“
    Else     *Rule      // elseåˆ†æ”¯
    Module   *Module    // æ‰€å±æ¨¡å—
}

// Head: è§„åˆ™å¤´éƒ¨
type Head struct {
    Location  *Location  // æºç ä½ç½®
    Name      Var        // è§„åˆ™åç§°
    Args      Args       // å‡½æ•°å‚æ•°ï¼ˆå¯é€‰ï¼‰
    Key       *Term      // éƒ¨åˆ†è§„åˆ™çš„keyï¼ˆå¯é€‰ï¼‰
    Value     *Term      // è§„åˆ™å€¼ï¼ˆå¯é€‰ï¼‰
    Assign    bool       // æ˜¯å¦æ˜¯èµ‹å€¼ï¼ˆ:= vs =ï¼‰
    Reference Ref        // å®Œæ•´å¼•ç”¨è·¯å¾„
}

// Args: å‡½æ•°å‚æ•°
type Args []*Term

// Body: è§„åˆ™ä½“ï¼ˆè¡¨è¾¾å¼åˆ—è¡¨ï¼‰
type Body []*Expr

// NewBody: åˆ›å»ºBody
func NewBody(exprs ...*Expr) Body {
    return Body(exprs)
}

// Append: è¿½åŠ è¡¨è¾¾å¼
func (body Body) Append(expr *Expr) Body {
    result := make(Body, len(body)+1)
    copy(result, body)
    result[len(body)] = expr
    return result
}

// IsGround: æ˜¯å¦æ‰€æœ‰è¡¨è¾¾å¼éƒ½æ˜¯ground
func (body Body) IsGround() bool {
    for _, expr := range body {
        for _, term := range expr.Operands() {
            if !term.IsGround() {
                return false
            }
        }
    }
    return true
}

// Vars: æå–æ‰€æœ‰å˜é‡
func (body Body) Vars() VarSet {
    vars := NewVarSet()
    for _, expr := range body {
        for _, term := range expr.Operands() {
            collectVars(term, vars)
        }
    }
    return vars
}
```

**è§„åˆ™ç±»å‹åˆ¤æ–­**:

```go
// IsComplete: æ˜¯å¦æ˜¯å®Œå…¨è§„åˆ™
// å®Œå…¨è§„åˆ™: p = true if { ... }
func (rule *Rule) IsComplete() bool {
    return rule.Head.Key == nil && rule.Head.Value != nil
}

// IsPartial: æ˜¯å¦æ˜¯éƒ¨åˆ†è§„åˆ™
// éƒ¨åˆ†è§„åˆ™: p[k] = v if { ... }
func (rule *Rule) IsPartial() bool {
    return rule.Head.Key != nil
}

// IsFunction: æ˜¯å¦æ˜¯å‡½æ•°
// å‡½æ•°: f(x, y) = z if { ... }
func (rule *Rule) IsFunction() bool {
    return len(rule.Head.Args) > 0
}

// IsDefault: æ˜¯å¦æ˜¯defaultè§„åˆ™
// default p = false
func (rule *Rule) IsDefault() bool {
    return rule.Default
}
```

### 2.6 ModuleèŠ‚ç‚¹

```go
// Module: Regoæ¨¡å—
type Module struct {
    Location *Location  // æºç ä½ç½®
    Package  *Package   // packageå£°æ˜
    Imports  []*Import  // importè¯­å¥
    Rules    []*Rule    // è§„åˆ™åˆ—è¡¨
    Comments []*Comment // æ³¨é‡Š
}

// Package: packageå£°æ˜
type Package struct {
    Location *Location  // æºç ä½ç½®
    Path     Ref        // åŒ…è·¯å¾„
}

// Import: importè¯­å¥
type Import struct {
    Location *Location  // æºç ä½ç½®
    Path     *Term      // å¯¼å…¥è·¯å¾„
    Alias    Var        // åˆ«åï¼ˆå¯é€‰ï¼‰
}

// Comment: æ³¨é‡Š
type Comment struct {
    Location *Location  // æºç ä½ç½®
    Text     []byte     // æ³¨é‡Šå†…å®¹
}
```

---

## 3. ASTæ„å»º

### 3.1 æ„å»ºå™¨æ¨¡å¼

**ModuleBuilder**:

```go
// ModuleBuilder: æ¨¡å—æ„å»ºå™¨
type ModuleBuilder struct {
    module *Module
}

// NewModuleBuilder: åˆ›å»ºæ„å»ºå™¨
func NewModuleBuilder() *ModuleBuilder {
    return &ModuleBuilder{
        module: &Module{},
    }
}

// Package: è®¾ç½®package
func (b *ModuleBuilder) Package(path string) *ModuleBuilder {
    b.module.Package = &Package{
        Path: ParseRef(path),
    }
    return b
}

// Import: æ·»åŠ import
func (b *ModuleBuilder) Import(path string, alias string) *ModuleBuilder {
    imp := &Import{
        Path: StringTerm(path),
    }
    if alias != "" {
        imp.Alias = Var(alias)
    }
    b.module.Imports = append(b.module.Imports, imp)
    return b
}

// Rule: æ·»åŠ è§„åˆ™
func (b *ModuleBuilder) Rule(rule *Rule) *ModuleBuilder {
    b.module.Rules = append(b.module.Rules, rule)
    return b
}

// Build: æ„å»ºæ¨¡å—
func (b *ModuleBuilder) Build() *Module {
    return b.module
}

// ä½¿ç”¨ç¤ºä¾‹:
module := NewModuleBuilder().
    Package("example.authz").
    Import("data.users", "").
    Rule(allowRule).
    Build()
```

**RuleBuilder**:

```go
// RuleBuilder: è§„åˆ™æ„å»ºå™¨
type RuleBuilder struct {
    rule *Rule
}

// NewRuleBuilder: åˆ›å»ºæ„å»ºå™¨
func NewRuleBuilder(name string) *RuleBuilder {
    return &RuleBuilder{
        rule: &Rule{
            Head: &Head{
                Name: Var(name),
            },
            Body: NewBody(),
        },
    }
}

// Default: è®¾ç½®ä¸ºdefaultè§„åˆ™
func (b *RuleBuilder) Default() *RuleBuilder {
    b.rule.Default = true
    return b
}

// Value: è®¾ç½®è§„åˆ™å€¼
func (b *RuleBuilder) Value(term *Term) *RuleBuilder {
    b.rule.Head.Value = term
    return b
}

// Key: è®¾ç½®éƒ¨åˆ†è§„åˆ™çš„key
func (b *RuleBuilder) Key(term *Term) *RuleBuilder {
    b.rule.Head.Key = term
    return b
}

// Args: è®¾ç½®å‡½æ•°å‚æ•°
func (b *RuleBuilder) Args(args ...*Term) *RuleBuilder {
    b.rule.Head.Args = Args(args)
    return b
}

// Body: æ·»åŠ bodyè¡¨è¾¾å¼
func (b *RuleBuilder) Body(exprs ...*Expr) *RuleBuilder {
    b.rule.Body = append(b.rule.Body, exprs...)
    return b
}

// Else: æ·»åŠ elseåˆ†æ”¯
func (b *RuleBuilder) Else(rule *Rule) *RuleBuilder {
    b.rule.Else = rule
    return b
}

// Build: æ„å»ºè§„åˆ™
func (b *RuleBuilder) Build() *Rule {
    return b.rule
}

// ä½¿ç”¨ç¤ºä¾‹:
rule := NewRuleBuilder("allow").
    Value(BooleanTerm(true)).
    Body(
        Equality.Expr(
            RefTerm(VarTerm("input"), StringTerm("method")),
            StringTerm("GET"),
        ),
    ).
    Build()
```

### 3.2 è¾…åŠ©æ„é€ å‡½æ•°

**è¡¨è¾¾å¼æ„é€ **:

```go
// Equality: ç­‰å¼è¡¨è¾¾å¼
var Equality = &Builtin{
    Name: "eq",
}

func (b *Builtin) Expr(a, b *Term) *Expr {
    return &Expr{
        Terms: []*Term{
            RefTerm(VarTerm(b.Name)),
            a,
            b,
        },
    }
}

// ç¤ºä¾‹:
expr := Equality.Expr(
    VarTerm("x"),
    IntNumberTerm(10),
)
// ç­‰ä»·äº: x == 10

// æ¯”è¾ƒè¿ç®—ç¬¦
var (
    Equal          = &Builtin{Name: "eq"}
    NotEqual       = &Builtin{Name: "neq"}
    LessThan       = &Builtin{Name: "lt"}
    LessThanEq     = &Builtin{Name: "lte"}
    GreaterThan    = &Builtin{Name: "gt"}
    GreaterThanEq  = &Builtin{Name: "gte"}
)

// ç®—æœ¯è¿ç®—ç¬¦
var (
    Plus     = &Builtin{Name: "plus"}
    Minus    = &Builtin{Name: "minus"}
    Multiply = &Builtin{Name: "mul"}
    Divide   = &Builtin{Name: "div"}
)
```

**å¼•ç”¨æ„é€ **:

```go
// ParseRef: è§£æå¼•ç”¨å­—ç¬¦ä¸²
func ParseRef(s string) Ref {
    // "data.users[0].name" â†’ Ref{...}
    parts := strings.Split(s, ".")
    ref := make(Ref, 0, len(parts))
    
    for _, part := range parts {
        if strings.Contains(part, "[") {
            // å¤„ç†æ•°ç»„ç´¢å¼•
            // "users[0]" â†’ "users", "[0]"
            // ...
        } else {
            if len(ref) == 0 {
                ref = append(ref, VarTerm(part))
            } else {
                ref = append(ref, StringTerm(part))
            }
        }
    }
    
    return ref
}

// MustParseRef: è§£æå¼•ç”¨ï¼ˆpanic on errorï¼‰
func MustParseRef(s string) Ref {
    ref, err := ParseRefSafe(s)
    if err != nil {
        panic(err)
    }
    return ref
}
```

### 3.3 ä»é›¶æ„å»ºAST

**å®Œæ•´ç¤ºä¾‹**:

```go
// æ„å»ºä»¥ä¸‹Regoç­–ç•¥çš„AST:
// package example.authz
//
// import data.users
//
// default allow = false
//
// allow if {
//     input.method == "GET"
//     user := users[input.user_id]
//     user.role == "admin"
// }

func buildExampleAST() *Module {
    // 1. åˆ›å»ºæ¨¡å—
    module := &Module{
        Package: &Package{
            Path: MustParseRef("data.example.authz"),
        },
    }
    
    // 2. æ·»åŠ import
    module.Imports = []*Import{
        {
            Path: StringTerm("data.users"),
        },
    }
    
    // 3. åˆ›å»ºdefaultè§„åˆ™
    defaultRule := &Rule{
        Default: true,
        Head: &Head{
            Name:  Var("allow"),
            Value: BooleanTerm(false),
        },
        Body: NewBody(),
    }
    module.Rules = append(module.Rules, defaultRule)
    
    // 4. åˆ›å»ºallowè§„åˆ™
    allowRule := &Rule{
        Head: &Head{
            Name:  Var("allow"),
            Value: BooleanTerm(true),
        },
        Body: NewBody(
            // input.method == "GET"
            Equality.Expr(
                RefTerm(VarTerm("input"), StringTerm("method")),
                StringTerm("GET"),
            ),
            
            // user := users[input.user_id]
            Equality.Expr(
                VarTerm("user"),
                RefTerm(
                    VarTerm("users"),
                    RefTerm(VarTerm("input"), StringTerm("user_id")),
                ),
            ),
            
            // user.role == "admin"
            Equality.Expr(
                RefTerm(VarTerm("user"), StringTerm("role")),
                StringTerm("admin"),
            ),
        ),
    }
    module.Rules = append(module.Rules, allowRule)
    
    return module
}
```

### 3.4 ASTéªŒè¯

**éªŒè¯å™¨**:

```go
// Validator: ASTéªŒè¯å™¨
type Validator struct {
    errors Errors
}

// Validate: éªŒè¯æ¨¡å—
func (v *Validator) Validate(module *Module) error {
    // 1. éªŒè¯package
    if module.Package == nil {
        v.error("missing package declaration")
    }
    
    // 2. éªŒè¯imports
    for _, imp := range module.Imports {
        v.validateImport(imp)
    }
    
    // 3. éªŒè¯è§„åˆ™
    for _, rule := range module.Rules {
        v.validateRule(rule)
    }
    
    if len(v.errors) > 0 {
        return v.errors
    }
    return nil
}

// validateRule: éªŒè¯è§„åˆ™
func (v *Validator) validateRule(rule *Rule) {
    // æ£€æŸ¥è§„åˆ™å¤´éƒ¨
    if rule.Head == nil {
        v.error("missing rule head")
        return
    }
    
    // æ£€æŸ¥è§„åˆ™åç§°
    if rule.Head.Name == "" {
        v.error("missing rule name")
    }
    
    // æ£€æŸ¥è§„åˆ™ä½“
    for _, expr := range rule.Body {
        v.validateExpr(expr)
    }
    
    // æ£€æŸ¥elseåˆ†æ”¯
    if rule.Else != nil {
        v.validateRule(rule.Else)
    }
}

// validateExpr: éªŒè¯è¡¨è¾¾å¼
func (v *Validator) validateExpr(expr *Expr) {
    // æ£€æŸ¥terms
    for _, term := range expr.Operands() {
        v.validateTerm(term)
    }
    
    // æ£€æŸ¥withè¯­å¥
    for _, with := range expr.With {
        v.validateWith(with)
    }
}
```

---

## 4. ASTéå†

### 4.1 Visitoræ¥å£

```go
// Visitor: ASTè®¿é—®è€…æ¥å£
type Visitor interface {
    // Visit: è®¿é—®èŠ‚ç‚¹
    // è¿”å›å€¼: ç»§ç»­éå†çš„Visitorï¼ˆå¯ä»¥æ˜¯è‡ªå·±æˆ–nilï¼‰
    Visit(node interface{}) (w Visitor)
}

// GenericVisitor: é€šç”¨è®¿é—®è€…
type GenericVisitor struct {
    before func(interface{}) bool
    after  func(interface{})
}

// NewGenericVisitor: åˆ›å»ºé€šç”¨è®¿é—®è€…
func NewGenericVisitor(before func(interface{}) bool) *GenericVisitor {
    return &GenericVisitor{before: before}
}

// Visit: å®ç°Visitoræ¥å£
func (v *GenericVisitor) Visit(node interface{}) Visitor {
    if v.before != nil {
        if !v.before(node) {
            return nil  // åœæ­¢éå†
        }
    }
    return v
}

// After: è®¾ç½®åç»­å¤„ç†å‡½æ•°
func (v *GenericVisitor) After(f func(interface{})) *GenericVisitor {
    v.after = f
    return v
}
```

### 4.2 Walkå‡½æ•°

```go
// Walk: éå†AST
func Walk(v Visitor, node interface{}) {
    if v = v.Visit(node); v == nil {
        return
    }
    
    switch n := node.(type) {
    case *Module:
        Walk(v, n.Package)
        for _, imp := range n.Imports {
            Walk(v, imp)
        }
        for _, rule := range n.Rules {
            Walk(v, rule)
        }
        
    case *Rule:
        Walk(v, n.Head)
        Walk(v, n.Body)
        if n.Else != nil {
            Walk(v, n.Else)
        }
        
    case *Head:
        for _, arg := range n.Args {
            Walk(v, arg)
        }
        if n.Key != nil {
            Walk(v, n.Key)
        }
        if n.Value != nil {
            Walk(v, n.Value)
        }
        
    case Body:
        for _, expr := range n {
            Walk(v, expr)
        }
        
    case *Expr:
        for _, term := range n.Operands() {
            Walk(v, term)
        }
        for _, with := range n.With {
            Walk(v, with)
        }
        
    case *Term:
        walkValue(v, n.Value)
        
    case *With:
        Walk(v, n.Target)
        Walk(v, n.Value)
    }
}

// walkValue: éå†Value
func walkValue(v Visitor, value Value) {
    switch val := value.(type) {
    case Ref:
        for _, term := range val {
            Walk(v, term)
        }
        
    case Array:
        for _, term := range val {
            Walk(v, term)
        }
        
    case Object:
        for _, pair := range val {
            Walk(v, pair[0])
            Walk(v, pair[1])
        }
        
    case Set:
        for _, term := range val {
            Walk(v, term)
        }
        
    case *ArrayComprehension:
        Walk(v, val.Term)
        Walk(v, val.Body)
        
    case *ObjectComprehension:
        Walk(v, val.Key)
        Walk(v, val.Value)
        Walk(v, val.Body)
        
    case *SetComprehension:
        Walk(v, val.Term)
        Walk(v, val.Body)
    }
}
```

### 4.3 éå†ç­–ç•¥

**å‰åºéå†**:

```go
// WalkBeforeAfter: å‰åéå†
func WalkBeforeAfter(node interface{},
    before func(interface{}) bool,
    after func(interface{})) {
    
    vis := &beforeAfterVisitor{
        before: before,
        after:  after,
    }
    Walk(vis, node)
}

type beforeAfterVisitor struct {
    before func(interface{}) bool
    after  func(interface{})
}

func (v *beforeAfterVisitor) Visit(node interface{}) Visitor {
    if v.before != nil && !v.before(node) {
        return nil
    }
    return v
}
```

**æ·±åº¦ä¼˜å…ˆéå†**:

```go
// WalkDepthFirst: æ·±åº¦ä¼˜å…ˆéå†
func WalkDepthFirst(node interface{}, f func(interface{})) {
    Walk(NewGenericVisitor(func(n interface{}) bool {
        f(n)
        return true
    }), node)
}
```

### 4.4 å®ç”¨éå†å™¨

**å˜é‡æ”¶é›†å™¨**:

```go
// VarCollector: å˜é‡æ”¶é›†å™¨
type VarCollector struct {
    vars VarSet
}

func NewVarCollector() *VarCollector {
    return &VarCollector{
        vars: NewVarSet(),
    }
}

func (c *VarCollector) Visit(node interface{}) Visitor {
    if term, ok := node.(*Term); ok {
        if v, ok := term.Value.(Var); ok {
            c.vars.Add(v)
        }
    }
    return c
}

func (c *VarCollector) Vars() VarSet {
    return c.vars
}

// ä½¿ç”¨:
collector := NewVarCollector()
Walk(collector, rule)
vars := collector.Vars()
```

**å¼•ç”¨æ”¶é›†å™¨**:

```go
// RefCollector: å¼•ç”¨æ”¶é›†å™¨
type RefCollector struct {
    refs []Ref
}

func NewRefCollector() *RefCollector {
    return &RefCollector{
        refs: []Ref{},
    }
}

func (c *RefCollector) Visit(node interface{}) Visitor {
    if term, ok := node.(*Term); ok {
        if ref, ok := term.Value.(Ref); ok {
            c.refs = append(c.refs, ref)
        }
    }
    return c
}

func (c *RefCollector) Refs() []Ref {
    return c.refs
}
```

---

## 5. ASTè½¬æ¢

### 5.1 Transformæ¥å£

```go
// Transformer: ASTè½¬æ¢å™¨æ¥å£
type Transformer interface {
    // Transform: è½¬æ¢èŠ‚ç‚¹
    // è¿”å›: è½¬æ¢åçš„èŠ‚ç‚¹ï¼Œæˆ–nilï¼ˆä¸å˜ï¼‰
    Transform(node interface{}) (interface{}, error)
}

// TransformFunc: è½¬æ¢å‡½æ•°ç±»å‹
type TransformFunc func(interface{}) (interface{}, error)

func (f TransformFunc) Transform(node interface{}) (interface{}, error) {
    return f(node)
}
```

### 5.2 é€šç”¨è½¬æ¢å‡½æ•°

```go
// Transform: è½¬æ¢AST
func Transform(transformer Transformer, node interface{}) (interface{}, error) {
    // å…ˆè½¬æ¢å­èŠ‚ç‚¹
    node, err := transformChildren(transformer, node)
    if err != nil {
        return nil, err
    }
    
    // å†è½¬æ¢å½“å‰èŠ‚ç‚¹
    return transformer.Transform(node)
}

// transformChildren: è½¬æ¢å­èŠ‚ç‚¹
func transformChildren(t Transformer, node interface{}) (interface{}, error) {
    switch n := node.(type) {
    case *Module:
        module := *n  // æ‹·è´
        
        // è½¬æ¢package
        pkg, err := Transform(t, n.Package)
        if err != nil {
            return nil, err
        }
        module.Package = pkg.(*Package)
        
        // è½¬æ¢imports
        for i, imp := range n.Imports {
            newImp, err := Transform(t, imp)
            if err != nil {
                return nil, err
            }
            module.Imports[i] = newImp.(*Import)
        }
        
        // è½¬æ¢rules
        for i, rule := range n.Rules {
            newRule, err := Transform(t, rule)
            if err != nil {
                return nil, err
            }
            module.Rules[i] = newRule.(*Rule)
        }
        
        return &module, nil
        
    case *Rule:
        rule := *n  // æ‹·è´
        
        // è½¬æ¢head
        head, err := Transform(t, n.Head)
        if err != nil {
            return nil, err
        }
        rule.Head = head.(*Head)
        
        // è½¬æ¢body
        body, err := Transform(t, n.Body)
        if err != nil {
            return nil, err
        }
        rule.Body = body.(Body)
        
        // è½¬æ¢else
        if n.Else != nil {
            elseRule, err := Transform(t, n.Else)
            if err != nil {
                return nil, err
            }
            rule.Else = elseRule.(*Rule)
        }
        
        return &rule, nil
        
    case Body:
        body := make(Body, len(n))
        for i, expr := range n {
            newExpr, err := Transform(t, expr)
            if err != nil {
                return nil, err
            }
            body[i] = newExpr.(*Expr)
        }
        return body, nil
        
    case *Expr:
        expr := *n  // æ‹·è´
        
        // è½¬æ¢terms
        newTerms, err := transformTerms(t, n.Terms)
        if err != nil {
            return nil, err
        }
        expr.Terms = newTerms
        
        // è½¬æ¢with
        for i, with := range n.With {
            newWith, err := Transform(t, with)
            if err != nil {
                return nil, err
            }
            expr.With[i] = newWith.(*With)
        }
        
        return &expr, nil
        
    case *Term:
        // è½¬æ¢value
        value, err := transformValue(t, n.Value)
        if err != nil {
            return nil, err
        }
        
        if value != n.Value {
            term := *n
            term.Value = value
            return &term, nil
        }
        
        return n, nil
    }
    
    return node, nil
}

// transformValue: è½¬æ¢Value
func transformValue(t Transformer, value Value) (Value, error) {
    switch val := value.(type) {
    case Ref:
        ref := make(Ref, len(val))
        changed := false
        
        for i, term := range val {
            newTerm, err := Transform(t, term)
            if err != nil {
                return nil, err
            }
            ref[i] = newTerm.(*Term)
            if ref[i] != term {
                changed = true
            }
        }
        
        if changed {
            return ref, nil
        }
        
    case Array:
        arr := make(Array, len(val))
        changed := false
        
        for i, term := range val {
            newTerm, err := Transform(t, term)
            if err != nil {
                return nil, err
            }
            arr[i] = newTerm.(*Term)
            if arr[i] != term {
                changed = true
            }
        }
        
        if changed {
            return arr, nil
        }
        
    // ... å…¶ä»–ç±»å‹ ...
    }
    
    return value, nil
}
```

### 5.3 è½¬æ¢å™¨ç»„åˆ

```go
// ComposeTransformers: ç»„åˆå¤šä¸ªè½¬æ¢å™¨
func ComposeTransformers(transformers ...Transformer) Transformer {
    return TransformFunc(func(node interface{}) (interface{}, error) {
        var err error
        for _, t := range transformers {
            node, err = t.Transform(node)
            if err != nil {
                return nil, err
            }
        }
        return node, nil
    })
}

// ä½¿ç”¨:
transformer := ComposeTransformers(
    rewriteLocalVars,
    expandComprehensions,
    rewriteDynamicTerms,
)

newModule, err := Transform(transformer, module)
```

### 5.4 å¸¸ç”¨è½¬æ¢

**å˜é‡é‡å‘½å**:

```go
// RenameVars: å˜é‡é‡å‘½åè½¬æ¢å™¨
type RenameVars struct {
    mapping map[Var]Var
}

func NewRenameVars(mapping map[Var]Var) *RenameVars {
    return &RenameVars{mapping: mapping}
}

func (r *RenameVars) Transform(node interface{}) (interface{}, error) {
    if term, ok := node.(*Term); ok {
        if v, ok := term.Value.(Var); ok {
            if newVar, found := r.mapping[v]; found {
                newTerm := *term
                newTerm.Value = newVar
                return &newTerm, nil
            }
        }
    }
    return node, nil
}

// ä½¿ç”¨:
renamer := NewRenameVars(map[Var]Var{
    Var("x"): Var("$x_0"),
    Var("y"): Var("$y_0"),
})

newRule, _ := Transform(renamer, rule)
```

**å¸¸é‡æŠ˜å **:

```go
// ConstantFolding: å¸¸é‡æŠ˜å è½¬æ¢å™¨
type ConstantFolding struct{}

func (c *ConstantFolding) Transform(node interface{}) (interface{}, error) {
    expr, ok := node.(*Expr)
    if !ok {
        return node, nil
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç®—æœ¯è¡¨è¾¾å¼
    if !expr.IsCall() {
        return node, nil
    }
    
    terms := expr.Operands()
    if len(terms) != 3 {
        return node, nil
    }
    
    // æå–è¿ç®—ç¬¦å’Œæ“ä½œæ•°
    op := terms[0]
    left := terms[1]
    right := terms[2]
    
    // æ£€æŸ¥æ“ä½œæ•°æ˜¯å¦éƒ½æ˜¯å¸¸é‡
    if !left.IsGround() || !right.IsGround() {
        return node, nil
    }
    
    // æ‰§è¡Œå¸¸é‡è®¡ç®—
    switch op.String() {
    case "plus":
        l, _ := left.Value.(Number).Int64()
        r, _ := right.Value.(Number).Int64()
        return IntNumberTerm(l + r), nil
        
    case "minus":
        l, _ := left.Value.(Number).Int64()
        r, _ := right.Value.(Number).Int64()
        return IntNumberTerm(l - r), nil
        
    // ... å…¶ä»–è¿ç®—ç¬¦ ...
    }
    
    return node, nil
}

// ä½¿ç”¨:
// è¾“å…¥: 3 + 5
// è¾“å‡º: 8
folder := &ConstantFolding{}
newExpr, _ := Transform(folder, expr)
```

---

## 6. é‡è¦ASTæ“ä½œ

### 6.1 å˜é‡æå–

```go
// Vars: æå–æ‰€æœ‰å˜é‡
func Vars(node interface{}) VarSet {
    vis := NewVarCollector()
    Walk(vis, node)
    return vis.Vars()
}

// OutputVars: æå–è¾“å‡ºå˜é‡ï¼ˆèµ‹å€¼å·¦ä¾§ï¼‰
func OutputVars(body Body) VarSet {
    outputs := NewVarSet()
    
    for _, expr := range body {
        if expr.IsEquality() {
            terms := expr.Operands()
            left := terms[1]
            
            // å¦‚æœå·¦ä¾§æ˜¯å˜é‡ï¼Œå®ƒæ˜¯è¾“å‡ºå˜é‡
            if v, ok := left.Value.(Var); ok {
                outputs.Add(v)
            }
        }
    }
    
    return outputs
}

// UnsafeVars: æå–ä¸å®‰å…¨å˜é‡
func UnsafeVars(body Body) VarSet {
    all := Vars(body)
    safe := SafeVars(body)
    return all.Diff(safe)
}

// SafeVars: æå–å®‰å…¨å˜é‡
func SafeVars(body Body) VarSet {
    safe := NewVarSet()
    
    for _, expr := range body {
        // ç­‰å¼å·¦ä¾§çš„å˜é‡æ˜¯å®‰å…¨çš„
        if expr.IsEquality() {
            terms := expr.Operands()
            collectVars(terms[1], safe)
        }
        
        // ground termä¸­çš„å˜é‡æ˜¯å®‰å…¨çš„
        for _, term := range expr.Operands() {
            if term.IsGround() {
                collectVars(term, safe)
            }
        }
    }
    
    return safe
}
```

### 6.2 å¼•ç”¨é‡å†™

```go
// RewriteRefs: é‡å†™å¼•ç”¨
type RewriteRefs struct {
    rewrite func(Ref) (Ref, error)
}

func (r *RewriteRefs) Transform(node interface{}) (interface{}, error) {
    if term, ok := node.(*Term); ok {
        if ref, ok := term.Value.(Ref); ok {
            newRef, err := r.rewrite(ref)
            if err != nil {
                return nil, err
            }
            
            if !newRef.Equal(ref) {
                newTerm := *term
                newTerm.Value = newRef
                return &newTerm, nil
            }
        }
    }
    return node, nil
}

// ç¤ºä¾‹: å°† data.* å‰ç¼€æ”¹ä¸º input.*
rewriter := &RewriteRefs{
    rewrite: func(ref Ref) (Ref, error) {
        if len(ref) > 0 {
            if v, ok := ref[0].Value.(Var); ok && v == Var("data") {
                newRef := make(Ref, len(ref))
                newRef[0] = VarTerm("input")
                copy(newRef[1:], ref[1:])
                return newRef, nil
            }
        }
        return ref, nil
    },
}
```

### 6.3 è¡¨è¾¾å¼ç®€åŒ–

```go
// SimplifyExprs: ç®€åŒ–è¡¨è¾¾å¼
func SimplifyExprs(body Body) Body {
    result := make(Body, 0, len(body))
    
    for _, expr := range body {
        // ç§»é™¤æ’çœŸè¡¨è¾¾å¼: true
        if isTautology(expr) {
            continue
        }
        
        // æ£€æµ‹çŸ›ç›¾: false
        if isContradiction(expr) {
            // æ•´ä¸ªbodyä¸ºfalse
            return Body{}
        }
        
        result = append(result, expr)
    }
    
    return result
}

// isTautology: æ˜¯å¦æ˜¯æ’çœŸè¡¨è¾¾å¼
func isTautology(expr *Expr) bool {
    // true
    if term, ok := expr.Terms.(*Term); ok {
        if b, ok := term.Value.(Boolean); ok && b {
            return true
        }
    }
    
    // x == x
    if expr.IsEquality() {
        terms := expr.Operands()
        if terms[1].Equal(terms[2]) {
            return true
        }
    }
    
    return false
}

// isContradiction: æ˜¯å¦æ˜¯çŸ›ç›¾
func isContradiction(expr *Expr) bool {
    // false
    if term, ok := expr.Terms.(*Term); ok {
        if b, ok := term.Value.(Boolean); ok && !b {
            return true
        }
    }
    
    // x != x
    if isNotEqual(expr) {
        terms := expr.Operands()
        if terms[1].Equal(terms[2]) {
            return true
        }
    }
    
    return false
}
```

### 6.4 å®‰å…¨æ€§æ£€æŸ¥

```go
// CheckSafety: å®‰å…¨æ€§æ£€æŸ¥
func CheckSafety(module *Module) Errors {
    var errors Errors
    
    for _, rule := range module.Rules {
        // æ£€æŸ¥è§„åˆ™ä½“çš„å®‰å…¨æ€§
        unsafe := UnsafeVars(rule.Body)
        
        if unsafe.Len() > 0 {
            errors = append(errors, &Error{
                Code:     UnsafeVarErr,
                Message:  fmt.Sprintf("unsafe variables: %v", unsafe),
                Location: rule.Location,
            })
        }
        
        // æ£€æŸ¥è§„åˆ™å¤´éƒ¨çš„å®‰å…¨æ€§
        headVars := Vars(rule.Head.Value)
        bodyVars := SafeVars(rule.Body)
        
        unsafeHead := headVars.Diff(bodyVars)
        if unsafeHead.Len() > 0 {
            errors = append(errors, &Error{
                Code:     UnsafeVarErr,
                Message:  fmt.Sprintf("unsafe variables in head: %v", unsafeHead),
                Location: rule.Head.Location,
            })
        }
    }
    
    return errors
}
```

---

## 7. ç¼–è¯‘å™¨ä½¿ç”¨çš„è½¬æ¢

### 7.1 å±€éƒ¨å˜é‡é‡å†™

```go
// RewriteLocalVars: é‡å†™å±€éƒ¨å˜é‡
// ä¸ºæ¯ä¸ªè§„åˆ™çš„å±€éƒ¨å˜é‡æ·»åŠ å”¯ä¸€å‰ç¼€
type RewriteLocalVars struct {
    ruleIndex int
}

func (r *RewriteLocalVars) Transform(node interface{}) (interface{}, error) {
    rule, ok := node.(*Rule)
    if !ok {
        return node, nil
    }
    
    r.ruleIndex++
    
    // æ”¶é›†å±€éƒ¨å˜é‡ï¼ˆä¸åŒ…æ‹¬è¾“å…¥å˜é‡ï¼‰
    locals := r.collectLocalVars(rule)
    
    // åˆ›å»ºé‡å‘½åæ˜ å°„
    mapping := make(map[Var]Var)
    for v := range locals {
        mapping[v] = Var(fmt.Sprintf("__%s_%d", v, r.ruleIndex))
    }
    
    // åº”ç”¨é‡å‘½å
    renamer := NewRenameVars(mapping)
    return Transform(renamer, rule)
}

func (r *RewriteLocalVars) collectLocalVars(rule *Rule) VarSet {
    all := Vars(rule.Body)
    
    // ç§»é™¤å…¨å±€å˜é‡ï¼ˆinput, dataç­‰ï¼‰
    globals := NewVarSet()
    globals.Add(Var("input"))
    globals.Add(Var("data"))
    
    return all.Diff(globals)
}

// ç¤ºä¾‹:
// è¾“å…¥:  allow if { x = 1; y = x + 1 }
// è¾“å‡º:  allow if { __x_1 = 1; __y_1 = __x_1 + 1 }
```

### 7.2 æ¨å¯¼å¼å±•å¼€

```go
// ExpandComprehensions: å±•å¼€æ¨å¯¼å¼
// å°†æ¨å¯¼å¼è½¬æ¢ä¸ºè§„åˆ™
type ExpandComprehensions struct {
    ruleCounter int
}

func (e *ExpandComprehensions) Transform(node interface{}) (interface{}, error) {
    term, ok := node.(*Term)
    if !ok {
        return node, nil
    }
    
    switch comp := term.Value.(type) {
    case *ArrayComprehension:
        return e.expandArrayComp(comp)
    case *SetComprehension:
        return e.expandSetComp(comp)
    case *ObjectComprehension:
        return e.expandObjectComp(comp)
    }
    
    return node, nil
}

func (e *ExpandComprehensions) expandArrayComp(comp *ArrayComprehension) (*Term, error) {
    // [x | x = arr[_]; x > 5]
    // è½¬æ¢ä¸º:
    // __result := [x | __internal_rule]
    // __internal_rule[x] { x = arr[_]; x > 5 }
    
    e.ruleCounter++
    ruleName := Var(fmt.Sprintf("__comp_%d", e.ruleCounter))
    
    // åˆ›å»ºå†…éƒ¨è§„åˆ™
    rule := &Rule{
        Head: &Head{
            Name:  ruleName,
            Key:   comp.Term,  // x
        },
        Body: comp.Body,  // x = arr[_]; x > 5
    }
    
    // è¿”å›å¯¹è§„åˆ™çš„å¼•ç”¨
    return RefTerm(VarTerm(ruleName)), nil
}

// ç¤ºä¾‹:
// è¾“å…¥:  result := [x | x = arr[_]; x > 5]
// è¾“å‡º:  result := __comp_1
//        __comp_1[x] { x = arr[_]; x > 5 }
```

### 7.3 åŠ¨æ€é¡¹é‡å†™

```go
// RewriteDynamicTerms: é‡å†™åŠ¨æ€é¡¹
// å°†åŠ¨æ€è®¡ç®—çš„é¡¹æå–ä¸ºå˜é‡
type RewriteDynamicTerms struct {
    varCounter int
}

func (r *RewriteDynamicTerms) Transform(node interface{}) (interface{}, error) {
    expr, ok := node.(*Expr)
    if !ok {
        return node, nil
    }
    
    var newExprs []*Expr
    
    for _, term := range expr.Operands() {
        if r.isDynamic(term) {
            // åˆ›å»ºæ–°å˜é‡
            r.varCounter++
            newVar := Var(fmt.Sprintf("__dyn_%d", r.varCounter))
            
            // åˆ›å»ºèµ‹å€¼è¡¨è¾¾å¼
            assign := Equality.Expr(VarTerm(newVar.String()), term)
            newExprs = append(newExprs, assign)
            
            // æ›¿æ¢åŸé¡¹ä¸ºå˜é‡
            // ... (å®ç°ç•¥)
        }
    }
    
    // ... è¿”å›é‡å†™åçš„è¡¨è¾¾å¼
    return expr, nil
}

func (r *RewriteDynamicTerms) isDynamic(term *Term) bool {
    // æ£€æŸ¥termæ˜¯å¦åŒ…å«å‡½æ•°è°ƒç”¨æˆ–æ¨å¯¼å¼
    switch term.Value.(type) {
    case Call, *ArrayComprehension, *SetComprehension, *ObjectComprehension:
        return true
    }
    return false
}

// ç¤ºä¾‹:
// è¾“å…¥:  allow if { input.role == upper(data.required_role) }
// è¾“å‡º:  allow if {
//            __dyn_1 = upper(data.required_role)
//            input.role == __dyn_1
//        }
```

### 7.4 Withè¯­å¥è½¬æ¢

```go
// RewriteWithStatements: è½¬æ¢withè¯­å¥
// å°†withè¯­å¥è½¬æ¢ä¸ºä¸´æ—¶èµ‹å€¼
type RewriteWithStatements struct{}

func (r *RewriteWithStatements) Transform(node interface{}) (interface{}, error) {
    expr, ok := node.(*Expr)
    if !ok || len(expr.With) == 0 {
        return node, nil
    }
    
    // data.config with input.user as "admin"
    // è½¬æ¢ä¸º:
    // __with_input_user = input.user   # ä¿å­˜åŸå€¼
    // input.user = "admin"             # æ›¿æ¢
    // data.config                      # æ‰§è¡Œè¡¨è¾¾å¼
    // input.user = __with_input_user   # æ¢å¤åŸå€¼
    
    var setup []*Expr
    var teardown []*Expr
    
    for i, with := range expr.With {
        // ç”Ÿæˆä¸´æ—¶å˜é‡
        tmpVar := Var(fmt.Sprintf("__with_%d", i))
        
        // ä¿å­˜åŸå€¼
        setup = append(setup, Equality.Expr(
            VarTerm(tmpVar.String()),
            with.Target,
        ))
        
        // æ›¿æ¢å€¼
        setup = append(setup, Equality.Expr(
            with.Target,
            with.Value,
        ))
        
        // æ¢å¤åŸå€¼
        teardown = append(teardown, Equality.Expr(
            with.Target,
            VarTerm(tmpVar.String()),
        ))
    }
    
    // æ„å»ºæ–°çš„è¡¨è¾¾å¼åºåˆ—
    // ... (å®ç°ç•¥)
    
    return expr, nil
}
```

---

## 8. ASTæ¯”è¾ƒä¸ç»Ÿä¸€

### 8.1 ç»“æ„æ¯”è¾ƒ

```go
// Equal: ç»“æ„ç›¸ç­‰æ€§æ¯”è¾ƒ
func (a *Term) Equal(b *Term) bool {
    return a.Value.Compare(b.Value) == 0
}

// Compare: æ¯”è¾ƒä¸¤ä¸ªValue
func CompareValues(a, b Value) int {
    // 1. ç±»å‹ä¼˜å…ˆçº§: Null < Boolean < Number < String < Var < Ref < ...
    typeOrder := map[string]int{
        "Null":    0,
        "Boolean": 1,
        "Number":  2,
        "String":  3,
        "Var":     4,
        "Ref":     5,
        "Array":   6,
        "Object":  7,
        "Set":     8,
    }
    
    aType := reflect.TypeOf(a).Name()
    bType := reflect.TypeOf(b).Name()
    
    if typeOrder[aType] < typeOrder[bType] {
        return -1
    } else if typeOrder[aType] > typeOrder[bType] {
        return 1
    }
    
    // 2. ç›¸åŒç±»å‹ï¼Œè°ƒç”¨Compareæ–¹æ³•
    return a.Compare(b)
}

// DeepEqual: æ·±åº¦ç›¸ç­‰æ€§æ¯”è¾ƒ
func DeepEqual(a, b interface{}) bool {
    switch x := a.(type) {
    case *Module:
        y, ok := b.(*Module)
        if !ok {
            return false
        }
        return deepEqualModule(x, y)
        
    case *Rule:
        y, ok := b.(*Rule)
        if !ok {
            return false
        }
        return deepEqualRule(x, y)
        
    // ... å…¶ä»–ç±»å‹ ...
    }
    
    return false
}
```

### 8.2 ç»Ÿä¸€ç®—æ³•

```go
// Unify: ç»Ÿä¸€ä¸¤ä¸ªterm
// è¿”å›: ç»Ÿä¸€åçš„æ›¿æ¢ï¼ˆsubstitutionï¼‰
func Unify(a, b *Term) (*Subst, error) {
    subst := NewSubst()
    if err := unifyTerms(a, b, subst); err != nil {
        return nil, err
    }
    return subst, nil
}

// unifyTerms: ç»Ÿä¸€ç®—æ³•æ ¸å¿ƒ
func unifyTerms(a, b *Term, subst *Subst) error {
    // åº”ç”¨å½“å‰æ›¿æ¢
    a = subst.Apply(a)
    b = subst.Apply(b)
    
    // å¦‚æœç›¸ç­‰ï¼Œç»Ÿä¸€æˆåŠŸ
    if a.Equal(b) {
        return nil
    }
    
    // å¦‚æœaæ˜¯å˜é‡ï¼Œç»‘å®šåˆ°b
    if v, ok := a.Value.(Var); ok {
        return subst.Bind(v, b)
    }
    
    // å¦‚æœbæ˜¯å˜é‡ï¼Œç»‘å®šåˆ°a
    if v, ok := b.Value.(Var); ok {
        return subst.Bind(v, a)
    }
    
    // é€’å½’ç»Ÿä¸€å¤åˆç±»å‹
    switch aVal := a.Value.(type) {
    case Ref:
        bVal, ok := b.Value.(Ref)
        if !ok || len(aVal) != len(bVal) {
            return fmt.Errorf("cannot unify %v and %v", a, b)
        }
        
        for i := range aVal {
            if err := unifyTerms(aVal[i], bVal[i], subst); err != nil {
                return err
            }
        }
        return nil
        
    case Array:
        bVal, ok := b.Value.(Array)
        if !ok || len(aVal) != len(bVal) {
            return fmt.Errorf("cannot unify %v and %v", a, b)
        }
        
        for i := range aVal {
            if err := unifyTerms(aVal[i], bVal[i], subst); err != nil {
                return err
            }
        }
        return nil
        
    // ... å…¶ä»–ç±»å‹ ...
    }
    
    return fmt.Errorf("cannot unify %v and %v", a, b)
}

// ç¤ºä¾‹:
// Unify(Var("x"), IntNumberTerm(5))
// ç»“æœ: {x â†’ 5}

// Unify(Array{Var("x"), Var("y")}, Array{IntNumberTerm(1), IntNumberTerm(2)})
// ç»“æœ: {x â†’ 1, y â†’ 2}
```

### 8.3 æ›¿æ¢ï¼ˆSubstitutionï¼‰

```go
// Subst: æ›¿æ¢ï¼ˆå˜é‡ç»‘å®šï¼‰
type Subst struct {
    bindings map[Var]*Term
}

func NewSubst() *Subst {
    return &Subst{
        bindings: make(map[Var]*Term),
    }
}

// Bind: ç»‘å®šå˜é‡
func (s *Subst) Bind(v Var, term *Term) error {
    // æ£€æŸ¥å¾ªç¯ç»‘å®š
    if occursCheck(v, term) {
        return fmt.Errorf("occurs check failed: %v in %v", v, term)
    }
    
    s.bindings[v] = term
    return nil
}

// Apply: åº”ç”¨æ›¿æ¢
func (s *Subst) Apply(term *Term) *Term {
    switch val := term.Value.(type) {
    case Var:
        if bound, ok := s.bindings[val]; ok {
            // é€’å½’åº”ç”¨ï¼ˆå¤„ç†ä¼ é€’ç»‘å®šï¼‰
            return s.Apply(bound)
        }
        return term
        
    case Ref:
        ref := make(Ref, len(val))
        for i, t := range val {
            ref[i] = s.Apply(t)
        }
        return &Term{Value: ref}
        
    case Array:
        arr := make(Array, len(val))
        for i, t := range val {
            arr[i] = s.Apply(t)
        }
        return &Term{Value: arr}
        
    // ... å…¶ä»–ç±»å‹ ...
    }
    
    return term
}

// occursCheck: å¾ªç¯æ£€æŸ¥
// æ£€æŸ¥å˜é‡væ˜¯å¦å‡ºç°åœ¨termä¸­
func occursCheck(v Var, term *Term) bool {
    if varTerm, ok := term.Value.(Var); ok {
        return v == varTerm
    }
    
    vars := Vars(term)
    return vars.Contains(v)
}
```

---

## 9. æ€§èƒ½ä¼˜åŒ–

### 9.1 å†…å­˜æ± 

```go
// TermPool: Termå¯¹è±¡æ± 
var termPool = sync.Pool{
    New: func() interface{} {
        return &Term{}
    },
}

// GetTerm: ä»æ± ä¸­è·å–Term
func GetTerm() *Term {
    return termPool.Get().(*Term)
}

// PutTerm: å½’è¿˜Termåˆ°æ± 
func PutTerm(term *Term) {
    term.Value = nil
    term.Location = nil
    termPool.Put(term)
}

// ä½¿ç”¨:
term := GetTerm()
term.Value = String("hello")
// ... ä½¿ç”¨term ...
PutTerm(term)
```

### 9.2 ç¼“å­˜æœºåˆ¶

```go
// ASTCache: ASTç¼“å­˜
type ASTCache struct {
    mu    sync.RWMutex
    cache map[string]*Module
}

func NewASTCache() *ASTCache {
    return &ASTCache{
        cache: make(map[string]*Module),
    }
}

// Get: è·å–ç¼“å­˜çš„æ¨¡å—
func (c *ASTCache) Get(key string) (*Module, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    module, ok := c.cache[key]
    return module, ok
}

// Put: ç¼“å­˜æ¨¡å—
func (c *ASTCache) Put(key string, module *Module) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.cache[key] = module
}

// ä½¿ç”¨:
cache := NewASTCache()

// è§£ææ—¶æ£€æŸ¥ç¼“å­˜
if module, ok := cache.Get(filename); ok {
    return module
}

// è§£æå¹¶ç¼“å­˜
module, _ := ParseModule(filename, source)
cache.Put(filename, module)
```

### 9.3 å»¶è¿Ÿè®¡ç®—

```go
// LazyValue: å»¶è¿Ÿè®¡ç®—çš„Value
type LazyValue struct {
    compute func() Value
    value   Value
    once    sync.Once
}

func NewLazyValue(compute func() Value) *LazyValue {
    return &LazyValue{compute: compute}
}

// Get: è·å–å€¼ï¼ˆç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶è®¡ç®—ï¼‰
func (lv *LazyValue) Get() Value {
    lv.once.Do(func() {
        lv.value = lv.compute()
    })
    return lv.value
}

// ä½¿ç”¨:
lazy := NewLazyValue(func() Value {
    // æ˜‚è´µçš„è®¡ç®—
    return computeExpensiveValue()
})

// åªåœ¨éœ€è¦æ—¶è®¡ç®—
value := lazy.Get()
```

---

## 10. å®æˆ˜ç¤ºä¾‹

### 10.1 è‡ªå®šä¹‰è½¬æ¢å™¨

**åˆ é™¤æœªä½¿ç”¨çš„è§„åˆ™**:

```go
// RemoveUnusedRules: åˆ é™¤æœªä½¿ç”¨çš„è§„åˆ™
type RemoveUnusedRules struct {
    entrypoints []string
}

func NewRemoveUnusedRules(entrypoints []string) *RemoveUnusedRules {
    return &RemoveUnusedRules{entrypoints: entrypoints}
}

func (r *RemoveUnusedRules) Transform(node interface{}) (interface{}, error) {
    module, ok := node.(*Module)
    if !ok {
        return node, nil
    }
    
    // 1. æ„å»ºè§„åˆ™ä¾èµ–å›¾
    graph := r.buildDependencyGraph(module)
    
    // 2. ä»å…¥å£ç‚¹å¼€å§‹æ ‡è®°å¯è¾¾è§„åˆ™
    reachable := r.markReachable(graph, r.entrypoints)
    
    // 3. ç§»é™¤ä¸å¯è¾¾è§„åˆ™
    newRules := make([]*Rule, 0)
    for _, rule := range module.Rules {
        if reachable.Contains(rule.Head.Name) {
            newRules = append(newRules, rule)
        }
    }
    
    newModule := *module
    newModule.Rules = newRules
    return &newModule, nil
}

func (r *RemoveUnusedRules) buildDependencyGraph(module *Module) map[Var][]Var {
    graph := make(map[Var][]Var)
    
    for _, rule := range module.Rules {
        name := rule.Head.Name
        
        // æ”¶é›†è§„åˆ™ä½“ä¸­å¼•ç”¨çš„å…¶ä»–è§„åˆ™
        refs := collectRuleRefs(rule.Body)
        graph[name] = refs
    }
    
    return graph
}

// ä½¿ç”¨:
transformer := NewRemoveUnusedRules([]string{"allow", "deny"})
optimizedModule, _ := Transform(transformer, module)
```

### 10.2 ASTåˆ†æå·¥å…·

**å¤æ‚åº¦åˆ†æ**:

```go
// ComplexityAnalyzer: å¤æ‚åº¦åˆ†æå™¨
type ComplexityAnalyzer struct {
    totalRules int
    totalExprs int
    maxDepth   int
}

func (a *ComplexityAnalyzer) Analyze(module *Module) {
    a.totalRules = len(module.Rules)
    
    for _, rule := range module.Rules {
        a.totalExprs += len(rule.Body)
        depth := a.measureDepth(rule)
        if depth > a.maxDepth {
            a.maxDepth = depth
        }
    }
}

func (a *ComplexityAnalyzer) measureDepth(rule *Rule) int {
    maxDepth := 0
    
    for _, expr := range rule.Body {
        for _, term := range expr.Operands() {
            depth := a.termDepth(term)
            if depth > maxDepth {
                maxDepth = depth
            }
        }
    }
    
    return maxDepth
}

func (a *ComplexityAnalyzer) termDepth(term *Term) int {
    switch val := term.Value.(type) {
    case Ref:
        return len(val)
    case Array:
        maxDepth := 0
        for _, t := range val {
            depth := a.termDepth(t)
            if depth > maxDepth {
                maxDepth = depth
            }
        }
        return maxDepth + 1
    // ... å…¶ä»–ç±»å‹ ...
    }
    return 1
}

func (a *ComplexityAnalyzer) Report() string {
    return fmt.Sprintf(`
Complexity Report:
  Total Rules: %d
  Total Expressions: %d
  Max Nesting Depth: %d
`, a.totalRules, a.totalExprs, a.maxDepth)
}

// ä½¿ç”¨:
analyzer := &ComplexityAnalyzer{}
analyzer.Analyze(module)
fmt.Println(analyzer.Report())
```

### 10.3 ä»£ç ç”Ÿæˆ

**ç”ŸæˆGoä»£ç **:

```go
// GoCodeGen: Goä»£ç ç”Ÿæˆå™¨
type GoCodeGen struct {
    buf strings.Builder
}

func (g *GoCodeGen) Generate(module *Module) string {
    g.buf.WriteString("package main\n\n")
    g.buf.WriteString("import \"fmt\"\n\n")
    
    for _, rule := range module.Rules {
        g.generateRule(rule)
    }
    
    return g.buf.String()
}

func (g *GoCodeGen) generateRule(rule *Rule) {
    // ç”Ÿæˆå‡½æ•°ç­¾å
    g.buf.WriteString(fmt.Sprintf("func %s(input map[string]interface{}) bool {\n",
        rule.Head.Name))
    
    // ç”Ÿæˆè§„åˆ™ä½“
    for _, expr := range rule.Body {
        g.generateExpr(expr)
    }
    
    // ç”Ÿæˆè¿”å›è¯­å¥
    if rule.Head.Value != nil {
        g.buf.WriteString(fmt.Sprintf("    return %s\n", g.termToGo(rule.Head.Value)))
    }
    
    g.buf.WriteString("}\n\n")
}

func (g *GoCodeGen) generateExpr(expr *Expr) {
    if expr.IsEquality() {
        terms := expr.Operands()
        left := g.termToGo(terms[1])
        right := g.termToGo(terms[2])
        g.buf.WriteString(fmt.Sprintf("    if %s != %s { return false }\n", left, right))
    }
}

func (g *GoCodeGen) termToGo(term *Term) string {
    switch val := term.Value.(type) {
    case String:
        return fmt.Sprintf("%q", val)
    case Number:
        return string(val)
    case Boolean:
        return fmt.Sprintf("%t", val)
    case Ref:
        return g.refToGo(val)
    // ... å…¶ä»–ç±»å‹ ...
    }
    return "nil"
}

func (g *GoCodeGen) refToGo(ref Ref) string {
    // input.method â†’ input["method"]
    result := ref[0].String()
    for i := 1; i < len(ref); i++ {
        result += fmt.Sprintf("[%s]", g.termToGo(ref[i]))
    }
    return result
}

// ä½¿ç”¨:
gen := &GoCodeGen{}
code := gen.Generate(module)
fmt.Println(code)
```

---

## é™„å½•

### A. å®Œæ•´ASTç±»å‹å‚è€ƒ

```go
// æ‰€æœ‰ASTç±»å‹çš„å¿«é€Ÿå‚è€ƒ

// é¡¶å±‚
type Module struct {...}
type Package struct {...}
type Import struct {...}
type Comment struct {...}

// è§„åˆ™
type Rule struct {...}
type Head struct {...}
type Body []*Expr
type Args []*Term

// è¡¨è¾¾å¼
type Expr struct {...}
type With struct {...}

// é¡¹
type Term struct {...}

// å€¼ç±»å‹
type Null struct{}
type Boolean bool
type Number json.Number
type String string
type Var string
type Ref []*Term
type Array []*Term
type Object [][2]*Term
type Set []*Term
type Call []*Term

// æ¨å¯¼å¼
type ArrayComprehension struct {...}
type ObjectComprehension struct {...}
type SetComprehension struct {...}
```

### B. è½¬æ¢å™¨æ¸…å•

**OPAå†…ç½®è½¬æ¢å™¨**:

1. `RewriteLocalVars` - å±€éƒ¨å˜é‡é‡å†™
2. `CheckTypes` - ç±»å‹æ£€æŸ¥
3. `CheckSafety` - å®‰å…¨æ€§æ£€æŸ¥
4. `CheckRecursion` - é€’å½’æ£€æŸ¥
5. `RewriteComprehensions` - æ¨å¯¼å¼é‡å†™
6. `RewriteDynamicTerms` - åŠ¨æ€é¡¹é‡å†™
7. `RewriteWith` - Withè¯­å¥è½¬æ¢
8. `RewriteRefsInHead` - å¤´éƒ¨å¼•ç”¨é‡å†™
9. `BuildRuleGraph` - æ„å»ºè§„åˆ™å›¾
10. `InlineRules` - è§„åˆ™å†…è”

### C. è°ƒè¯•å·¥å…·

**ASTæ‰“å°å™¨**:

```go
// PrettyPrint: ç¾è§‚æ‰“å°AST
func PrettyPrint(node interface{}) string {
    var buf bytes.Buffer
    prettyPrintNode(&buf, node, 0)
    return buf.String()
}

func prettyPrintNode(buf *bytes.Buffer, node interface{}, indent int) {
    prefix := strings.Repeat("  ", indent)
    
    switch n := node.(type) {
    case *Module:
        fmt.Fprintf(buf, "%sModule\n", prefix)
        prettyPrintNode(buf, n.Package, indent+1)
        for _, imp := range n.Imports {
            prettyPrintNode(buf, imp, indent+1)
        }
        for _, rule := range n.Rules {
            prettyPrintNode(buf, rule, indent+1)
        }
        
    case *Rule:
        fmt.Fprintf(buf, "%sRule: %s\n", prefix, n.Head.Name)
        for _, expr := range n.Body {
            prettyPrintNode(buf, expr, indent+1)
        }
        
    case *Expr:
        fmt.Fprintf(buf, "%sExpr: %s\n", prefix, n.String())
        
    // ... å…¶ä»–ç±»å‹ ...
    }
}

// ä½¿ç”¨:
fmt.Println(PrettyPrint(module))
```

**ASTå·®å¼‚æ¯”è¾ƒ**:

```go
// Diff: æ¯”è¾ƒä¸¤ä¸ªASTçš„å·®å¼‚
func Diff(a, b interface{}) []string {
    var diffs []string
    diffNode(a, b, "", &diffs)
    return diffs
}

func diffNode(a, b interface{}, path string, diffs *[]string) {
    if reflect.TypeOf(a) != reflect.TypeOf(b) {
        *diffs = append(*diffs, fmt.Sprintf("%s: type mismatch", path))
        return
    }
    
    switch x := a.(type) {
    case *Module:
        y := b.(*Module)
        if len(x.Rules) != len(y.Rules) {
            *diffs = append(*diffs, fmt.Sprintf("%s.Rules: length mismatch", path))
        }
        // ... è¯¦ç»†æ¯”è¾ƒ ...
        
    // ... å…¶ä»–ç±»å‹ ...
    }
}

// ä½¿ç”¨:
diffs := Diff(oldModule, newModule)
for _, diff := range diffs {
    fmt.Println(diff)
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
**ç»´æŠ¤è€…**: OPAæŠ€æœ¯æ–‡æ¡£é¡¹ç›®  
**åé¦ˆ**: æ¬¢è¿é€šè¿‡GitHub Issuesæä¾›å»ºè®®

**ç›¸å…³é˜…è¯»**:

- [è¯æ³•å™¨ä¸è¯­æ³•è§£æå™¨å®ç°](10.2-è¯æ³•å™¨ä¸è¯­æ³•è§£æå™¨å®ç°.md) - è§£æå™¨å®ç°
- [ç¼–è¯‘å™¨å®ç°è¯¦è§£](10.4-ç¼–è¯‘å™¨å®ç°è¯¦è§£.md) - ç¼–è¯‘ä¼˜åŒ–
- [Regoå½¢å¼åŒ–è¯­ä¹‰](../06-å½¢å¼åŒ–è¯æ˜/06.2-Regoå½¢å¼åŒ–è¯­ä¹‰.md) - å½¢å¼åŒ–å®šä¹‰
