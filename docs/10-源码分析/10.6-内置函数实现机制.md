# 内置函数实现机制

> **文档类型**: 源码实现分析  
> **核心模块**: `topdown/builtins/*.go`, `ast/builtins.go`  
> **适用读者**: OPA扩展开发者、内置函数贡献者  
> **先修知识**: [Top-Down求值器](10.5-Top-Down求值器源码.md)、[Rego内置函数](../02-语言模型/02.3-内置函数库.md)  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 2.6 - 内置函数机制  
> **OPA版本**: v0.68.0

---

## 📋 文档概述

本文档深入分析OPA内置函数的实现机制，包括150+内置函数的架构、注册机制、实现模式和扩展方法。

**核心内容**:

- 内置函数架构与注册
- 不同类型内置函数的实现模式
- 类型检查与错误处理
- 自定义内置函数开发

---

## 1. 内置函数架构

### 1.1 Builtin定义

```go
// Builtin: 内置函数定义
type Builtin struct {
    Name string            // 函数名
    Decl *types.Function   // 类型签名
    Description string      // 描述
    Categories []string     // 分类
}

// 示例: count函数
var CountBuiltin = &Builtin{
    Name: "count",
    Decl: types.NewFunction(
        types.Args(
            types.NewAny(
                types.NewArray(types.A),
                types.NewSet(types.A),
                types.NewObject(types.A, types.B),
                types.S,
            ),
        ),
        types.N,
    ),
    Description: "Returns the length of a collection or string",
    Categories: []string{"Aggregates"},
}
```

### 1.2 内置函数注册表

```go
// 全局注册表
var builtins = map[string]*Builtin{}

// RegisterBuiltin: 注册内置函数
func RegisterBuiltin(builtin *Builtin) {
    builtins[builtin.Name] = builtin
}

// GetBuiltin: 获取内置函数
func GetBuiltin(name string) *Builtin {
    return builtins[name]
}

// Builtins: 获取所有内置函数
func Builtins() []*Builtin {
    result := make([]*Builtin, 0, len(builtins))
    for _, b := range builtins {
        result = append(result, b)
    }
    return result
}
```

### 1.3 实现函数注册

```go
// BuiltinImpl: 内置函数实现
type BuiltinImpl func(BuiltinContext, []*ast.Term, func(*ast.Term) error) error

// 注册表
var builtinImpls = map[string]BuiltinImpl{}

// RegisterBuiltinFunc: 注册实现
func RegisterBuiltinFunc(name string, impl BuiltinImpl) {
    builtinImpls[name] = impl
}

// GetBuiltinImpl: 获取实现
func GetBuiltinImpl(name string) BuiltinImpl {
    return builtinImpls[name]
}
```

---

## 2. 内置函数类型

### 2.1 Functional类型（纯函数）

```go
// RegisterFunctionalBuiltin1: 注册单参数纯函数
func RegisterFunctionalBuiltin1(name string, fn func(ast.Value) (ast.Value, error)) {
    impl := func(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
        // 应用绑定
        arg := bctx.Plug(args[0])
        
        // 调用实现函数
        result, err := fn(arg.Value)
        if err != nil {
            return err
        }
        
        // 返回结果
        return iter(ast.NewTerm(result))
    }
    
    RegisterBuiltinFunc(name, impl)
}

// 示例: abs函数
func builtinAbs(x ast.Value) (ast.Value, error) {
    num, ok := x.(ast.Number)
    if !ok {
        return nil, fmt.Errorf("abs: expected number")
    }
    
    f, _ := num.Float64()
    return ast.Number(strconv.FormatFloat(math.Abs(f), 'f', -1, 64)), nil
}

func init() {
    RegisterFunctionalBuiltin1("abs", builtinAbs)
}
```

### 2.2 Relation类型（关系）

```go
// RegisterFunctionalBuiltin2: 注册双参数函数
func RegisterFunctionalBuiltin2(name string, fn func(ast.Value, ast.Value) (ast.Value, error)) {
    impl := func(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
        arg1 := bctx.Plug(args[0])
        arg2 := bctx.Plug(args[1])
        
        result, err := fn(arg1.Value, arg2.Value)
        if err != nil {
            return err
        }
        
        return iter(ast.NewTerm(result))
    }
    
    RegisterBuiltinFunc(name, impl)
}

// 示例: plus函数
func builtinPlus(a, b ast.Value) (ast.Value, error) {
    numA, okA := a.(ast.Number)
    numB, okB := b.(ast.Number)
    
    if !okA || !okB {
        return nil, fmt.Errorf("plus: expected numbers")
    }
    
    fa, _ := numA.Float64()
    fb, _ := numB.Float64()
    
    return ast.Number(strconv.FormatFloat(fa+fb, 'f', -1, 64)), nil
}
```

### 2.3 Generator类型（生成器）

```go
// 生成器：产生多个结果
func builtinWalk(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    input := bctx.Plug(args[0])
    
    // 遍历所有路径
    return walk(input, []interface{}{}, func(path []interface{}, value ast.Value) error {
        // 构造结果
        pathArray := pathToArray(path)
        result := ast.ArrayTerm(pathArray, ast.NewTerm(value))
        
        // 调用迭代器
        return iter(result)
    })
}

func walk(term *ast.Term, path []interface{}, fn func([]interface{}, ast.Value) error) error {
    // 当前节点
    if err := fn(path, term.Value); err != nil {
        return err
    }
    
    // 递归子节点
    switch val := term.Value.(type) {
    case ast.Array:
        for i, elem := range val {
            newPath := append(path, i)
            if err := walk(elem, newPath, fn); err != nil {
                return err
            }
        }
    case ast.Object:
        for _, pair := range val {
            key := pair[0].Value
            newPath := append(path, key)
            if err := walk(pair[1], newPath, fn); err != nil {
                return err
            }
        }
    }
    
    return nil
}
```

---

## 3. 常见内置函数实现

### 3.1 字符串操作

```go
// concat: 字符串连接
func builtinConcat(delimiter ast.Value, arr ast.Value) (ast.Value, error) {
    delim, ok := delimiter.(ast.String)
    if !ok {
        return nil, fmt.Errorf("concat: delimiter must be string")
    }
    
    array, ok := arr.(ast.Array)
    if !ok {
        return nil, fmt.Errorf("concat: second argument must be array")
    }
    
    parts := make([]string, len(array))
    for i, term := range array {
        str, ok := term.Value.(ast.String)
        if !ok {
            return nil, fmt.Errorf("concat: array elements must be strings")
        }
        parts[i] = string(str)
    }
    
    result := strings.Join(parts, string(delim))
    return ast.String(result), nil
}

// startswith: 前缀检查
func builtinStartsWith(str, prefix ast.Value) (ast.Value, error) {
    s, ok1 := str.(ast.String)
    p, ok2 := prefix.(ast.String)
    
    if !ok1 || !ok2 {
        return nil, fmt.Errorf("startswith: arguments must be strings")
    }
    
    return ast.Boolean(strings.HasPrefix(string(s), string(p))), nil
}
```

### 3.2 数组操作

```go
// array.slice: 数组切片
func builtinArraySlice(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    arr := bctx.Plug(args[0])
    start := bctx.Plug(args[1])
    stop := bctx.Plug(args[2])
    
    array, ok := arr.Value.(ast.Array)
    if !ok {
        return fmt.Errorf("array.slice: first argument must be array")
    }
    
    startIdx, err := getInt(start.Value)
    if err != nil {
        return err
    }
    
    stopIdx, err := getInt(stop.Value)
    if err != nil {
        return err
    }
    
    // 处理负索引
    if startIdx < 0 {
        startIdx = len(array) + startIdx
    }
    if stopIdx < 0 {
        stopIdx = len(array) + stopIdx
    }
    
    // 边界检查
    if startIdx < 0 || startIdx > len(array) {
        return fmt.Errorf("array.slice: start index out of range")
    }
    if stopIdx < 0 || stopIdx > len(array) {
        return fmt.Errorf("array.slice: stop index out of range")
    }
    
    // 切片
    result := array[startIdx:stopIdx]
    
    return iter(ast.NewTerm(result))
}
```

### 3.3 聚合函数

```go
// sum: 求和
func builtinSum(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    arr := bctx.Plug(args[0])
    
    var array ast.Array
    
    switch val := arr.Value.(type) {
    case ast.Array:
        array = val
    case ast.Set:
        array = setToArray(val)
    default:
        return fmt.Errorf("sum: argument must be array or set")
    }
    
    var sum float64
    
    for _, term := range array {
        num, ok := term.Value.(ast.Number)
        if !ok {
            return fmt.Errorf("sum: array elements must be numbers")
        }
        
        f, _ := num.Float64()
        sum += f
    }
    
    result := ast.Number(strconv.FormatFloat(sum, 'f', -1, 64))
    return iter(ast.NewTerm(result))
}

// max: 最大值
func builtinMax(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    arr := bctx.Plug(args[0])
    
    array, ok := arr.Value.(ast.Array)
    if !ok {
        return fmt.Errorf("max: argument must be array")
    }
    
    if len(array) == 0 {
        return fmt.Errorf("max: array is empty")
    }
    
    max := array[0]
    
    for i := 1; i < len(array); i++ {
        if array[i].Value.Compare(max.Value) > 0 {
            max = array[i]
        }
    }
    
    return iter(max)
}
```

### 3.4 JSON操作

```go
// json.marshal: JSON序列化
func builtinJSONMarshal(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    term := bctx.Plug(args[0])
    
    // 转换为JSON
    jsonVal := termToJSON(term.Value)
    
    // 序列化
    data, err := json.Marshal(jsonVal)
    if err != nil {
        return err
    }
    
    result := ast.String(string(data))
    return iter(ast.NewTerm(result))
}

// json.unmarshal: JSON反序列化
func builtinJSONUnmarshal(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    str := bctx.Plug(args[0])
    
    s, ok := str.Value.(ast.String)
    if !ok {
        return fmt.Errorf("json.unmarshal: argument must be string")
    }
    
    // 反序列化
    var jsonVal interface{}
    if err := json.Unmarshal([]byte(s), &jsonVal); err != nil {
        return err
    }
    
    // 转换为Term
    term := jsonToTerm(jsonVal)
    
    return iter(term)
}
```

---

## 4. 高级特性

### 4.1 缓存机制

```go
// CachingBuiltin: 带缓存的内置函数
type CachingBuiltin struct {
    cache sync.Map  // 线程安全的缓存
}

func (cb *CachingBuiltin) Eval(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    // 计算缓存键
    key := cacheKey(args)
    
    // 查找缓存
    if cached, ok := cb.cache.Load(key); ok {
        return iter(cached.(*ast.Term))
    }
    
    // 执行计算
    result, err := cb.compute(args)
    if err != nil {
        return err
    }
    
    // 存入缓存
    cb.cache.Store(key, result)
    
    return iter(result)
}
```

### 4.2 HTTP请求

```go
// http.send: 发送HTTP请求
func builtinHTTPSend(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    req := bctx.Plug(args[0])
    
    // 解析请求
    reqObj, ok := req.Value.(ast.Object)
    if !ok {
        return fmt.Errorf("http.send: argument must be object")
    }
    
    // 提取参数
    method := getString(reqObj, "method")
    url := getString(reqObj, "url")
    headers := getObject(reqObj, "headers")
    body := get(reqObj, "body")
    
    // 构造HTTP请求
    httpReq, err := http.NewRequest(method, url, bodyReader(body))
    if err != nil {
        return err
    }
    
    // 设置headers
    for _, pair := range headers {
        key := string(pair[0].Value.(ast.String))
        val := string(pair[1].Value.(ast.String))
        httpReq.Header.Set(key, val)
    }
    
    // 发送请求
    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Do(httpReq)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    // 读取响应
    respBody, _ := ioutil.ReadAll(resp.Body)
    
    // 构造结果
    result := ast.NewObject(
        [2]*ast.Term{ast.StringTerm("status_code"), ast.IntNumberTerm(int64(resp.StatusCode))},
        [2]*ast.Term{ast.StringTerm("body"), ast.StringTerm(string(respBody))},
        [2]*ast.Term{ast.StringTerm("headers"), headersToObject(resp.Header)},
    )
    
    return iter(ast.NewTerm(result))
}
```

---

## 5. 自定义内置函数

### 5.1 完整示例

```go
package custom

import (
    "github.com/open-policy-agent/opa/ast"
    "github.com/open-policy-agent/opa/topdown"
    "github.com/open-policy-agent/opa/types"
)

// 1. 定义函数签名
var customHashBuiltin = &ast.Builtin{
    Name: "custom.hash",
    Decl: types.NewFunction(
        types.Args(types.S),  // 输入: String
        types.S,              // 输出: String
    ),
    Description: "Computes SHA256 hash of a string",
    Categories: []string{"Custom", "Crypto"},
}

// 2. 实现函数
func builtinCustomHash(bctx topdown.BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    // 获取参数
    str := bctx.Plug(args[0])
    
    s, ok := str.Value.(ast.String)
    if !ok {
        return fmt.Errorf("custom.hash: argument must be string")
    }
    
    // 计算hash
    h := sha256.New()
    h.Write([]byte(s))
    hash := hex.EncodeToString(h.Sum(nil))
    
    // 返回结果
    return iter(ast.StringTerm(hash))
}

// 3. 注册
func init() {
    ast.RegisterBuiltin(customHashBuiltin)
    topdown.RegisterBuiltinFunc(customHashBuiltin.Name, builtinCustomHash)
}

// 4. 在Rego中使用
// hash := custom.hash("hello")  # hash = "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
```

---

## 6. 测试

### 6.1 单元测试

```go
func TestCustomHash(t *testing.T) {
    tests := []struct {
        input    string
        expected string
    }{
        {"hello", "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"},
        {"world", "486ea46224d1bb4fb680f34f7c9ad96a8f24ec88be73ea8e5a6c65260e9cb8a7"},
    }
    
    for _, tt := range tests {
        // 创建查询
        query := fmt.Sprintf(`custom.hash("%s")`, tt.input)
        
        // 执行
        result, err := rego.New(
            rego.Query(query),
        ).Eval(context.Background())
        
        if err != nil {
            t.Fatal(err)
        }
        
        // 验证结果
        hash := string(result[0].Expressions[0].Value.(ast.String))
        if hash != tt.expected {
            t.Errorf("expected %s, got %s", tt.expected, hash)
        }
    }
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日

**相关阅读**:

- [Rego内置函数库](../02-语言模型/02.3-内置函数库.md)
- [Top-Down求值器源码](10.5-Top-Down求值器源码.md)
