# å†…ç½®å‡½æ•°å®ç°æœºåˆ¶

> **æ–‡æ¡£ç±»å‹**: æºç å®ç°åˆ†æ  
> **æ ¸å¿ƒæ¨¡å—**: `topdown/builtins/*.go`, `ast/builtins.go`  
> **é€‚ç”¨è¯»è€…**: OPAæ‰©å±•å¼€å‘è€…ã€å†…ç½®å‡½æ•°è´¡çŒ®è€…  
> **å…ˆä¿®çŸ¥è¯†**: [Top-Downæ±‚å€¼å™¨](10.5-Top-Downæ±‚å€¼å™¨æºç .md)ã€[Regoå†…ç½®å‡½æ•°](../02-è¯­è¨€æ¨¡å‹/02.3-å†…ç½®å‡½æ•°åº“.md)  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 2.6 - å†…ç½®å‡½æ•°æœºåˆ¶  
> **OPAç‰ˆæœ¬**: v0.68.0

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æOPAå†…ç½®å‡½æ•°çš„å®ç°æœºåˆ¶ï¼ŒåŒ…æ‹¬150+å†…ç½®å‡½æ•°çš„æ¶æ„ã€æ³¨å†Œæœºåˆ¶ã€å®ç°æ¨¡å¼å’Œæ‰©å±•æ–¹æ³•ã€‚

**æ ¸å¿ƒå†…å®¹**:

- å†…ç½®å‡½æ•°æ¶æ„ä¸æ³¨å†Œ
- ä¸åŒç±»å‹å†…ç½®å‡½æ•°çš„å®ç°æ¨¡å¼
- ç±»å‹æ£€æŸ¥ä¸é”™è¯¯å¤„ç†
- è‡ªå®šä¹‰å†…ç½®å‡½æ•°å¼€å‘

---

## 1. å†…ç½®å‡½æ•°æ¶æ„

### 1.1 Builtinå®šä¹‰

```go
// Builtin: å†…ç½®å‡½æ•°å®šä¹‰
type Builtin struct {
    Name string            // å‡½æ•°å
    Decl *types.Function   // ç±»å‹ç­¾å
    Description string      // æè¿°
    Categories []string     // åˆ†ç±»
}

// ç¤ºä¾‹: countå‡½æ•°
var CountBuiltin = &Builtin{
    Name: "count",
    Decl: types.NewFunction(
        types.Args(
            types.NewAny(
                types.NewArray(types.A),
                types.NewSet(types.A),
                types.NewObject(types.A, types.B),
                types.S,
            ),
        ),
        types.N,
    ),
    Description: "Returns the length of a collection or string",
    Categories: []string{"Aggregates"},
}
```

### 1.2 å†…ç½®å‡½æ•°æ³¨å†Œè¡¨

```go
// å…¨å±€æ³¨å†Œè¡¨
var builtins = map[string]*Builtin{}

// RegisterBuiltin: æ³¨å†Œå†…ç½®å‡½æ•°
func RegisterBuiltin(builtin *Builtin) {
    builtins[builtin.Name] = builtin
}

// GetBuiltin: è·å–å†…ç½®å‡½æ•°
func GetBuiltin(name string) *Builtin {
    return builtins[name]
}

// Builtins: è·å–æ‰€æœ‰å†…ç½®å‡½æ•°
func Builtins() []*Builtin {
    result := make([]*Builtin, 0, len(builtins))
    for _, b := range builtins {
        result = append(result, b)
    }
    return result
}
```

### 1.3 å®ç°å‡½æ•°æ³¨å†Œ

```go
// BuiltinImpl: å†…ç½®å‡½æ•°å®ç°
type BuiltinImpl func(BuiltinContext, []*ast.Term, func(*ast.Term) error) error

// æ³¨å†Œè¡¨
var builtinImpls = map[string]BuiltinImpl{}

// RegisterBuiltinFunc: æ³¨å†Œå®ç°
func RegisterBuiltinFunc(name string, impl BuiltinImpl) {
    builtinImpls[name] = impl
}

// GetBuiltinImpl: è·å–å®ç°
func GetBuiltinImpl(name string) BuiltinImpl {
    return builtinImpls[name]
}
```

---

## 2. å†…ç½®å‡½æ•°ç±»å‹

### 2.1 Functionalç±»å‹ï¼ˆçº¯å‡½æ•°ï¼‰

```go
// RegisterFunctionalBuiltin1: æ³¨å†Œå•å‚æ•°çº¯å‡½æ•°
func RegisterFunctionalBuiltin1(name string, fn func(ast.Value) (ast.Value, error)) {
    impl := func(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
        // åº”ç”¨ç»‘å®š
        arg := bctx.Plug(args[0])
        
        // è°ƒç”¨å®ç°å‡½æ•°
        result, err := fn(arg.Value)
        if err != nil {
            return err
        }
        
        // è¿”å›ç»“æœ
        return iter(ast.NewTerm(result))
    }
    
    RegisterBuiltinFunc(name, impl)
}

// ç¤ºä¾‹: abså‡½æ•°
func builtinAbs(x ast.Value) (ast.Value, error) {
    num, ok := x.(ast.Number)
    if !ok {
        return nil, fmt.Errorf("abs: expected number")
    }
    
    f, _ := num.Float64()
    return ast.Number(strconv.FormatFloat(math.Abs(f), 'f', -1, 64)), nil
}

func init() {
    RegisterFunctionalBuiltin1("abs", builtinAbs)
}
```

### 2.2 Relationç±»å‹ï¼ˆå…³ç³»ï¼‰

```go
// RegisterFunctionalBuiltin2: æ³¨å†ŒåŒå‚æ•°å‡½æ•°
func RegisterFunctionalBuiltin2(name string, fn func(ast.Value, ast.Value) (ast.Value, error)) {
    impl := func(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
        arg1 := bctx.Plug(args[0])
        arg2 := bctx.Plug(args[1])
        
        result, err := fn(arg1.Value, arg2.Value)
        if err != nil {
            return err
        }
        
        return iter(ast.NewTerm(result))
    }
    
    RegisterBuiltinFunc(name, impl)
}

// ç¤ºä¾‹: pluså‡½æ•°
func builtinPlus(a, b ast.Value) (ast.Value, error) {
    numA, okA := a.(ast.Number)
    numB, okB := b.(ast.Number)
    
    if !okA || !okB {
        return nil, fmt.Errorf("plus: expected numbers")
    }
    
    fa, _ := numA.Float64()
    fb, _ := numB.Float64()
    
    return ast.Number(strconv.FormatFloat(fa+fb, 'f', -1, 64)), nil
}
```

### 2.3 Generatorç±»å‹ï¼ˆç”Ÿæˆå™¨ï¼‰

```go
// ç”Ÿæˆå™¨ï¼šäº§ç”Ÿå¤šä¸ªç»“æœ
func builtinWalk(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    input := bctx.Plug(args[0])
    
    // éå†æ‰€æœ‰è·¯å¾„
    return walk(input, []interface{}{}, func(path []interface{}, value ast.Value) error {
        // æ„é€ ç»“æœ
        pathArray := pathToArray(path)
        result := ast.ArrayTerm(pathArray, ast.NewTerm(value))
        
        // è°ƒç”¨è¿­ä»£å™¨
        return iter(result)
    })
}

func walk(term *ast.Term, path []interface{}, fn func([]interface{}, ast.Value) error) error {
    // å½“å‰èŠ‚ç‚¹
    if err := fn(path, term.Value); err != nil {
        return err
    }
    
    // é€’å½’å­èŠ‚ç‚¹
    switch val := term.Value.(type) {
    case ast.Array:
        for i, elem := range val {
            newPath := append(path, i)
            if err := walk(elem, newPath, fn); err != nil {
                return err
            }
        }
    case ast.Object:
        for _, pair := range val {
            key := pair[0].Value
            newPath := append(path, key)
            if err := walk(pair[1], newPath, fn); err != nil {
                return err
            }
        }
    }
    
    return nil
}
```

---

## 3. å¸¸è§å†…ç½®å‡½æ•°å®ç°

### 3.1 å­—ç¬¦ä¸²æ“ä½œ

```go
// concat: å­—ç¬¦ä¸²è¿æ¥
func builtinConcat(delimiter ast.Value, arr ast.Value) (ast.Value, error) {
    delim, ok := delimiter.(ast.String)
    if !ok {
        return nil, fmt.Errorf("concat: delimiter must be string")
    }
    
    array, ok := arr.(ast.Array)
    if !ok {
        return nil, fmt.Errorf("concat: second argument must be array")
    }
    
    parts := make([]string, len(array))
    for i, term := range array {
        str, ok := term.Value.(ast.String)
        if !ok {
            return nil, fmt.Errorf("concat: array elements must be strings")
        }
        parts[i] = string(str)
    }
    
    result := strings.Join(parts, string(delim))
    return ast.String(result), nil
}

// startswith: å‰ç¼€æ£€æŸ¥
func builtinStartsWith(str, prefix ast.Value) (ast.Value, error) {
    s, ok1 := str.(ast.String)
    p, ok2 := prefix.(ast.String)
    
    if !ok1 || !ok2 {
        return nil, fmt.Errorf("startswith: arguments must be strings")
    }
    
    return ast.Boolean(strings.HasPrefix(string(s), string(p))), nil
}
```

### 3.2 æ•°ç»„æ“ä½œ

```go
// array.slice: æ•°ç»„åˆ‡ç‰‡
func builtinArraySlice(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    arr := bctx.Plug(args[0])
    start := bctx.Plug(args[1])
    stop := bctx.Plug(args[2])
    
    array, ok := arr.Value.(ast.Array)
    if !ok {
        return fmt.Errorf("array.slice: first argument must be array")
    }
    
    startIdx, err := getInt(start.Value)
    if err != nil {
        return err
    }
    
    stopIdx, err := getInt(stop.Value)
    if err != nil {
        return err
    }
    
    // å¤„ç†è´Ÿç´¢å¼•
    if startIdx < 0 {
        startIdx = len(array) + startIdx
    }
    if stopIdx < 0 {
        stopIdx = len(array) + stopIdx
    }
    
    // è¾¹ç•Œæ£€æŸ¥
    if startIdx < 0 || startIdx > len(array) {
        return fmt.Errorf("array.slice: start index out of range")
    }
    if stopIdx < 0 || stopIdx > len(array) {
        return fmt.Errorf("array.slice: stop index out of range")
    }
    
    // åˆ‡ç‰‡
    result := array[startIdx:stopIdx]
    
    return iter(ast.NewTerm(result))
}
```

### 3.3 èšåˆå‡½æ•°

```go
// sum: æ±‚å’Œ
func builtinSum(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    arr := bctx.Plug(args[0])
    
    var array ast.Array
    
    switch val := arr.Value.(type) {
    case ast.Array:
        array = val
    case ast.Set:
        array = setToArray(val)
    default:
        return fmt.Errorf("sum: argument must be array or set")
    }
    
    var sum float64
    
    for _, term := range array {
        num, ok := term.Value.(ast.Number)
        if !ok {
            return fmt.Errorf("sum: array elements must be numbers")
        }
        
        f, _ := num.Float64()
        sum += f
    }
    
    result := ast.Number(strconv.FormatFloat(sum, 'f', -1, 64))
    return iter(ast.NewTerm(result))
}

// max: æœ€å¤§å€¼
func builtinMax(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    arr := bctx.Plug(args[0])
    
    array, ok := arr.Value.(ast.Array)
    if !ok {
        return fmt.Errorf("max: argument must be array")
    }
    
    if len(array) == 0 {
        return fmt.Errorf("max: array is empty")
    }
    
    max := array[0]
    
    for i := 1; i < len(array); i++ {
        if array[i].Value.Compare(max.Value) > 0 {
            max = array[i]
        }
    }
    
    return iter(max)
}
```

### 3.4 JSONæ“ä½œ

```go
// json.marshal: JSONåºåˆ—åŒ–
func builtinJSONMarshal(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    term := bctx.Plug(args[0])
    
    // è½¬æ¢ä¸ºJSON
    jsonVal := termToJSON(term.Value)
    
    // åºåˆ—åŒ–
    data, err := json.Marshal(jsonVal)
    if err != nil {
        return err
    }
    
    result := ast.String(string(data))
    return iter(ast.NewTerm(result))
}

// json.unmarshal: JSONååºåˆ—åŒ–
func builtinJSONUnmarshal(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    str := bctx.Plug(args[0])
    
    s, ok := str.Value.(ast.String)
    if !ok {
        return fmt.Errorf("json.unmarshal: argument must be string")
    }
    
    // ååºåˆ—åŒ–
    var jsonVal interface{}
    if err := json.Unmarshal([]byte(s), &jsonVal); err != nil {
        return err
    }
    
    // è½¬æ¢ä¸ºTerm
    term := jsonToTerm(jsonVal)
    
    return iter(term)
}
```

---

## 4. é«˜çº§ç‰¹æ€§

### 4.1 ç¼“å­˜æœºåˆ¶

```go
// CachingBuiltin: å¸¦ç¼“å­˜çš„å†…ç½®å‡½æ•°
type CachingBuiltin struct {
    cache sync.Map  // çº¿ç¨‹å®‰å…¨çš„ç¼“å­˜
}

func (cb *CachingBuiltin) Eval(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    // è®¡ç®—ç¼“å­˜é”®
    key := cacheKey(args)
    
    // æŸ¥æ‰¾ç¼“å­˜
    if cached, ok := cb.cache.Load(key); ok {
        return iter(cached.(*ast.Term))
    }
    
    // æ‰§è¡Œè®¡ç®—
    result, err := cb.compute(args)
    if err != nil {
        return err
    }
    
    // å­˜å…¥ç¼“å­˜
    cb.cache.Store(key, result)
    
    return iter(result)
}
```

### 4.2 HTTPè¯·æ±‚

```go
// http.send: å‘é€HTTPè¯·æ±‚
func builtinHTTPSend(bctx BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    req := bctx.Plug(args[0])
    
    // è§£æè¯·æ±‚
    reqObj, ok := req.Value.(ast.Object)
    if !ok {
        return fmt.Errorf("http.send: argument must be object")
    }
    
    // æå–å‚æ•°
    method := getString(reqObj, "method")
    url := getString(reqObj, "url")
    headers := getObject(reqObj, "headers")
    body := get(reqObj, "body")
    
    // æ„é€ HTTPè¯·æ±‚
    httpReq, err := http.NewRequest(method, url, bodyReader(body))
    if err != nil {
        return err
    }
    
    // è®¾ç½®headers
    for _, pair := range headers {
        key := string(pair[0].Value.(ast.String))
        val := string(pair[1].Value.(ast.String))
        httpReq.Header.Set(key, val)
    }
    
    // å‘é€è¯·æ±‚
    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Do(httpReq)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    // è¯»å–å“åº”
    respBody, _ := ioutil.ReadAll(resp.Body)
    
    // æ„é€ ç»“æœ
    result := ast.NewObject(
        [2]*ast.Term{ast.StringTerm("status_code"), ast.IntNumberTerm(int64(resp.StatusCode))},
        [2]*ast.Term{ast.StringTerm("body"), ast.StringTerm(string(respBody))},
        [2]*ast.Term{ast.StringTerm("headers"), headersToObject(resp.Header)},
    )
    
    return iter(ast.NewTerm(result))
}
```

---

## 5. è‡ªå®šä¹‰å†…ç½®å‡½æ•°

### 5.1 å®Œæ•´ç¤ºä¾‹

```go
package custom

import (
    "github.com/open-policy-agent/opa/ast"
    "github.com/open-policy-agent/opa/topdown"
    "github.com/open-policy-agent/opa/types"
)

// 1. å®šä¹‰å‡½æ•°ç­¾å
var customHashBuiltin = &ast.Builtin{
    Name: "custom.hash",
    Decl: types.NewFunction(
        types.Args(types.S),  // è¾“å…¥: String
        types.S,              // è¾“å‡º: String
    ),
    Description: "Computes SHA256 hash of a string",
    Categories: []string{"Custom", "Crypto"},
}

// 2. å®ç°å‡½æ•°
func builtinCustomHash(bctx topdown.BuiltinContext, args []*ast.Term, iter func(*ast.Term) error) error {
    // è·å–å‚æ•°
    str := bctx.Plug(args[0])
    
    s, ok := str.Value.(ast.String)
    if !ok {
        return fmt.Errorf("custom.hash: argument must be string")
    }
    
    // è®¡ç®—hash
    h := sha256.New()
    h.Write([]byte(s))
    hash := hex.EncodeToString(h.Sum(nil))
    
    // è¿”å›ç»“æœ
    return iter(ast.StringTerm(hash))
}

// 3. æ³¨å†Œ
func init() {
    ast.RegisterBuiltin(customHashBuiltin)
    topdown.RegisterBuiltinFunc(customHashBuiltin.Name, builtinCustomHash)
}

// 4. åœ¨Regoä¸­ä½¿ç”¨
// hash := custom.hash("hello")  # hash = "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
```

---

## 6. æµ‹è¯•

### 6.1 å•å…ƒæµ‹è¯•

```go
func TestCustomHash(t *testing.T) {
    tests := []struct {
        input    string
        expected string
    }{
        {"hello", "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"},
        {"world", "486ea46224d1bb4fb680f34f7c9ad96a8f24ec88be73ea8e5a6c65260e9cb8a7"},
    }
    
    for _, tt := range tests {
        // åˆ›å»ºæŸ¥è¯¢
        query := fmt.Sprintf(`custom.hash("%s")`, tt.input)
        
        // æ‰§è¡Œ
        result, err := rego.New(
            rego.Query(query),
        ).Eval(context.Background())
        
        if err != nil {
            t.Fatal(err)
        }
        
        // éªŒè¯ç»“æœ
        hash := string(result[0].Expressions[0].Value.(ast.String))
        if hash != tt.expected {
            t.Errorf("expected %s, got %s", tt.expected, hash)
        }
    }
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥

**ç›¸å…³é˜…è¯»**:

- [Regoå†…ç½®å‡½æ•°åº“](../02-è¯­è¨€æ¨¡å‹/02.3-å†…ç½®å‡½æ•°åº“.md)
- [Top-Downæ±‚å€¼å™¨æºç ](10.5-Top-Downæ±‚å€¼å™¨æºç .md)
