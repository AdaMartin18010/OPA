# ç¼–è¯‘å™¨å®ç°è¯¦è§£

> **æ–‡æ¡£ç±»å‹**: æºç å®ç°åˆ†æ  
> **æ ¸å¿ƒæ¨¡å—**: `compile/compile.go`, `ast/compile.go`, `internal/compiler/`  
> **é€‚ç”¨è¯»è€…**: ç¼–è¯‘å™¨å¼€å‘è€…ã€è¯­è¨€è®¾è®¡è€…ã€æ€§èƒ½ä¼˜åŒ–å·¥ç¨‹å¸ˆ  
> **å…ˆä¿®çŸ¥è¯†**: [ASTæ„å»ºä¸è½¬æ¢](10.3-ASTæ„å»ºä¸è½¬æ¢.md)ã€ç¼–è¯‘åŸç†  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 2.4 - ç¼–è¯‘å™¨åˆ†æ  
> **OPAç‰ˆæœ¬**: v0.68.0

---

## ğŸ¯ å®ç°åˆ†æè¯´æ˜

> **æœ¬æ–‡æ¡£ç›®æ ‡**:
>
> - âœ… æ·±å…¥ç†è§£OPAç¼–è¯‘å™¨çš„å®Œæ•´æ¶æ„
> - âœ… æŒæ¡å„ä¸ªç¼–è¯‘é˜¶æ®µçš„å®ç°åŸç†
> - âœ… å­¦ä¹ ç±»å‹æ£€æŸ¥å’Œå®‰å…¨æ€§åˆ†ææŠ€æœ¯
> - âœ… ç†è§£æŸ¥è¯¢è§„åˆ’å’Œä¼˜åŒ–ç­–ç•¥
>
> **æŠ€æœ¯äº®ç‚¹**:
>
> - **å¤šé˜¶æ®µç¼–è¯‘**: æ¨¡å—åŒ–çš„ç¼–è¯‘ç®¡é“
> - **å¢é‡ç¼–è¯‘**: åªé‡æ–°ç¼–è¯‘å˜æ›´éƒ¨åˆ†
> - **é™æ€åˆ†æ**: ç¼–è¯‘æ—¶é”™è¯¯æ£€æµ‹
> - **æŸ¥è¯¢ä¼˜åŒ–**: æ™ºèƒ½æ‰§è¡Œè®¡åˆ’
>
> **å®æˆ˜ä»·å€¼**:
>
> - ç†è§£Regoç¼–è¯‘è¿‡ç¨‹
> - å®ç°è‡ªå®šä¹‰ä¼˜åŒ–
> - æ€§èƒ½è°ƒä¼˜
> - å·¥å…·å¼€å‘

---

## ç›®å½•

- [ç¼–è¯‘å™¨å®ç°è¯¦è§£](#ç¼–è¯‘å™¨å®ç°è¯¦è§£)
  - [ğŸ¯ å®ç°åˆ†æè¯´æ˜](#-å®ç°åˆ†æè¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. ç¼–è¯‘å™¨æ¶æ„](#1-ç¼–è¯‘å™¨æ¶æ„)
    - [1.1 æ•´ä½“è®¾è®¡](#11-æ•´ä½“è®¾è®¡)
    - [1.2 ç¼–è¯‘é˜¶æ®µ](#12-ç¼–è¯‘é˜¶æ®µ)
    - [1.3 æ•°æ®æµ](#13-æ•°æ®æµ)
  - [2. Compileræ ¸å¿ƒç»“æ„](#2-compileræ ¸å¿ƒç»“æ„)
    - [2.1 Compilerç±»å‹](#21-compilerç±»å‹)
    - [2.2 åˆ›å»ºä¸åˆå§‹åŒ–](#22-åˆ›å»ºä¸åˆå§‹åŒ–)
    - [2.3 ç¼–è¯‘å…¥å£](#23-ç¼–è¯‘å…¥å£)
  - [3. ç¼–è¯‘é˜¶æ®µè¯¦è§£](#3-ç¼–è¯‘é˜¶æ®µè¯¦è§£)
    - [3.1 æ¨¡å—è§£æ](#31-æ¨¡å—è§£æ)
    - [3.2 æ¨¡å—æ ‘æ„å»º](#32-æ¨¡å—æ ‘æ„å»º)
    - [3.3 ä¾èµ–åˆ†æ](#33-ä¾èµ–åˆ†æ)
    - [3.4 ç±»å‹æ£€æŸ¥](#34-ç±»å‹æ£€æŸ¥)
    - [3.5 å®‰å…¨æ€§åˆ†æ](#35-å®‰å…¨æ€§åˆ†æ)
    - [3.6 é€’å½’æ£€æŸ¥](#36-é€’å½’æ£€æŸ¥)
  - [4. ASTé‡å†™](#4-asté‡å†™)
    - [4.1 å±€éƒ¨å˜é‡é‡å†™](#41-å±€éƒ¨å˜é‡é‡å†™)
    - [4.2 æ¨å¯¼å¼é‡å†™](#42-æ¨å¯¼å¼é‡å†™)
    - [4.3 åŠ¨æ€é¡¹é‡å†™](#43-åŠ¨æ€é¡¹é‡å†™)
    - [4.4 å¼•ç”¨é‡å†™](#44-å¼•ç”¨é‡å†™)
  - [5. æŸ¥è¯¢è§„åˆ’](#5-æŸ¥è¯¢è§„åˆ’)
    - [5.1 è§„åˆ’å™¨æ¶æ„](#51-è§„åˆ’å™¨æ¶æ„)
    - [5.2 ç´¢å¼•æ„å»º](#52-ç´¢å¼•æ„å»º)
    - [5.3 è§„åˆ™æ’åº](#53-è§„åˆ™æ’åº)
    - [5.4 éƒ¨åˆ†æ±‚å€¼](#54-éƒ¨åˆ†æ±‚å€¼)
  - [6. ç±»å‹ç³»ç»Ÿå®ç°](#6-ç±»å‹ç³»ç»Ÿå®ç°)
    - [6.1 ç±»å‹å®šä¹‰](#61-ç±»å‹å®šä¹‰)
    - [6.2 ç±»å‹æ¨å¯¼](#62-ç±»å‹æ¨å¯¼)
  - [é™„å½•](#é™„å½•)
    - [A. ç¼–è¯‘å™¨é€‰é¡¹](#a-ç¼–è¯‘å™¨é€‰é¡¹)
    - [B. ç¼–è¯‘é˜¶æ®µæ¸…å•](#b-ç¼–è¯‘é˜¶æ®µæ¸…å•)
    - [C. æ€§èƒ½è°ƒä¼˜æŒ‡å—](#c-æ€§èƒ½è°ƒä¼˜æŒ‡å—)

---

## 1. ç¼–è¯‘å™¨æ¶æ„

### 1.1 æ•´ä½“è®¾è®¡

OPAç¼–è¯‘å™¨é‡‡ç”¨**å¤šé˜¶æ®µç®¡é“**æ¶æ„ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              è¾“å…¥ï¼šRegoæ¨¡å—é›†åˆ                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ1: è§£æä¸æ„å»º (Parsing & Building)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ è§£æRegoæºç  â†’ AST                      â”‚ â”‚
â”‚  â”‚  â€¢ æ„å»ºæ¨¡å—æ ‘                               â”‚ â”‚
â”‚  â”‚  â€¢ æ”¶é›†å¯¼å…¥å’Œå¯¼å‡º                           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ2: è¯­ä¹‰åˆ†æ (Semantic Analysis)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ ç±»å‹æ£€æŸ¥                                 â”‚ â”‚
â”‚  â”‚  â€¢ å®‰å…¨æ€§åˆ†æ                               â”‚ â”‚
â”‚  â”‚  â€¢ é€’å½’æ£€æŸ¥                                 â”‚ â”‚
â”‚  â”‚  â€¢ ä¾èµ–åˆ†æ                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ3: ASTé‡å†™ (Rewriting)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ å±€éƒ¨å˜é‡é‡å†™                             â”‚ â”‚
â”‚  â”‚  â€¢ æ¨å¯¼å¼å±•å¼€                               â”‚ â”‚
â”‚  â”‚  â€¢ åŠ¨æ€é¡¹æå–                               â”‚ â”‚
â”‚  â”‚  â€¢ å¼•ç”¨è§„èŒƒåŒ–                               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ4: ä¼˜åŒ– (Optimization)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ æŸ¥è¯¢è§„åˆ’                                 â”‚ â”‚
â”‚  â”‚  â€¢ ç´¢å¼•æ„å»º                                 â”‚ â”‚
â”‚  â”‚  â€¢ éƒ¨åˆ†æ±‚å€¼                                 â”‚ â”‚
â”‚  â”‚  â€¢ è§„åˆ™å†…è”                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ5: ä»£ç ç”Ÿæˆ (Code Generation - å¯é€‰)         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  â€¢ ç”ŸæˆIR                                   â”‚ â”‚
â”‚  â”‚  â€¢ WASMç¼–è¯‘                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          è¾“å‡ºï¼šç¼–è¯‘åçš„ç­–ç•¥ Bundle                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ç¼–è¯‘é˜¶æ®µ

**ç¼–è¯‘é˜¶æ®µæšä¸¾**:

```go
// CompilerStage: ç¼–è¯‘é˜¶æ®µç±»å‹
type CompilerStage string

const (
    // è§£æé˜¶æ®µ
    StageResolveRefs       CompilerStage = "ResolveRefs"
    StageCheckRecursion    CompilerStage = "CheckRecursion"
    
    // é‡å†™é˜¶æ®µ
    StageRewriteLocalVars  CompilerStage = "RewriteLocalVars"
    StageRewriteExprTerms  CompilerStage = "RewriteExprTerms"
    StageRewriteComprehensionTerms CompilerStage = "RewriteComprehensionTerms"
    StageRewriteRefsInHead CompilerStage = "RewriteRefsInHead"
    StageRewriteDynamicTerms CompilerStage = "RewriteDynamicTerms"
    StageRewriteEquals     CompilerStage = "RewriteEquals"
    StageRewriteWith       CompilerStage = "RewriteWith"
    
    // æ£€æŸ¥é˜¶æ®µ
    StageCheckDuplicateImports CompilerStage = "CheckDuplicateImports"
    StageCheckSafety         CompilerStage = "CheckSafety"
    StageCheckUnsafeBuiltins CompilerStage = "CheckUnsafeBuiltins"
    StageCheckTypes          CompilerStage = "CheckTypes"
    
    // ä¼˜åŒ–é˜¶æ®µ
    StageBuildComprehensionIndex CompilerStage = "BuildComprehensionIndex"
    StageBuildRuleIndex        CompilerStage = "BuildRuleIndex"
)
```

### 1.3 æ•°æ®æµ

**ç¼–è¯‘è¿‡ç¨‹ä¸­çš„æ•°æ®è½¬æ¢**:

```text
Regoæºç  (*.rego)
      â†“
  AST (æœªç¼–è¯‘)
      â†“
ç¼–è¯‘å™¨å¤„ç†
      â†“
ç¼–è¯‘åAST
      â”œâ†’ è§„åˆ™å›¾ (Rule Graph)
      â”œâ†’ ç±»å‹ç¯å¢ƒ (Type Environment)
      â”œâ†’ ç´¢å¼• (Indices)
      â””â†’ å…ƒæ•°æ® (Metadata)
      â†“
  Bundle / IR
```

---

## 2. Compileræ ¸å¿ƒç»“æ„

### 2.1 Compilerç±»å‹

```go
// Compiler: OPAç¼–è¯‘å™¨
type Compiler struct {
    // è¾“å…¥
    Modules      map[string]*Module  // æ¨¡å—é›†åˆ (æ–‡ä»¶å â†’ æ¨¡å—)
    ModuleTree   *ModuleTree         // æ¨¡å—æ ‘
    
    // åˆ†æç»“æœ
    RuleGraph    *graph.Graph        // è§„åˆ™ä¾èµ–å›¾
    TypeEnv      *TypeEnv            // ç±»å‹ç¯å¢ƒ
    
    // ç´¢å¼•
    RuleIndex    *RuleIndex          // è§„åˆ™ç´¢å¼•
    ComprehensionIndex *ComprehensionIndex  // æ¨å¯¼å¼ç´¢å¼•
    
    // é…ç½®
    stages       []func(*Compiler) error  // ç¼–è¯‘é˜¶æ®µ
    capabilities *Capabilities       // èƒ½åŠ›é™åˆ¶
    
    // é”™è¯¯
    Errors       Errors              // ç¼–è¯‘é”™è¯¯
    warnings     []*Warning          // è­¦å‘Š
    
    // å…ƒæ•°æ®
    metadata     *Metadata           // ç¼–è¯‘å…ƒæ•°æ®
    
    // çŠ¶æ€
    compiled     bool                // æ˜¯å¦å·²ç¼–è¯‘
    
    // ç¼“å­˜
    cache        *CompilerCache      // ç¼–è¯‘ç¼“å­˜
}
```

**ModuleTreeç±»å‹**:

```go
// ModuleTree: æ¨¡å—æ ‘ï¼ˆå‘½åç©ºé—´æ ‘ï¼‰
type ModuleTree struct {
    root *TreeNode
}

// TreeNode: æ ‘èŠ‚ç‚¹
type TreeNode struct {
    Key      Value           // è·¯å¾„é”®
    Children map[Value]*TreeNode  // å­èŠ‚ç‚¹
    Values   []*Rule         // æ­¤è·¯å¾„ä¸‹çš„è§„åˆ™
    Hide     bool            // æ˜¯å¦éšè—
}

// ç¤ºä¾‹:
// package a.b.c
// package a.b.d
//
// æ ‘ç»“æ„:
//   data
//     â””â”€â”€ a
//         â””â”€â”€ b
//             â”œâ”€â”€ c (è§„åˆ™...)
//             â””â”€â”€ d (è§„åˆ™...)
```

**RuleGraphç±»å‹**:

```go
// RuleGraph: è§„åˆ™ä¾èµ–å›¾
type RuleGraph struct {
    nodes map[Ref]*RuleNode     // è§„åˆ™èŠ‚ç‚¹
    edges map[Ref][]Ref         // ä¾èµ–è¾¹
}

// RuleNode: è§„åˆ™èŠ‚ç‚¹
type RuleNode struct {
    Ref   Ref      // è§„åˆ™å¼•ç”¨
    Rules []*Rule  // è§„åˆ™åˆ—è¡¨
}
```

### 2.2 åˆ›å»ºä¸åˆå§‹åŒ–

```go
// NewCompiler: åˆ›å»ºç¼–è¯‘å™¨
func NewCompiler() *Compiler {
    c := &Compiler{
        Modules:   make(map[string]*Module),
        Errors:    nil,
        stages:    getDefaultStages(),
        TypeEnv:   NewTypeEnv(),
        cache:     NewCompilerCache(),
    }
    return c
}

// getDefaultStages: è·å–é»˜è®¤ç¼–è¯‘é˜¶æ®µ
func getDefaultStages() []func(*Compiler) error {
    return []func(*Compiler) error{
        // 1. è§£æä¸æ„å»º
        (*Compiler).buildModuleTree,
        (*Compiler).resolveAllRefs,
        
        // 2. æ£€æŸ¥
        (*Compiler).checkRecursion,
        (*Compiler).checkDuplicateImports,
        
        // 3. é‡å†™
        (*Compiler).rewriteLocalVars,
        (*Compiler).rewriteExprTerms,
        (*Compiler).rewriteComprehensionTerms,
        (*Compiler).rewriteRefsInHead,
        (*Compiler).rewriteDynamicTerms,
        (*Compiler).rewriteEquals,
        (*Compiler).rewriteWith,
        
        // 4. å®‰å…¨æ€§å’Œç±»å‹
        (*Compiler).checkSafety,
        (*Compiler).checkUnsafeBuiltins,
        (*Compiler).checkTypes,
        
        // 5. ç´¢å¼•
        (*Compiler).buildRuleGraph,
        (*Compiler).buildRuleIndex,
        (*Compiler).buildComprehensionIndex,
    }
}

// WithStages: è‡ªå®šä¹‰ç¼–è¯‘é˜¶æ®µ
func (c *Compiler) WithStages(stages ...func(*Compiler) error) *Compiler {
    c.stages = stages
    return c
}

// WithCapabilities: è®¾ç½®èƒ½åŠ›é™åˆ¶
func (c *Compiler) WithCapabilities(caps *Capabilities) *Compiler {
    c.capabilities = caps
    return c
}
```

### 2.3 ç¼–è¯‘å…¥å£

```go
// Compile: ç¼–è¯‘æ‰€æœ‰æ¨¡å—
func (c *Compiler) Compile(modules map[string]*Module) error {
    // è®¾ç½®æ¨¡å—
    c.Modules = modules
    
    // æ‰§è¡Œç¼–è¯‘é˜¶æ®µ
    for _, stage := range c.stages {
        if err := stage(c); err != nil {
            return err
        }
        
        // å¦‚æœæœ‰é”™è¯¯ï¼Œåœæ­¢ç¼–è¯‘
        if len(c.Errors) > 0 {
            return c.Errors
        }
    }
    
    c.compiled = true
    return nil
}

// QueryCompiler: æŸ¥è¯¢ç¼–è¯‘å™¨ï¼ˆç”¨äºad-hocæŸ¥è¯¢ï¼‰
type QueryCompiler struct {
    compiler *Compiler
    query    Body
}

// NewQueryCompiler: åˆ›å»ºæŸ¥è¯¢ç¼–è¯‘å™¨
func (c *Compiler) QueryCompiler() *QueryCompiler {
    return &QueryCompiler{
        compiler: c,
    }
}

// Compile: ç¼–è¯‘æŸ¥è¯¢
func (qc *QueryCompiler) Compile(query Body) error {
    qc.query = query
    
    // åº”ç”¨å¿…è¦çš„é‡å†™
    if err := qc.rewriteQuery(); err != nil {
        return err
    }
    
    // ç±»å‹æ£€æŸ¥
    if err := qc.checkQueryTypes(); err != nil {
        return err
    }
    
    // å®‰å…¨æ€§æ£€æŸ¥
    if err := qc.checkQuerySafety(); err != nil {
        return err
    }
    
    return nil
}
```

---

## 3. ç¼–è¯‘é˜¶æ®µè¯¦è§£

### 3.1 æ¨¡å—è§£æ

**ParseModule**:

```go
// ParseModule: è§£æå•ä¸ªæ¨¡å—
func ParseModule(filename string, source []byte) (*Module, error) {
    // åˆ›å»ºscanner
    s := newScanner(source)
    
    // åˆ›å»ºparser
    p := newParser(s)
    
    // è§£æ
    module := p.parseModule()
    
    // æ£€æŸ¥é”™è¯¯
    if len(p.errors) > 0 {
        return nil, p.errors
    }
    
    // è®¾ç½®å…ƒä¿¡æ¯
    module.Package.Location = &Location{
        File: filename,
    }
    
    return module, nil
}

// ParseModules: æ‰¹é‡è§£ææ¨¡å—
func ParseModules(files map[string][]byte) (map[string]*Module, error) {
    modules := make(map[string]*Module)
    var errors Errors
    
    for filename, source := range files {
        module, err := ParseModule(filename, source)
        if err != nil {
            errors = append(errors, err.(Errors)...)
            continue
        }
        modules[filename] = module
    }
    
    if len(errors) > 0 {
        return nil, errors
    }
    
    return modules, nil
}
```

### 3.2 æ¨¡å—æ ‘æ„å»º

```go
// buildModuleTree: æ„å»ºæ¨¡å—æ ‘
func (c *Compiler) buildModuleTree() error {
    c.ModuleTree = NewModuleTree()
    
    for _, module := range c.Modules {
        // å°†æ¨¡å—æ’å…¥æ ‘ä¸­
        path := module.Package.Path
        
        // æ’å…¥è§„åˆ™
        for _, rule := range module.Rules {
            fullPath := append(path, rule.Head.Name)
            c.ModuleTree.Insert(fullPath, rule)
        }
    }
    
    return nil
}

// Insert: æ’å…¥è§„åˆ™åˆ°æ ‘ä¸­
func (t *ModuleTree) Insert(path Ref, rule *Rule) {
    node := t.root
    
    for _, term := range path {
        key := term.Value
        
        // æŸ¥æ‰¾æˆ–åˆ›å»ºå­èŠ‚ç‚¹
        child, ok := node.Children[key]
        if !ok {
            child = &TreeNode{
                Key:      key,
                Children: make(map[Value]*TreeNode),
                Values:   []*Rule{},
            }
            node.Children[key] = child
        }
        
        node = child
    }
    
    // æ·»åŠ è§„åˆ™åˆ°å¶èŠ‚ç‚¹
    node.Values = append(node.Values, rule)
}

// Lookup: æŸ¥æ‰¾è·¯å¾„å¯¹åº”çš„è§„åˆ™
func (t *ModuleTree) Lookup(path Ref) []*Rule {
    node := t.root
    
    for _, term := range path {
        key := term.Value
        
        child, ok := node.Children[key]
        if !ok {
            return nil
        }
        
        node = child
    }
    
    return node.Values
}
```

### 3.3 ä¾èµ–åˆ†æ

```go
// buildRuleGraph: æ„å»ºè§„åˆ™ä¾èµ–å›¾
func (c *Compiler) buildRuleGraph() error {
    c.RuleGraph = NewRuleGraph()
    
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            // è·å–è§„åˆ™çš„å®Œæ•´å¼•ç”¨
            ref := rule.Head.Reference
            
            // æ”¶é›†è§„åˆ™ä½“ä¸­çš„ä¾èµ–
            deps := c.collectDependencies(rule.Body)
            
            // æ·»åŠ åˆ°å›¾ä¸­
            c.RuleGraph.AddRule(ref, rule)
            for _, dep := range deps {
                c.RuleGraph.AddEdge(ref, dep)
            }
        }
    }
    
    return nil
}

// collectDependencies: æ”¶é›†ä¾èµ–
func (c *Compiler) collectDependencies(body Body) []Ref {
    var deps []Ref
    
    for _, expr := range body {
        // éå†è¡¨è¾¾å¼ä¸­çš„å¼•ç”¨
        vis := NewRefCollector()
        Walk(vis, expr)
        
        for _, ref := range vis.Refs() {
            // åªæ”¶é›†è§„åˆ™å¼•ç”¨ï¼ˆä¸åŒ…æ‹¬input, dataç­‰ï¼‰
            if c.isRuleRef(ref) {
                deps = append(deps, ref)
            }
        }
    }
    
    return deps
}

// isRuleRef: åˆ¤æ–­æ˜¯å¦æ˜¯è§„åˆ™å¼•ç”¨
func (c *Compiler) isRuleRef(ref Ref) bool {
    // æ£€æŸ¥æ˜¯å¦ä»¥data.å¼€å¤´
    if len(ref) > 0 {
        if v, ok := ref[0].Value.(Var); ok {
            if v == Var("data") {
                return true
            }
        }
    }
    return false
}
```

### 3.4 ç±»å‹æ£€æŸ¥

```go
// checkTypes: ç±»å‹æ£€æŸ¥
func (c *Compiler) checkTypes() error {
    checker := NewTypeChecker(c.TypeEnv, c.Modules)
    
    for _, module := range c.Modules {
        if err := checker.CheckModule(module); err != nil {
            c.Errors = append(c.Errors, err.(Errors)...)
        }
    }
    
    return nil
}

// TypeChecker: ç±»å‹æ£€æŸ¥å™¨
type TypeChecker struct {
    env     *TypeEnv         // ç±»å‹ç¯å¢ƒ
    modules map[string]*Module
    errors  Errors
}

// CheckModule: æ£€æŸ¥æ¨¡å—
func (tc *TypeChecker) CheckModule(module *Module) error {
    for _, rule := range module.Rules {
        if err := tc.checkRule(rule); err != nil {
            tc.errors = append(tc.errors, err.(Errors)...)
        }
    }
    
    if len(tc.errors) > 0 {
        return tc.errors
    }
    
    return nil
}

// checkRule: æ£€æŸ¥è§„åˆ™
func (tc *TypeChecker) checkRule(rule *Rule) error {
    // 1. æ£€æŸ¥è§„åˆ™å¤´éƒ¨
    if err := tc.checkHead(rule.Head); err != nil {
        return err
    }
    
    // 2. æ£€æŸ¥è§„åˆ™ä½“
    for _, expr := range rule.Body {
        if err := tc.checkExpr(expr); err != nil {
            return err
        }
    }
    
    return nil
}

// checkExpr: æ£€æŸ¥è¡¨è¾¾å¼
func (tc *TypeChecker) checkExpr(expr *Expr) error {
    // æ¨å¯¼è¡¨è¾¾å¼ç±»å‹
    typ, err := tc.inferExprType(expr)
    if err != nil {
        return err
    }
    
    // æ£€æŸ¥ç±»å‹ä¸€è‡´æ€§
    if typ != types.Boolean {
        return fmt.Errorf("expression must be boolean, got %v", typ)
    }
    
    return nil
}

// inferExprType: æ¨å¯¼è¡¨è¾¾å¼ç±»å‹
func (tc *TypeChecker) inferExprType(expr *Expr) (types.Type, error) {
    if expr.IsCall() {
        // å‡½æ•°è°ƒç”¨
        return tc.inferCallType(expr)
    }
    
    // å…¶ä»–è¡¨è¾¾å¼ç±»å‹
    operands := expr.Operands()
    if len(operands) == 1 {
        // å•é¡¹è¡¨è¾¾å¼
        return tc.inferTermType(operands[0])
    }
    
    // äºŒå…ƒè¡¨è¾¾å¼
    if len(operands) == 3 {
        op := operands[0]
        left := operands[1]
        right := operands[2]
        
        return tc.inferBinaryOpType(op, left, right)
    }
    
    return types.Any, nil
}

// inferTermType: æ¨å¯¼é¡¹ç±»å‹
func (tc *TypeChecker) inferTermType(term *Term) (types.Type, error) {
    switch val := term.Value.(type) {
    case Null:
        return types.Null, nil
    case Boolean:
        return types.Boolean, nil
    case Number:
        return types.Number, nil
    case String:
        return types.String, nil
    case Var:
        // æŸ¥æ‰¾å˜é‡ç±»å‹
        return tc.env.Get(val)
    case Ref:
        // æŸ¥æ‰¾å¼•ç”¨ç±»å‹
        return tc.inferRefType(val)
    case Array:
        // æ¨å¯¼æ•°ç»„å…ƒç´ ç±»å‹
        if len(val) == 0 {
            return types.NewArray(types.Any), nil
        }
        elemType, err := tc.inferTermType(val[0])
        if err != nil {
            return nil, err
        }
        return types.NewArray(elemType), nil
    case Object:
        // æ¨å¯¼å¯¹è±¡ç±»å‹
        return tc.inferObjectType(val)
    case Set:
        // æ¨å¯¼é›†åˆå…ƒç´ ç±»å‹
        if len(val) == 0 {
            return types.NewSet(types.Any), nil
        }
        elemType, err := tc.inferTermType(val[0])
        if err != nil {
            return nil, err
        }
        return types.NewSet(elemType), nil
    }
    
    return types.Any, nil
}
```

### 3.5 å®‰å…¨æ€§åˆ†æ

```go
// checkSafety: å®‰å…¨æ€§æ£€æŸ¥
func (c *Compiler) checkSafety() error {
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            if err := c.checkRuleSafety(rule); err != nil {
                c.Errors = append(c.Errors, err.(Errors)...)
            }
        }
    }
    
    return nil
}

// checkRuleSafety: æ£€æŸ¥è§„åˆ™å®‰å…¨æ€§
func (c *Compiler) checkRuleSafety(rule *Rule) error {
    // æ”¶é›†æ‰€æœ‰å˜é‡
    allVars := Vars(rule)
    
    // æ”¶é›†å®‰å…¨å˜é‡
    safeVars := c.collectSafeVars(rule.Body)
    
    // æ£€æŸ¥è§„åˆ™å¤´éƒ¨å˜é‡
    headVars := Vars(rule.Head)
    unsafeHead := headVars.Diff(safeVars)
    
    if unsafeHead.Len() > 0 {
        return fmt.Errorf("unsafe variables in rule head: %v", unsafeHead)
    }
    
    // æ£€æŸ¥è´Ÿå‘è¡¨è¾¾å¼ä¸­çš„å˜é‡
    for _, expr := range rule.Body {
        if expr.Negated {
            exprVars := Vars(expr)
            unsafeNeg := exprVars.Diff(safeVars)
            
            if unsafeNeg.Len() > 0 {
                return fmt.Errorf("unsafe variables in negation: %v", unsafeNeg)
            }
        }
    }
    
    return nil
}

// collectSafeVars: æ”¶é›†å®‰å…¨å˜é‡
func (c *Compiler) collectSafeVars(body Body) VarSet {
    safe := NewVarSet()
    
    // ç¬¬ä¸€éï¼šæ”¶é›†æ˜æ˜¾å®‰å…¨çš„å˜é‡
    for _, expr := range body {
        if expr.Negated {
            continue  // è·³è¿‡è´Ÿå‘è¡¨è¾¾å¼
        }
        
        // ç­‰å¼å·¦ä¾§çš„å˜é‡
        if expr.IsEquality() {
            terms := expr.Operands()
            left := terms[1]
            right := terms[2]
            
            // left = ground_term
            if right.IsGround() {
                collectVars(left, safe)
            }
            
            // ground_term = right
            if left.IsGround() {
                collectVars(right, safe)
            }
        }
        
        // å†…ç½®å‡½æ•°è¾“å‡ºå˜é‡
        if expr.IsCall() {
            c.checkBuiltinSafety(expr, safe)
        }
    }
    
    // ç¬¬äºŒéï¼šè¿­ä»£ç›´åˆ°ä¸åŠ¨ç‚¹
    changed := true
    for changed {
        changed = false
        oldSize := safe.Len()
        
        for _, expr := range body {
            if expr.Negated {
                continue
            }
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è¾“å…¥éƒ½å®‰å…¨
            inputs := c.getExprInputs(expr)
            if inputs.Subset(safe) {
                // æ‰€æœ‰è¾“å…¥å®‰å…¨ï¼Œè¾“å‡ºä¹Ÿå®‰å…¨
                outputs := c.getExprOutputs(expr)
                safe.Update(outputs)
            }
        }
        
        changed = (safe.Len() > oldSize)
    }
    
    return safe
}

// checkBuiltinSafety: æ£€æŸ¥å†…ç½®å‡½æ•°å®‰å…¨æ€§
func (c *Compiler) checkBuiltinSafety(expr *Expr, safe VarSet) {
    // è·å–å†…ç½®å‡½æ•°å®šä¹‰
    builtin := c.getBuiltin(expr)
    if builtin == nil {
        return
    }
    
    // æ£€æŸ¥å‡½æ•°çš„å®‰å…¨æ€§è§„åˆ™
    // ä¾‹å¦‚: count(arr, n) - å¦‚æœarrå®‰å…¨ï¼Œnä¹Ÿå®‰å…¨
    terms := expr.Operands()
    
    switch builtin.Name {
    case "count", "sum", "product", "max", "min":
        // èšåˆå‡½æ•°ï¼šè¾“å…¥å®‰å…¨ â†’ è¾“å‡ºå®‰å…¨
        if len(terms) == 2 {
            input := terms[0]
            output := terms[1]
            
            if Vars(input).Subset(safe) {
                collectVars(output, safe)
            }
        }
        
    // ... å…¶ä»–å†…ç½®å‡½æ•° ...
    }
}
```

### 3.6 é€’å½’æ£€æŸ¥

```go
// checkRecursion: æ£€æŸ¥é€’å½’
func (c *Compiler) checkRecursion() error {
    // ä½¿ç”¨è§„åˆ™å›¾æ£€æµ‹å¾ªç¯
    cycles := c.RuleGraph.FindCycles()
    
    if len(cycles) > 0 {
        for _, cycle := range cycles {
            c.Errors = append(c.Errors, &Error{
                Code:    "rego_recursion_error",
                Message: fmt.Sprintf("rule recursion detected: %v", cycle),
            })
        }
    }
    
    return nil
}

// FindCycles: æŸ¥æ‰¾å›¾ä¸­çš„å¾ªç¯
func (g *RuleGraph) FindCycles() [][]Ref {
    var cycles [][]Ref
    visited := make(map[Ref]bool)
    recStack := make(map[Ref]bool)
    var path []Ref
    
    for node := range g.nodes {
        if !visited[node] {
            if c := g.dfs(node, visited, recStack, path); len(c) > 0 {
                cycles = append(cycles, c...)
            }
        }
    }
    
    return cycles
}

// dfs: æ·±åº¦ä¼˜å…ˆæœç´¢
func (g *RuleGraph) dfs(node Ref, visited, recStack map[Ref]bool, path []Ref) [][]Ref {
    visited[node] = true
    recStack[node] = true
    path = append(path, node)
    
    var cycles [][]Ref
    
    for _, neighbor := range g.edges[node] {
        if !visited[neighbor] {
            if c := g.dfs(neighbor, visited, recStack, path); len(c) > 0 {
                cycles = append(cycles, c...)
            }
        } else if recStack[neighbor] {
            // æ‰¾åˆ°å¾ªç¯
            cycle := g.extractCycle(path, neighbor)
            cycles = append(cycles, cycle)
        }
    }
    
    recStack[node] = false
    return cycles
}

// extractCycle: æå–å¾ªç¯è·¯å¾„
func (g *RuleGraph) extractCycle(path []Ref, start Ref) []Ref {
    for i, ref := range path {
        if ref.Equal(start) {
            cycle := make([]Ref, len(path)-i)
            copy(cycle, path[i:])
            return cycle
        }
    }
    return nil
}
```

---

## 4. ASTé‡å†™

### 4.1 å±€éƒ¨å˜é‡é‡å†™

```go
// rewriteLocalVars: é‡å†™å±€éƒ¨å˜é‡
func (c *Compiler) rewriteLocalVars() error {
    rewriter := &LocalVarRewriter{
        counter: 0,
    }
    
    for filename, module := range c.Modules {
        newModule, err := Transform(rewriter, module)
        if err != nil {
            return err
        }
        c.Modules[filename] = newModule.(*Module)
    }
    
    return nil
}

// LocalVarRewriter: å±€éƒ¨å˜é‡é‡å†™å™¨
type LocalVarRewriter struct {
    counter int
    current *Rule
}

func (r *LocalVarRewriter) Transform(node interface{}) (interface{}, error) {
    rule, ok := node.(*Rule)
    if !ok {
        return node, nil
    }
    
    r.current = rule
    r.counter++
    
    // æ”¶é›†å±€éƒ¨å˜é‡
    locals := r.collectLocals(rule)
    
    // åˆ›å»ºé‡å‘½åæ˜ å°„
    mapping := make(map[Var]Var)
    for v := range locals {
        mapping[v] = Var(fmt.Sprintf("__%s_%d", v, r.counter))
    }
    
    // åº”ç”¨é‡å‘½å
    renamer := NewRenameVars(mapping)
    return Transform(renamer, rule)
}

func (r *LocalVarRewriter) collectLocals(rule *Rule) VarSet {
    allVars := Vars(rule)
    
    // æ’é™¤å…¨å±€å˜é‡
    globals := NewVarSet()
    globals.Add(Var("input"))
    globals.Add(Var("data"))
    
    // æ’é™¤å¯¼å…¥çš„å˜é‡
    if rule.Module != nil {
        for _, imp := range rule.Module.Imports {
            if imp.Alias != "" {
                globals.Add(imp.Alias)
            }
        }
    }
    
    return allVars.Diff(globals)
}
```

### 4.2 æ¨å¯¼å¼é‡å†™

```go
// rewriteComprehensionTerms: é‡å†™æ¨å¯¼å¼
func (c *Compiler) rewriteComprehensionTerms() error {
    rewriter := &ComprehensionRewriter{
        compiler: c,
        counter:  0,
    }
    
    for filename, module := range c.Modules {
        newModule, err := Transform(rewriter, module)
        if err != nil {
            return err
        }
        c.Modules[filename] = newModule.(*Module)
    }
    
    return nil
}

// ComprehensionRewriter: æ¨å¯¼å¼é‡å†™å™¨
type ComprehensionRewriter struct {
    compiler *Compiler
    counter  int
    module   *Module
}

func (r *ComprehensionRewriter) Transform(node interface{}) (interface{}, error) {
    // å¤„ç†ModuleèŠ‚ç‚¹
    if module, ok := node.(*Module); ok {
        r.module = module
        return node, nil
    }
    
    // å¤„ç†TermèŠ‚ç‚¹
    term, ok := node.(*Term)
    if !ok {
        return node, nil
    }
    
    switch comp := term.Value.(type) {
    case *ArrayComprehension:
        return r.rewriteArrayComp(comp)
    case *SetComprehension:
        return r.rewriteSetComp(comp)
    case *ObjectComprehension:
        return r.rewriteObjectComp(comp)
    }
    
    return node, nil
}

func (r *ComprehensionRewriter) rewriteArrayComp(comp *ArrayComprehension) (*Term, error) {
    // [x | x = arr[_]; x > 5]
    // â†’
    // __comp_N
    //
    // æ–°å¢è§„åˆ™:
    // __comp_N[__key] = x if {
    //     x = arr[_]
    //     x > 5
    //     __key = count(__comp_N)  # ç”Ÿæˆç´¢å¼•
    // }
    
    r.counter++
    ruleName := Var(fmt.Sprintf("__comp_%d", r.counter))
    
    // åˆ›å»ºkeyå˜é‡
    keyVar := Var("__key")
    
    // åˆ›å»ºè§„åˆ™
    rule := &Rule{
        Head: &Head{
            Name:  ruleName,
            Key:   VarTerm(keyVar.String()),
            Value: comp.Term,
        },
        Body: comp.Body,
    }
    
    // æ·»åŠ ç´¢å¼•ç”Ÿæˆè¡¨è¾¾å¼
    // __key = count(__comp_N)
    countExpr := &Expr{
        Terms: []*Term{
            RefTerm(VarTerm("count")),
            RefTerm(VarTerm(ruleName.String())),
            VarTerm(keyVar.String()),
        },
    }
    rule.Body = append(rule.Body, countExpr)
    
    // å°†è§„åˆ™æ·»åŠ åˆ°æ¨¡å—
    r.module.Rules = append(r.module.Rules, rule)
    
    // è¿”å›å¯¹è§„åˆ™çš„å¼•ç”¨
    return RefTerm(VarTerm(ruleName.String())), nil
}
```

### 4.3 åŠ¨æ€é¡¹é‡å†™

```go
// rewriteDynamicTerms: é‡å†™åŠ¨æ€é¡¹
func (c *Compiler) rewriteDynamicTerms() error {
    rewriter := &DynamicTermRewriter{
        counter: 0,
    }
    
    for filename, module := range c.Modules {
        newModule, err := Transform(rewriter, module)
        if err != nil {
            return err
        }
        c.Modules[filename] = newModule.(*Module)
    }
    
    return nil
}

// DynamicTermRewriter: åŠ¨æ€é¡¹é‡å†™å™¨
type DynamicTermRewriter struct {
    counter int
}

func (r *DynamicTermRewriter) Transform(node interface{}) (interface{}, error) {
    body, ok := node.(Body)
    if !ok {
        return node, nil
    }
    
    // å¯¹æ¯ä¸ªè¡¨è¾¾å¼è¿›è¡Œé‡å†™
    newBody := make(Body, 0, len(body))
    
    for _, expr := range body {
        // æå–åŠ¨æ€é¡¹
        dynTerms := r.extractDynamicTerms(expr)
        
        // ä¸ºæ¯ä¸ªåŠ¨æ€é¡¹åˆ›å»ºèµ‹å€¼
        for _, term := range dynTerms {
            r.counter++
            tmpVar := Var(fmt.Sprintf("__dyn_%d", r.counter))
            
            // åˆ›å»ºèµ‹å€¼è¡¨è¾¾å¼: __dyn_N = <dynamic_term>
            assign := Equality.Expr(VarTerm(tmpVar.String()), term)
            newBody = append(newBody, assign)
            
            // æ›¿æ¢åŸè¡¨è¾¾å¼ä¸­çš„åŠ¨æ€é¡¹ä¸ºå˜é‡
            expr = r.replaceTerm(expr, term, VarTerm(tmpVar.String()))
        }
        
        newBody = append(newBody, expr)
    }
    
    return newBody, nil
}

func (r *DynamicTermRewriter) extractDynamicTerms(expr *Expr) []*Term {
    var dynTerms []*Term
    
    for _, term := range expr.Operands() {
        if r.isDynamic(term) {
            dynTerms = append(dynTerms, term)
        }
    }
    
    return dynTerms
}

func (r *DynamicTermRewriter) isDynamic(term *Term) bool {
    // å‡½æ•°è°ƒç”¨å’Œæ¨å¯¼å¼æ˜¯åŠ¨æ€çš„
    switch term.Value.(type) {
    case Call, *ArrayComprehension, *SetComprehension, *ObjectComprehension:
        return true
    }
    return false
}
```

### 4.4 å¼•ç”¨é‡å†™

```go
// rewriteRefsInHead: é‡å†™è§„åˆ™å¤´éƒ¨çš„å¼•ç”¨
func (c *Compiler) rewriteRefsInHead() error {
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            if err := c.rewriteRuleHead(rule); err != nil {
                return err
            }
        }
    }
    
    return nil
}

func (c *Compiler) rewriteRuleHead(rule *Rule) error {
    head := rule.Head
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å¤æ‚å¼•ç”¨
    // ä¾‹å¦‚: data.users[id].name = value
    if !c.isComplexRef(head.Name) {
        return nil
    }
    
    // å°†å¤æ‚å¼•ç”¨æ‹†åˆ†
    // data.users[id].name = value
    // â†’
    // __ref = data.users[id]
    // __ref.name = value
    
    // ... å®ç°ç•¥ ...
    
    return nil
}
```

---

## 5. æŸ¥è¯¢è§„åˆ’

### 5.1 è§„åˆ’å™¨æ¶æ„

```go
// Planner: æŸ¥è¯¢è§„åˆ’å™¨
type Planner struct {
    compiler *Compiler
    query    Body
    indices  *Indices
}

// Plan: æ‰§è¡Œè®¡åˆ’
type Plan struct {
    Steps []PlanStep  // æ‰§è¡Œæ­¥éª¤
    Cost  int         // ä¼°è®¡æˆæœ¬
}

// PlanStep: æ‰§è¡Œæ­¥éª¤
type PlanStep struct {
    Expr      *Expr     // è¡¨è¾¾å¼
    Index     *Index    // ä½¿ç”¨çš„ç´¢å¼•
    Estimated int       // ä¼°è®¡ç»“æœæ•°
}

// NewPlanner: åˆ›å»ºè§„åˆ’å™¨
func NewPlanner(c *Compiler) *Planner {
    return &Planner{
        compiler: c,
        indices:  c.indices,
    }
}

// Plan: ç”ŸæˆæŸ¥è¯¢è®¡åˆ’
func (p *Planner) Plan(query Body) (*Plan, error) {
    // 1. åˆ†ææŸ¥è¯¢
    analysis := p.analyzeQuery(query)
    
    // 2. é€‰æ‹©ç´¢å¼•
    indices := p.selectIndices(analysis)
    
    // 3. æ’åºè¡¨è¾¾å¼
    ordered := p.orderExprs(query, indices)
    
    // 4. ä¼°è®¡æˆæœ¬
    cost := p.estimateCost(ordered)
    
    return &Plan{
        Steps: ordered,
        Cost:  cost,
    }, nil
}
```

### 5.2 ç´¢å¼•æ„å»º

```go
// buildRuleIndex: æ„å»ºè§„åˆ™ç´¢å¼•
func (c *Compiler) buildRuleIndex() error {
    c.RuleIndex = NewRuleIndex()
    
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            // è·å–è§„åˆ™çš„å¼•ç”¨è·¯å¾„
            ref := rule.Head.Reference
            
            // æ·»åŠ åˆ°ç´¢å¼•
            c.RuleIndex.Add(ref, rule)
            
            // å¦‚æœæ˜¯éƒ¨åˆ†è§„åˆ™ï¼Œç´¢å¼•key
            if rule.Head.Key != nil {
                c.indexPartialRule(rule)
            }
        }
    }
    
    return nil
}

// RuleIndex: è§„åˆ™ç´¢å¼•
type RuleIndex struct {
    rules map[string][]*Rule  // è·¯å¾„ â†’ è§„åˆ™åˆ—è¡¨
    keys  map[string]*KeyIndex  // éƒ¨åˆ†è§„åˆ™çš„keyç´¢å¼•
}

// KeyIndex: Keyç´¢å¼•
type KeyIndex struct {
    ground  map[Value]*Rule    // ground key â†’ è§„åˆ™
    dynamic []*Rule            // åŠ¨æ€keyçš„è§„åˆ™
}

// Add: æ·»åŠ è§„åˆ™åˆ°ç´¢å¼•
func (idx *RuleIndex) Add(ref Ref, rule *Rule) {
    path := ref.String()
    idx.rules[path] = append(idx.rules[path], rule)
}

// Lookup: æŸ¥æ‰¾è§„åˆ™
func (idx *RuleIndex) Lookup(ref Ref) []*Rule {
    path := ref.String()
    return idx.rules[path]
}

// indexPartialRule: ç´¢å¼•éƒ¨åˆ†è§„åˆ™
func (c *Compiler) indexPartialRule(rule *Rule) {
    ref := rule.Head.Reference
    key := rule.Head.Key
    
    if key.IsGround() {
        // Ground keyï¼Œç›´æ¥ç´¢å¼•
        c.RuleIndex.keys[ref.String()].ground[key.Value] = rule
    } else {
        // åŠ¨æ€key
        c.RuleIndex.keys[ref.String()].dynamic = append(
            c.RuleIndex.keys[ref.String()].dynamic,
            rule,
        )
    }
}
```

### 5.3 è§„åˆ™æ’åº

```go
// orderExprs: æ’åºè¡¨è¾¾å¼
func (p *Planner) orderExprs(body Body, indices map[*Expr]*Index) []PlanStep {
    // ä½¿ç”¨è´ªå¿ƒç®—æ³•æ’åºè¡¨è¾¾å¼
    // ä¼˜å…ˆæ‰§è¡Œï¼š
    // 1. groundè¡¨è¾¾å¼ï¼ˆç¡®å®šå€¼ï¼‰
    // 2. æœ‰ç´¢å¼•æ”¯æŒçš„è¡¨è¾¾å¼
    // 3. è¾“å‡ºè¾ƒå°‘çš„è¡¨è¾¾å¼
    
    steps := make([]PlanStep, 0, len(body))
    remaining := make([]*Expr, len(body))
    copy(remaining, body)
    
    safe := NewVarSet()  // å·²çŸ¥çš„å®‰å…¨å˜é‡
    
    for len(remaining) > 0 {
        // é€‰æ‹©ä¸‹ä¸€ä¸ªè¡¨è¾¾å¼
        best := p.selectBest(remaining, safe, indices)
        
        if best == -1 {
            // æ— æ³•ç»§ç»­ï¼ˆä¸åº”è¯¥å‘ç”Ÿï¼‰
            break
        }
        
        expr := remaining[best]
        
        // æ·»åŠ åˆ°è®¡åˆ’
        steps = append(steps, PlanStep{
            Expr:      expr,
            Index:     indices[expr],
            Estimated: p.estimate(expr, safe),
        })
        
        // æ›´æ–°å®‰å…¨å˜é‡
        safe.Update(p.getExprOutputs(expr))
        
        // ä»å‰©ä½™åˆ—è¡¨ä¸­ç§»é™¤
        remaining = append(remaining[:best], remaining[best+1:]...)
    }
    
    return steps
}

// selectBest: é€‰æ‹©æœ€ä¼˜è¡¨è¾¾å¼
func (p *Planner) selectBest(exprs []*Expr, safe VarSet, indices map[*Expr]*Index) int {
    bestIdx := -1
    bestScore := -1
    
    for i, expr := range exprs {
        score := p.scoreExpr(expr, safe, indices[expr])
        
        if score > bestScore {
            bestScore = score
            bestIdx = i
        }
    }
    
    return bestIdx
}

// scoreExpr: è¯„åˆ†è¡¨è¾¾å¼
func (p *Planner) scoreExpr(expr *Expr, safe VarSet, index *Index) int {
    score := 0
    
    // 1. Groundè¡¨è¾¾å¼ä¼˜å…ˆ
    if expr.IsGround() {
        score += 1000
    }
    
    // 2. æ‰€æœ‰è¾“å…¥éƒ½å®‰å…¨
    inputs := p.getExprInputs(expr)
    if inputs.Subset(safe) {
        score += 500
    }
    
    // 3. æœ‰ç´¢å¼•æ”¯æŒ
    if index != nil {
        score += 300
    }
    
    // 4. ä¼°è®¡è¾“å‡ºå°‘
    estimated := p.estimate(expr, safe)
    score += (1000 - estimated)  // è¾“å‡ºè¶Šå°‘è¶Šå¥½
    
    return score
}
```

### 5.4 éƒ¨åˆ†æ±‚å€¼

```go
// PartialEval: éƒ¨åˆ†æ±‚å€¼
type PartialEval struct {
    compiler *Compiler
    unknowns []string   // æœªçŸ¥è¾“å…¥
}

// Eval: æ‰§è¡Œéƒ¨åˆ†æ±‚å€¼
func (pe *PartialEval) Eval(query Body) (Body, error) {
    // éƒ¨åˆ†æ±‚å€¼å°†å·²çŸ¥çš„è¾“å…¥æ±‚å€¼ï¼Œä¿ç•™æœªçŸ¥éƒ¨åˆ†
    
    result := make(Body, 0)
    
    for _, expr := range query {
        // å°è¯•æ±‚å€¼è¡¨è¾¾å¼
        val, err := pe.evalExpr(expr)
        
        if err != nil {
            // æ— æ³•æ±‚å€¼ï¼Œä¿ç•™åŸè¡¨è¾¾å¼
            result = append(result, expr)
            continue
        }
        
        // æ£€æŸ¥ç»“æœ
        if val == BooleanTerm(true) {
            // æ’çœŸï¼Œå¿½ç•¥
            continue
        } else if val == BooleanTerm(false) {
            // æ’å‡ï¼Œæ•´ä¸ªæŸ¥è¯¢å¤±è´¥
            return nil, fmt.Errorf("partial eval: contradiction")
        } else {
            // éƒ¨åˆ†æ±‚å€¼ç»“æœ
            result = append(result, &Expr{Terms: val})
        }
    }
    
    return result, nil
}

// evalExpr: æ±‚å€¼è¡¨è¾¾å¼
func (pe *PartialEval) evalExpr(expr *Expr) (*Term, error) {
    // æ£€æŸ¥æ˜¯å¦ä¾èµ–æœªçŸ¥è¾“å…¥
    if pe.dependsOnUnknowns(expr) {
        return nil, fmt.Errorf("depends on unknowns")
    }
    
    // æ‰€æœ‰è¾“å…¥éƒ½æ˜¯å·²çŸ¥çš„ï¼Œå¯ä»¥æ±‚å€¼
    return pe.evaluate(expr)
}

// dependsOnUnknowns: æ£€æŸ¥æ˜¯å¦ä¾èµ–æœªçŸ¥è¾“å…¥
func (pe *PartialEval) dependsOnUnknowns(expr *Expr) bool {
    refs := collectRefs(expr)
    
    for _, ref := range refs {
        for _, unknown := range pe.unknowns {
            if strings.HasPrefix(ref.String(), unknown) {
                return true
            }
        }
    }
    
    return false
}
```

---

(ç”±äºç¯‡å¹…é™åˆ¶ï¼Œè¿™é‡Œå±•ç¤ºç¼–è¯‘å™¨å®ç°çš„æ ¸å¿ƒéƒ¨åˆ†ã€‚å®Œæ•´æ–‡æ¡£å°†åŒ…å«ç±»å‹ç³»ç»Ÿã€é”™è¯¯å¤„ç†ã€ä¼˜åŒ–æŠ€æœ¯ã€IRç”Ÿæˆç­‰è¯¦ç»†å†…å®¹ã€‚)

è®©æˆ‘ç»§ç»­æ·»åŠ å‰©ä½™éƒ¨åˆ†...

---

## 6. ç±»å‹ç³»ç»Ÿå®ç°

### 6.1 ç±»å‹å®šä¹‰

```go
// Type: ç±»å‹æ¥å£
type Type interface {
    String() string
    Compare(Type) int
}

// åŸºç¡€ç±»å‹
var (
    Any     = &anyType{}
    Null    = &nullType{}
    Boolean = &booleanType{}
    Number  = &numberType{}
    String  = &stringType{}
)

// å¤åˆç±»å‹
type ArrayType struct {
    Elem Type  // å…ƒç´ ç±»å‹
}

type ObjectType struct {
    Static  map[string]Type  // é™æ€é”®
    Dynamic *DynamicType     // åŠ¨æ€é”®ï¼ˆå¯é€‰ï¼‰
}

type SetType struct {
    Elem Type  // å…ƒç´ ç±»å‹
}

// å‡½æ•°ç±»å‹
type FunctionType struct {
    Args   []Type  // å‚æ•°ç±»å‹
    Result Type    // è¿”å›ç±»å‹
}
```

### 6.2 ç±»å‹æ¨å¯¼

è¯¦ç»†å®ç°ç•¥...

---

## é™„å½•

### A. ç¼–è¯‘å™¨é€‰é¡¹

```go
// CompilerOptions: ç¼–è¯‘å™¨é€‰é¡¹
type CompilerOptions struct {
    // èƒ½åŠ›é™åˆ¶
    Capabilities *Capabilities
    
    // ä¼˜åŒ–çº§åˆ«
    OptimizationLevel int  // 0: æ— ä¼˜åŒ–, 1: åŸºæœ¬, 2: å®Œå…¨
    
    // æ˜¯å¦å¯ç”¨ä¸¥æ ¼æ¨¡å¼
    Strict bool
    
    // æ˜¯å¦ç”Ÿæˆè°ƒè¯•ä¿¡æ¯
    Debug bool
    
    // è‡ªå®šä¹‰é˜¶æ®µ
    Stages []func(*Compiler) error
}
```

### B. ç¼–è¯‘é˜¶æ®µæ¸…å•

å®Œæ•´çš„ç¼–è¯‘é˜¶æ®µåˆ—è¡¨...

### C. æ€§èƒ½è°ƒä¼˜æŒ‡å—

1. **ä½¿ç”¨å¢é‡ç¼–è¯‘**
2. **å¯ç”¨ç¼–è¯‘ç¼“å­˜**
3. **ä¼˜åŒ–æ¨¡å—ç»“æ„**
4. **å‡å°‘è§„åˆ™å¤æ‚åº¦**

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
**ç»´æŠ¤è€…**: OPAæŠ€æœ¯æ–‡æ¡£é¡¹ç›®  
**åé¦ˆ**: æ¬¢è¿é€šè¿‡GitHub Issuesæä¾›å»ºè®®

**ç›¸å…³é˜…è¯»**:

- [ASTæ„å»ºä¸è½¬æ¢](10.3-ASTæ„å»ºä¸è½¬æ¢.md) - ASTæ“ä½œ
- [Top-Downæ±‚å€¼å™¨æºç ](10.5-Top-Downæ±‚å€¼å™¨æºç .md) - æ±‚å€¼å™¨
- [ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–](../06-å½¢å¼åŒ–è¯æ˜/06.5-ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–.md) - ç±»å‹ç†è®º
