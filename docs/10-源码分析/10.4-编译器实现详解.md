# 编译器实现详解

> **文档类型**: 源码实现分析  
> **核心模块**: `compile/compile.go`, `ast/compile.go`, `internal/compiler/`  
> **适用读者**: 编译器开发者、语言设计者、性能优化工程师  
> **先修知识**: [AST构建与转换](10.3-AST构建与转换.md)、编译原理  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 2.4 - 编译器分析  
> **OPA版本**: v0.68.0

---

## 🎯 实现分析说明

> **本文档目标**:
>
> - ✅ 深入理解OPA编译器的完整架构
> - ✅ 掌握各个编译阶段的实现原理
> - ✅ 学习类型检查和安全性分析技术
> - ✅ 理解查询规划和优化策略
>
> **技术亮点**:
>
> - **多阶段编译**: 模块化的编译管道
> - **增量编译**: 只重新编译变更部分
> - **静态分析**: 编译时错误检测
> - **查询优化**: 智能执行计划
>
> **实战价值**:
>
> - 理解Rego编译过程
> - 实现自定义优化
> - 性能调优
> - 工具开发

---

## 目录

- [编译器实现详解](#编译器实现详解)
  - [🎯 实现分析说明](#-实现分析说明)
  - [目录](#目录)
  - [1. 编译器架构](#1-编译器架构)
    - [1.1 整体设计](#11-整体设计)
    - [1.2 编译阶段](#12-编译阶段)
    - [1.3 数据流](#13-数据流)
  - [2. Compiler核心结构](#2-compiler核心结构)
    - [2.1 Compiler类型](#21-compiler类型)
    - [2.2 创建与初始化](#22-创建与初始化)
    - [2.3 编译入口](#23-编译入口)
  - [3. 编译阶段详解](#3-编译阶段详解)
    - [3.1 模块解析](#31-模块解析)
    - [3.2 模块树构建](#32-模块树构建)
    - [3.3 依赖分析](#33-依赖分析)
    - [3.4 类型检查](#34-类型检查)
    - [3.5 安全性分析](#35-安全性分析)
    - [3.6 递归检查](#36-递归检查)
  - [4. AST重写](#4-ast重写)
    - [4.1 局部变量重写](#41-局部变量重写)
    - [4.2 推导式重写](#42-推导式重写)
    - [4.3 动态项重写](#43-动态项重写)
    - [4.4 引用重写](#44-引用重写)
  - [5. 查询规划](#5-查询规划)
    - [5.1 规划器架构](#51-规划器架构)
    - [5.2 索引构建](#52-索引构建)
    - [5.3 规则排序](#53-规则排序)
    - [5.4 部分求值](#54-部分求值)
  - [6. 类型系统实现](#6-类型系统实现)
    - [6.1 类型定义](#61-类型定义)
    - [6.2 类型推导](#62-类型推导)
  - [附录](#附录)
    - [A. 编译器选项](#a-编译器选项)
    - [B. 编译阶段清单](#b-编译阶段清单)
    - [C. 性能调优指南](#c-性能调优指南)

---

## 1. 编译器架构

### 1.1 整体设计

OPA编译器采用**多阶段管道**架构：

```text
┌──────────────────────────────────────────────────┐
│              输入：Rego模块集合                  │
└──────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────┐
│  阶段1: 解析与构建 (Parsing & Building)          │
│  ┌────────────────────────────────────────────┐ │
│  │  • 解析Rego源码 → AST                      │ │
│  │  • 构建模块树                               │ │
│  │  • 收集导入和导出                           │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────┐
│  阶段2: 语义分析 (Semantic Analysis)             │
│  ┌────────────────────────────────────────────┐ │
│  │  • 类型检查                                 │ │
│  │  • 安全性分析                               │ │
│  │  • 递归检查                                 │ │
│  │  • 依赖分析                                 │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────┐
│  阶段3: AST重写 (Rewriting)                      │
│  ┌────────────────────────────────────────────┐ │
│  │  • 局部变量重写                             │ │
│  │  • 推导式展开                               │ │
│  │  • 动态项提取                               │ │
│  │  • 引用规范化                               │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────┐
│  阶段4: 优化 (Optimization)                      │
│  ┌────────────────────────────────────────────┐ │
│  │  • 查询规划                                 │ │
│  │  • 索引构建                                 │ │
│  │  • 部分求值                                 │ │
│  │  • 规则内联                                 │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────┐
│  阶段5: 代码生成 (Code Generation - 可选)         │
│  ┌────────────────────────────────────────────┐  │
│  │  • 生成IR                                   │ │
│  │  • WASM编译                                 │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────┐
│          输出：编译后的策略 Bundle                 │
└──────────────────────────────────────────────────┘
```

### 1.2 编译阶段

**编译阶段枚举**:

```go
// CompilerStage: 编译阶段类型
type CompilerStage string

const (
    // 解析阶段
    StageResolveRefs       CompilerStage = "ResolveRefs"
    StageCheckRecursion    CompilerStage = "CheckRecursion"
    
    // 重写阶段
    StageRewriteLocalVars  CompilerStage = "RewriteLocalVars"
    StageRewriteExprTerms  CompilerStage = "RewriteExprTerms"
    StageRewriteComprehensionTerms CompilerStage = "RewriteComprehensionTerms"
    StageRewriteRefsInHead CompilerStage = "RewriteRefsInHead"
    StageRewriteDynamicTerms CompilerStage = "RewriteDynamicTerms"
    StageRewriteEquals     CompilerStage = "RewriteEquals"
    StageRewriteWith       CompilerStage = "RewriteWith"
    
    // 检查阶段
    StageCheckDuplicateImports CompilerStage = "CheckDuplicateImports"
    StageCheckSafety         CompilerStage = "CheckSafety"
    StageCheckUnsafeBuiltins CompilerStage = "CheckUnsafeBuiltins"
    StageCheckTypes          CompilerStage = "CheckTypes"
    
    // 优化阶段
    StageBuildComprehensionIndex CompilerStage = "BuildComprehensionIndex"
    StageBuildRuleIndex        CompilerStage = "BuildRuleIndex"
)
```

### 1.3 数据流

**编译过程中的数据转换**:

```text
Rego源码 (*.rego)
      ↓
  AST (未编译)
      ↓
编译器处理
      ↓
编译后AST
      ├→ 规则图 (Rule Graph)
      ├→ 类型环境 (Type Environment)
      ├→ 索引 (Indices)
      └→ 元数据 (Metadata)
      ↓
  Bundle / IR
```

---

## 2. Compiler核心结构

### 2.1 Compiler类型

```go
// Compiler: OPA编译器
type Compiler struct {
    // 输入
    Modules      map[string]*Module  // 模块集合 (文件名 → 模块)
    ModuleTree   *ModuleTree         // 模块树
    
    // 分析结果
    RuleGraph    *graph.Graph        // 规则依赖图
    TypeEnv      *TypeEnv            // 类型环境
    
    // 索引
    RuleIndex    *RuleIndex          // 规则索引
    ComprehensionIndex *ComprehensionIndex  // 推导式索引
    
    // 配置
    stages       []func(*Compiler) error  // 编译阶段
    capabilities *Capabilities       // 能力限制
    
    // 错误
    Errors       Errors              // 编译错误
    warnings     []*Warning          // 警告
    
    // 元数据
    metadata     *Metadata           // 编译元数据
    
    // 状态
    compiled     bool                // 是否已编译
    
    // 缓存
    cache        *CompilerCache      // 编译缓存
}
```

**ModuleTree类型**:

```go
// ModuleTree: 模块树（命名空间树）
type ModuleTree struct {
    root *TreeNode
}

// TreeNode: 树节点
type TreeNode struct {
    Key      Value           // 路径键
    Children map[Value]*TreeNode  // 子节点
    Values   []*Rule         // 此路径下的规则
    Hide     bool            // 是否隐藏
}

// 示例:
// package a.b.c
// package a.b.d
//
// 树结构:
//   data
//     └── a
//         └── b
//             ├── c (规则...)
//             └── d (规则...)
```

**RuleGraph类型**:

```go
// RuleGraph: 规则依赖图
type RuleGraph struct {
    nodes map[Ref]*RuleNode     // 规则节点
    edges map[Ref][]Ref         // 依赖边
}

// RuleNode: 规则节点
type RuleNode struct {
    Ref   Ref      // 规则引用
    Rules []*Rule  // 规则列表
}
```

### 2.2 创建与初始化

```go
// NewCompiler: 创建编译器
func NewCompiler() *Compiler {
    c := &Compiler{
        Modules:   make(map[string]*Module),
        Errors:    nil,
        stages:    getDefaultStages(),
        TypeEnv:   NewTypeEnv(),
        cache:     NewCompilerCache(),
    }
    return c
}

// getDefaultStages: 获取默认编译阶段
func getDefaultStages() []func(*Compiler) error {
    return []func(*Compiler) error{
        // 1. 解析与构建
        (*Compiler).buildModuleTree,
        (*Compiler).resolveAllRefs,
        
        // 2. 检查
        (*Compiler).checkRecursion,
        (*Compiler).checkDuplicateImports,
        
        // 3. 重写
        (*Compiler).rewriteLocalVars,
        (*Compiler).rewriteExprTerms,
        (*Compiler).rewriteComprehensionTerms,
        (*Compiler).rewriteRefsInHead,
        (*Compiler).rewriteDynamicTerms,
        (*Compiler).rewriteEquals,
        (*Compiler).rewriteWith,
        
        // 4. 安全性和类型
        (*Compiler).checkSafety,
        (*Compiler).checkUnsafeBuiltins,
        (*Compiler).checkTypes,
        
        // 5. 索引
        (*Compiler).buildRuleGraph,
        (*Compiler).buildRuleIndex,
        (*Compiler).buildComprehensionIndex,
    }
}

// WithStages: 自定义编译阶段
func (c *Compiler) WithStages(stages ...func(*Compiler) error) *Compiler {
    c.stages = stages
    return c
}

// WithCapabilities: 设置能力限制
func (c *Compiler) WithCapabilities(caps *Capabilities) *Compiler {
    c.capabilities = caps
    return c
}
```

### 2.3 编译入口

```go
// Compile: 编译所有模块
func (c *Compiler) Compile(modules map[string]*Module) error {
    // 设置模块
    c.Modules = modules
    
    // 执行编译阶段
    for _, stage := range c.stages {
        if err := stage(c); err != nil {
            return err
        }
        
        // 如果有错误，停止编译
        if len(c.Errors) > 0 {
            return c.Errors
        }
    }
    
    c.compiled = true
    return nil
}

// QueryCompiler: 查询编译器（用于ad-hoc查询）
type QueryCompiler struct {
    compiler *Compiler
    query    Body
}

// NewQueryCompiler: 创建查询编译器
func (c *Compiler) QueryCompiler() *QueryCompiler {
    return &QueryCompiler{
        compiler: c,
    }
}

// Compile: 编译查询
func (qc *QueryCompiler) Compile(query Body) error {
    qc.query = query
    
    // 应用必要的重写
    if err := qc.rewriteQuery(); err != nil {
        return err
    }
    
    // 类型检查
    if err := qc.checkQueryTypes(); err != nil {
        return err
    }
    
    // 安全性检查
    if err := qc.checkQuerySafety(); err != nil {
        return err
    }
    
    return nil
}
```

---

## 3. 编译阶段详解

### 3.1 模块解析

**ParseModule**:

```go
// ParseModule: 解析单个模块
func ParseModule(filename string, source []byte) (*Module, error) {
    // 创建scanner
    s := newScanner(source)
    
    // 创建parser
    p := newParser(s)
    
    // 解析
    module := p.parseModule()
    
    // 检查错误
    if len(p.errors) > 0 {
        return nil, p.errors
    }
    
    // 设置元信息
    module.Package.Location = &Location{
        File: filename,
    }
    
    return module, nil
}

// ParseModules: 批量解析模块
func ParseModules(files map[string][]byte) (map[string]*Module, error) {
    modules := make(map[string]*Module)
    var errors Errors
    
    for filename, source := range files {
        module, err := ParseModule(filename, source)
        if err != nil {
            errors = append(errors, err.(Errors)...)
            continue
        }
        modules[filename] = module
    }
    
    if len(errors) > 0 {
        return nil, errors
    }
    
    return modules, nil
}
```

### 3.2 模块树构建

```go
// buildModuleTree: 构建模块树
func (c *Compiler) buildModuleTree() error {
    c.ModuleTree = NewModuleTree()
    
    for _, module := range c.Modules {
        // 将模块插入树中
        path := module.Package.Path
        
        // 插入规则
        for _, rule := range module.Rules {
            fullPath := append(path, rule.Head.Name)
            c.ModuleTree.Insert(fullPath, rule)
        }
    }
    
    return nil
}

// Insert: 插入规则到树中
func (t *ModuleTree) Insert(path Ref, rule *Rule) {
    node := t.root
    
    for _, term := range path {
        key := term.Value
        
        // 查找或创建子节点
        child, ok := node.Children[key]
        if !ok {
            child = &TreeNode{
                Key:      key,
                Children: make(map[Value]*TreeNode),
                Values:   []*Rule{},
            }
            node.Children[key] = child
        }
        
        node = child
    }
    
    // 添加规则到叶节点
    node.Values = append(node.Values, rule)
}

// Lookup: 查找路径对应的规则
func (t *ModuleTree) Lookup(path Ref) []*Rule {
    node := t.root
    
    for _, term := range path {
        key := term.Value
        
        child, ok := node.Children[key]
        if !ok {
            return nil
        }
        
        node = child
    }
    
    return node.Values
}
```

### 3.3 依赖分析

```go
// buildRuleGraph: 构建规则依赖图
func (c *Compiler) buildRuleGraph() error {
    c.RuleGraph = NewRuleGraph()
    
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            // 获取规则的完整引用
            ref := rule.Head.Reference
            
            // 收集规则体中的依赖
            deps := c.collectDependencies(rule.Body)
            
            // 添加到图中
            c.RuleGraph.AddRule(ref, rule)
            for _, dep := range deps {
                c.RuleGraph.AddEdge(ref, dep)
            }
        }
    }
    
    return nil
}

// collectDependencies: 收集依赖
func (c *Compiler) collectDependencies(body Body) []Ref {
    var deps []Ref
    
    for _, expr := range body {
        // 遍历表达式中的引用
        vis := NewRefCollector()
        Walk(vis, expr)
        
        for _, ref := range vis.Refs() {
            // 只收集规则引用（不包括input, data等）
            if c.isRuleRef(ref) {
                deps = append(deps, ref)
            }
        }
    }
    
    return deps
}

// isRuleRef: 判断是否是规则引用
func (c *Compiler) isRuleRef(ref Ref) bool {
    // 检查是否以data.开头
    if len(ref) > 0 {
        if v, ok := ref[0].Value.(Var); ok {
            if v == Var("data") {
                return true
            }
        }
    }
    return false
}
```

### 3.4 类型检查

```go
// checkTypes: 类型检查
func (c *Compiler) checkTypes() error {
    checker := NewTypeChecker(c.TypeEnv, c.Modules)
    
    for _, module := range c.Modules {
        if err := checker.CheckModule(module); err != nil {
            c.Errors = append(c.Errors, err.(Errors)...)
        }
    }
    
    return nil
}

// TypeChecker: 类型检查器
type TypeChecker struct {
    env     *TypeEnv         // 类型环境
    modules map[string]*Module
    errors  Errors
}

// CheckModule: 检查模块
func (tc *TypeChecker) CheckModule(module *Module) error {
    for _, rule := range module.Rules {
        if err := tc.checkRule(rule); err != nil {
            tc.errors = append(tc.errors, err.(Errors)...)
        }
    }
    
    if len(tc.errors) > 0 {
        return tc.errors
    }
    
    return nil
}

// checkRule: 检查规则
func (tc *TypeChecker) checkRule(rule *Rule) error {
    // 1. 检查规则头部
    if err := tc.checkHead(rule.Head); err != nil {
        return err
    }
    
    // 2. 检查规则体
    for _, expr := range rule.Body {
        if err := tc.checkExpr(expr); err != nil {
            return err
        }
    }
    
    return nil
}

// checkExpr: 检查表达式
func (tc *TypeChecker) checkExpr(expr *Expr) error {
    // 推导表达式类型
    typ, err := tc.inferExprType(expr)
    if err != nil {
        return err
    }
    
    // 检查类型一致性
    if typ != types.Boolean {
        return fmt.Errorf("expression must be boolean, got %v", typ)
    }
    
    return nil
}

// inferExprType: 推导表达式类型
func (tc *TypeChecker) inferExprType(expr *Expr) (types.Type, error) {
    if expr.IsCall() {
        // 函数调用
        return tc.inferCallType(expr)
    }
    
    // 其他表达式类型
    operands := expr.Operands()
    if len(operands) == 1 {
        // 单项表达式
        return tc.inferTermType(operands[0])
    }
    
    // 二元表达式
    if len(operands) == 3 {
        op := operands[0]
        left := operands[1]
        right := operands[2]
        
        return tc.inferBinaryOpType(op, left, right)
    }
    
    return types.Any, nil
}

// inferTermType: 推导项类型
func (tc *TypeChecker) inferTermType(term *Term) (types.Type, error) {
    switch val := term.Value.(type) {
    case Null:
        return types.Null, nil
    case Boolean:
        return types.Boolean, nil
    case Number:
        return types.Number, nil
    case String:
        return types.String, nil
    case Var:
        // 查找变量类型
        return tc.env.Get(val)
    case Ref:
        // 查找引用类型
        return tc.inferRefType(val)
    case Array:
        // 推导数组元素类型
        if len(val) == 0 {
            return types.NewArray(types.Any), nil
        }
        elemType, err := tc.inferTermType(val[0])
        if err != nil {
            return nil, err
        }
        return types.NewArray(elemType), nil
    case Object:
        // 推导对象类型
        return tc.inferObjectType(val)
    case Set:
        // 推导集合元素类型
        if len(val) == 0 {
            return types.NewSet(types.Any), nil
        }
        elemType, err := tc.inferTermType(val[0])
        if err != nil {
            return nil, err
        }
        return types.NewSet(elemType), nil
    }
    
    return types.Any, nil
}
```

### 3.5 安全性分析

```go
// checkSafety: 安全性检查
func (c *Compiler) checkSafety() error {
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            if err := c.checkRuleSafety(rule); err != nil {
                c.Errors = append(c.Errors, err.(Errors)...)
            }
        }
    }
    
    return nil
}

// checkRuleSafety: 检查规则安全性
func (c *Compiler) checkRuleSafety(rule *Rule) error {
    // 收集所有变量
    allVars := Vars(rule)
    
    // 收集安全变量
    safeVars := c.collectSafeVars(rule.Body)
    
    // 检查规则头部变量
    headVars := Vars(rule.Head)
    unsafeHead := headVars.Diff(safeVars)
    
    if unsafeHead.Len() > 0 {
        return fmt.Errorf("unsafe variables in rule head: %v", unsafeHead)
    }
    
    // 检查负向表达式中的变量
    for _, expr := range rule.Body {
        if expr.Negated {
            exprVars := Vars(expr)
            unsafeNeg := exprVars.Diff(safeVars)
            
            if unsafeNeg.Len() > 0 {
                return fmt.Errorf("unsafe variables in negation: %v", unsafeNeg)
            }
        }
    }
    
    return nil
}

// collectSafeVars: 收集安全变量
func (c *Compiler) collectSafeVars(body Body) VarSet {
    safe := NewVarSet()
    
    // 第一遍：收集明显安全的变量
    for _, expr := range body {
        if expr.Negated {
            continue  // 跳过负向表达式
        }
        
        // 等式左侧的变量
        if expr.IsEquality() {
            terms := expr.Operands()
            left := terms[1]
            right := terms[2]
            
            // left = ground_term
            if right.IsGround() {
                collectVars(left, safe)
            }
            
            // ground_term = right
            if left.IsGround() {
                collectVars(right, safe)
            }
        }
        
        // 内置函数输出变量
        if expr.IsCall() {
            c.checkBuiltinSafety(expr, safe)
        }
    }
    
    // 第二遍：迭代直到不动点
    changed := true
    for changed {
        changed = false
        oldSize := safe.Len()
        
        for _, expr := range body {
            if expr.Negated {
                continue
            }
            
            // 检查是否所有输入都安全
            inputs := c.getExprInputs(expr)
            if inputs.Subset(safe) {
                // 所有输入安全，输出也安全
                outputs := c.getExprOutputs(expr)
                safe.Update(outputs)
            }
        }
        
        changed = (safe.Len() > oldSize)
    }
    
    return safe
}

// checkBuiltinSafety: 检查内置函数安全性
func (c *Compiler) checkBuiltinSafety(expr *Expr, safe VarSet) {
    // 获取内置函数定义
    builtin := c.getBuiltin(expr)
    if builtin == nil {
        return
    }
    
    // 检查函数的安全性规则
    // 例如: count(arr, n) - 如果arr安全，n也安全
    terms := expr.Operands()
    
    switch builtin.Name {
    case "count", "sum", "product", "max", "min":
        // 聚合函数：输入安全 → 输出安全
        if len(terms) == 2 {
            input := terms[0]
            output := terms[1]
            
            if Vars(input).Subset(safe) {
                collectVars(output, safe)
            }
        }
        
    // ... 其他内置函数 ...
    }
}
```

### 3.6 递归检查

```go
// checkRecursion: 检查递归
func (c *Compiler) checkRecursion() error {
    // 使用规则图检测循环
    cycles := c.RuleGraph.FindCycles()
    
    if len(cycles) > 0 {
        for _, cycle := range cycles {
            c.Errors = append(c.Errors, &Error{
                Code:    "rego_recursion_error",
                Message: fmt.Sprintf("rule recursion detected: %v", cycle),
            })
        }
    }
    
    return nil
}

// FindCycles: 查找图中的循环
func (g *RuleGraph) FindCycles() [][]Ref {
    var cycles [][]Ref
    visited := make(map[Ref]bool)
    recStack := make(map[Ref]bool)
    var path []Ref
    
    for node := range g.nodes {
        if !visited[node] {
            if c := g.dfs(node, visited, recStack, path); len(c) > 0 {
                cycles = append(cycles, c...)
            }
        }
    }
    
    return cycles
}

// dfs: 深度优先搜索
func (g *RuleGraph) dfs(node Ref, visited, recStack map[Ref]bool, path []Ref) [][]Ref {
    visited[node] = true
    recStack[node] = true
    path = append(path, node)
    
    var cycles [][]Ref
    
    for _, neighbor := range g.edges[node] {
        if !visited[neighbor] {
            if c := g.dfs(neighbor, visited, recStack, path); len(c) > 0 {
                cycles = append(cycles, c...)
            }
        } else if recStack[neighbor] {
            // 找到循环
            cycle := g.extractCycle(path, neighbor)
            cycles = append(cycles, cycle)
        }
    }
    
    recStack[node] = false
    return cycles
}

// extractCycle: 提取循环路径
func (g *RuleGraph) extractCycle(path []Ref, start Ref) []Ref {
    for i, ref := range path {
        if ref.Equal(start) {
            cycle := make([]Ref, len(path)-i)
            copy(cycle, path[i:])
            return cycle
        }
    }
    return nil
}
```

---

## 4. AST重写

### 4.1 局部变量重写

```go
// rewriteLocalVars: 重写局部变量
func (c *Compiler) rewriteLocalVars() error {
    rewriter := &LocalVarRewriter{
        counter: 0,
    }
    
    for filename, module := range c.Modules {
        newModule, err := Transform(rewriter, module)
        if err != nil {
            return err
        }
        c.Modules[filename] = newModule.(*Module)
    }
    
    return nil
}

// LocalVarRewriter: 局部变量重写器
type LocalVarRewriter struct {
    counter int
    current *Rule
}

func (r *LocalVarRewriter) Transform(node interface{}) (interface{}, error) {
    rule, ok := node.(*Rule)
    if !ok {
        return node, nil
    }
    
    r.current = rule
    r.counter++
    
    // 收集局部变量
    locals := r.collectLocals(rule)
    
    // 创建重命名映射
    mapping := make(map[Var]Var)
    for v := range locals {
        mapping[v] = Var(fmt.Sprintf("__%s_%d", v, r.counter))
    }
    
    // 应用重命名
    renamer := NewRenameVars(mapping)
    return Transform(renamer, rule)
}

func (r *LocalVarRewriter) collectLocals(rule *Rule) VarSet {
    allVars := Vars(rule)
    
    // 排除全局变量
    globals := NewVarSet()
    globals.Add(Var("input"))
    globals.Add(Var("data"))
    
    // 排除导入的变量
    if rule.Module != nil {
        for _, imp := range rule.Module.Imports {
            if imp.Alias != "" {
                globals.Add(imp.Alias)
            }
        }
    }
    
    return allVars.Diff(globals)
}
```

### 4.2 推导式重写

```go
// rewriteComprehensionTerms: 重写推导式
func (c *Compiler) rewriteComprehensionTerms() error {
    rewriter := &ComprehensionRewriter{
        compiler: c,
        counter:  0,
    }
    
    for filename, module := range c.Modules {
        newModule, err := Transform(rewriter, module)
        if err != nil {
            return err
        }
        c.Modules[filename] = newModule.(*Module)
    }
    
    return nil
}

// ComprehensionRewriter: 推导式重写器
type ComprehensionRewriter struct {
    compiler *Compiler
    counter  int
    module   *Module
}

func (r *ComprehensionRewriter) Transform(node interface{}) (interface{}, error) {
    // 处理Module节点
    if module, ok := node.(*Module); ok {
        r.module = module
        return node, nil
    }
    
    // 处理Term节点
    term, ok := node.(*Term)
    if !ok {
        return node, nil
    }
    
    switch comp := term.Value.(type) {
    case *ArrayComprehension:
        return r.rewriteArrayComp(comp)
    case *SetComprehension:
        return r.rewriteSetComp(comp)
    case *ObjectComprehension:
        return r.rewriteObjectComp(comp)
    }
    
    return node, nil
}

func (r *ComprehensionRewriter) rewriteArrayComp(comp *ArrayComprehension) (*Term, error) {
    // [x | x = arr[_]; x > 5]
    // →
    // __comp_N
    //
    // 新增规则:
    // __comp_N[__key] = x if {
    //     x = arr[_]
    //     x > 5
    //     __key = count(__comp_N)  # 生成索引
    // }
    
    r.counter++
    ruleName := Var(fmt.Sprintf("__comp_%d", r.counter))
    
    // 创建key变量
    keyVar := Var("__key")
    
    // 创建规则
    rule := &Rule{
        Head: &Head{
            Name:  ruleName,
            Key:   VarTerm(keyVar.String()),
            Value: comp.Term,
        },
        Body: comp.Body,
    }
    
    // 添加索引生成表达式
    // __key = count(__comp_N)
    countExpr := &Expr{
        Terms: []*Term{
            RefTerm(VarTerm("count")),
            RefTerm(VarTerm(ruleName.String())),
            VarTerm(keyVar.String()),
        },
    }
    rule.Body = append(rule.Body, countExpr)
    
    // 将规则添加到模块
    r.module.Rules = append(r.module.Rules, rule)
    
    // 返回对规则的引用
    return RefTerm(VarTerm(ruleName.String())), nil
}
```

### 4.3 动态项重写

```go
// rewriteDynamicTerms: 重写动态项
func (c *Compiler) rewriteDynamicTerms() error {
    rewriter := &DynamicTermRewriter{
        counter: 0,
    }
    
    for filename, module := range c.Modules {
        newModule, err := Transform(rewriter, module)
        if err != nil {
            return err
        }
        c.Modules[filename] = newModule.(*Module)
    }
    
    return nil
}

// DynamicTermRewriter: 动态项重写器
type DynamicTermRewriter struct {
    counter int
}

func (r *DynamicTermRewriter) Transform(node interface{}) (interface{}, error) {
    body, ok := node.(Body)
    if !ok {
        return node, nil
    }
    
    // 对每个表达式进行重写
    newBody := make(Body, 0, len(body))
    
    for _, expr := range body {
        // 提取动态项
        dynTerms := r.extractDynamicTerms(expr)
        
        // 为每个动态项创建赋值
        for _, term := range dynTerms {
            r.counter++
            tmpVar := Var(fmt.Sprintf("__dyn_%d", r.counter))
            
            // 创建赋值表达式: __dyn_N = <dynamic_term>
            assign := Equality.Expr(VarTerm(tmpVar.String()), term)
            newBody = append(newBody, assign)
            
            // 替换原表达式中的动态项为变量
            expr = r.replaceTerm(expr, term, VarTerm(tmpVar.String()))
        }
        
        newBody = append(newBody, expr)
    }
    
    return newBody, nil
}

func (r *DynamicTermRewriter) extractDynamicTerms(expr *Expr) []*Term {
    var dynTerms []*Term
    
    for _, term := range expr.Operands() {
        if r.isDynamic(term) {
            dynTerms = append(dynTerms, term)
        }
    }
    
    return dynTerms
}

func (r *DynamicTermRewriter) isDynamic(term *Term) bool {
    // 函数调用和推导式是动态的
    switch term.Value.(type) {
    case Call, *ArrayComprehension, *SetComprehension, *ObjectComprehension:
        return true
    }
    return false
}
```

### 4.4 引用重写

```go
// rewriteRefsInHead: 重写规则头部的引用
func (c *Compiler) rewriteRefsInHead() error {
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            if err := c.rewriteRuleHead(rule); err != nil {
                return err
            }
        }
    }
    
    return nil
}

func (c *Compiler) rewriteRuleHead(rule *Rule) error {
    head := rule.Head
    
    // 检查是否是复杂引用
    // 例如: data.users[id].name = value
    if !c.isComplexRef(head.Name) {
        return nil
    }
    
    // 将复杂引用拆分
    // data.users[id].name = value
    // →
    // __ref = data.users[id]
    // __ref.name = value
    
    // ... 实现略 ...
    
    return nil
}
```

---

## 5. 查询规划

### 5.1 规划器架构

```go
// Planner: 查询规划器
type Planner struct {
    compiler *Compiler
    query    Body
    indices  *Indices
}

// Plan: 执行计划
type Plan struct {
    Steps []PlanStep  // 执行步骤
    Cost  int         // 估计成本
}

// PlanStep: 执行步骤
type PlanStep struct {
    Expr      *Expr     // 表达式
    Index     *Index    // 使用的索引
    Estimated int       // 估计结果数
}

// NewPlanner: 创建规划器
func NewPlanner(c *Compiler) *Planner {
    return &Planner{
        compiler: c,
        indices:  c.indices,
    }
}

// Plan: 生成查询计划
func (p *Planner) Plan(query Body) (*Plan, error) {
    // 1. 分析查询
    analysis := p.analyzeQuery(query)
    
    // 2. 选择索引
    indices := p.selectIndices(analysis)
    
    // 3. 排序表达式
    ordered := p.orderExprs(query, indices)
    
    // 4. 估计成本
    cost := p.estimateCost(ordered)
    
    return &Plan{
        Steps: ordered,
        Cost:  cost,
    }, nil
}
```

### 5.2 索引构建

```go
// buildRuleIndex: 构建规则索引
func (c *Compiler) buildRuleIndex() error {
    c.RuleIndex = NewRuleIndex()
    
    for _, module := range c.Modules {
        for _, rule := range module.Rules {
            // 获取规则的引用路径
            ref := rule.Head.Reference
            
            // 添加到索引
            c.RuleIndex.Add(ref, rule)
            
            // 如果是部分规则，索引key
            if rule.Head.Key != nil {
                c.indexPartialRule(rule)
            }
        }
    }
    
    return nil
}

// RuleIndex: 规则索引
type RuleIndex struct {
    rules map[string][]*Rule  // 路径 → 规则列表
    keys  map[string]*KeyIndex  // 部分规则的key索引
}

// KeyIndex: Key索引
type KeyIndex struct {
    ground  map[Value]*Rule    // ground key → 规则
    dynamic []*Rule            // 动态key的规则
}

// Add: 添加规则到索引
func (idx *RuleIndex) Add(ref Ref, rule *Rule) {
    path := ref.String()
    idx.rules[path] = append(idx.rules[path], rule)
}

// Lookup: 查找规则
func (idx *RuleIndex) Lookup(ref Ref) []*Rule {
    path := ref.String()
    return idx.rules[path]
}

// indexPartialRule: 索引部分规则
func (c *Compiler) indexPartialRule(rule *Rule) {
    ref := rule.Head.Reference
    key := rule.Head.Key
    
    if key.IsGround() {
        // Ground key，直接索引
        c.RuleIndex.keys[ref.String()].ground[key.Value] = rule
    } else {
        // 动态key
        c.RuleIndex.keys[ref.String()].dynamic = append(
            c.RuleIndex.keys[ref.String()].dynamic,
            rule,
        )
    }
}
```

### 5.3 规则排序

```go
// orderExprs: 排序表达式
func (p *Planner) orderExprs(body Body, indices map[*Expr]*Index) []PlanStep {
    // 使用贪心算法排序表达式
    // 优先执行：
    // 1. ground表达式（确定值）
    // 2. 有索引支持的表达式
    // 3. 输出较少的表达式
    
    steps := make([]PlanStep, 0, len(body))
    remaining := make([]*Expr, len(body))
    copy(remaining, body)
    
    safe := NewVarSet()  // 已知的安全变量
    
    for len(remaining) > 0 {
        // 选择下一个表达式
        best := p.selectBest(remaining, safe, indices)
        
        if best == -1 {
            // 无法继续（不应该发生）
            break
        }
        
        expr := remaining[best]
        
        // 添加到计划
        steps = append(steps, PlanStep{
            Expr:      expr,
            Index:     indices[expr],
            Estimated: p.estimate(expr, safe),
        })
        
        // 更新安全变量
        safe.Update(p.getExprOutputs(expr))
        
        // 从剩余列表中移除
        remaining = append(remaining[:best], remaining[best+1:]...)
    }
    
    return steps
}

// selectBest: 选择最优表达式
func (p *Planner) selectBest(exprs []*Expr, safe VarSet, indices map[*Expr]*Index) int {
    bestIdx := -1
    bestScore := -1
    
    for i, expr := range exprs {
        score := p.scoreExpr(expr, safe, indices[expr])
        
        if score > bestScore {
            bestScore = score
            bestIdx = i
        }
    }
    
    return bestIdx
}

// scoreExpr: 评分表达式
func (p *Planner) scoreExpr(expr *Expr, safe VarSet, index *Index) int {
    score := 0
    
    // 1. Ground表达式优先
    if expr.IsGround() {
        score += 1000
    }
    
    // 2. 所有输入都安全
    inputs := p.getExprInputs(expr)
    if inputs.Subset(safe) {
        score += 500
    }
    
    // 3. 有索引支持
    if index != nil {
        score += 300
    }
    
    // 4. 估计输出少
    estimated := p.estimate(expr, safe)
    score += (1000 - estimated)  // 输出越少越好
    
    return score
}
```

### 5.4 部分求值

```go
// PartialEval: 部分求值
type PartialEval struct {
    compiler *Compiler
    unknowns []string   // 未知输入
}

// Eval: 执行部分求值
func (pe *PartialEval) Eval(query Body) (Body, error) {
    // 部分求值将已知的输入求值，保留未知部分
    
    result := make(Body, 0)
    
    for _, expr := range query {
        // 尝试求值表达式
        val, err := pe.evalExpr(expr)
        
        if err != nil {
            // 无法求值，保留原表达式
            result = append(result, expr)
            continue
        }
        
        // 检查结果
        if val == BooleanTerm(true) {
            // 恒真，忽略
            continue
        } else if val == BooleanTerm(false) {
            // 恒假，整个查询失败
            return nil, fmt.Errorf("partial eval: contradiction")
        } else {
            // 部分求值结果
            result = append(result, &Expr{Terms: val})
        }
    }
    
    return result, nil
}

// evalExpr: 求值表达式
func (pe *PartialEval) evalExpr(expr *Expr) (*Term, error) {
    // 检查是否依赖未知输入
    if pe.dependsOnUnknowns(expr) {
        return nil, fmt.Errorf("depends on unknowns")
    }
    
    // 所有输入都是已知的，可以求值
    return pe.evaluate(expr)
}

// dependsOnUnknowns: 检查是否依赖未知输入
func (pe *PartialEval) dependsOnUnknowns(expr *Expr) bool {
    refs := collectRefs(expr)
    
    for _, ref := range refs {
        for _, unknown := range pe.unknowns {
            if strings.HasPrefix(ref.String(), unknown) {
                return true
            }
        }
    }
    
    return false
}
```

---

(由于篇幅限制，这里展示编译器实现的核心部分。完整文档将包含类型系统、错误处理、优化技术、IR生成等详细内容。)

让我继续添加剩余部分...

---

## 6. 类型系统实现

### 6.1 类型定义

```go
// Type: 类型接口
type Type interface {
    String() string
    Compare(Type) int
}

// 基础类型
var (
    Any     = &anyType{}
    Null    = &nullType{}
    Boolean = &booleanType{}
    Number  = &numberType{}
    String  = &stringType{}
)

// 复合类型
type ArrayType struct {
    Elem Type  // 元素类型
}

type ObjectType struct {
    Static  map[string]Type  // 静态键
    Dynamic *DynamicType     // 动态键（可选）
}

type SetType struct {
    Elem Type  // 元素类型
}

// 函数类型
type FunctionType struct {
    Args   []Type  // 参数类型
    Result Type    // 返回类型
}
```

### 6.2 类型推导

详细实现略...

---

## 附录

### A. 编译器选项

```go
// CompilerOptions: 编译器选项
type CompilerOptions struct {
    // 能力限制
    Capabilities *Capabilities
    
    // 优化级别
    OptimizationLevel int  // 0: 无优化, 1: 基本, 2: 完全
    
    // 是否启用严格模式
    Strict bool
    
    // 是否生成调试信息
    Debug bool
    
    // 自定义阶段
    Stages []func(*Compiler) error
}
```

### B. 编译阶段清单

完整的编译阶段列表...

### C. 性能调优指南

1. **使用增量编译**
2. **启用编译缓存**
3. **优化模块结构**
4. **减少规则复杂度**

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日  
**维护者**: OPA技术文档项目  
**反馈**: 欢迎通过GitHub Issues提供建议

**相关阅读**:

- [AST构建与转换](10.3-AST构建与转换.md) - AST操作
- [Top-Down求值器源码](10.5-Top-Down求值器源码.md) - 求值器
- [类型系统形式化](../06-形式化证明/06.5-类型系统形式化.md) - 类型理论
