# 部分求值引擎

> **文档类型**: 源码实现分析  
> **核心模块**: `internal/planner/`, `compile/partial.go`  
> **适用读者**: 编译优化工程师、高级OPA用户  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 2.8 - 部分求值  
> **OPA版本**: v0.68.0

---

## 📋 文档概述

部分求值（Partial Evaluation）是OPA的高级优化技术，通过在编译时预计算已知部分，生成优化的策略。

**应用场景**:

- WASM编译优化
- 策略预处理
- 查询专门化
- 性能加速

---

## 1. 部分求值原理

### 1.1 基本概念

```text
原始策略:
  allow if {
      input.method == "GET"
      user := data.users[input.user_id]
      user.role == "admin"
  }

已知输入: input.method = "GET"

部分求值结果:
  allow if {
      user := data.users[input.user_id]
      user.role == "admin"
  }
```

### 1.2 PartialEvaluator

```go
// PartialEvaluator: 部分求值器
type PartialEvaluator struct {
    compiler *ast.Compiler
    unknowns []string  // 未知输入路径
    queries  []ast.Body // 待求值查询
}

// NewPartialEvaluator: 创建部分求值器
func NewPartialEvaluator(c *ast.Compiler, unknowns []string) *PartialEvaluator {
    return &PartialEvaluator{
        compiler: c,
        unknowns: unknowns,
    }
}

// Eval: 执行部分求值
func (pe *PartialEvaluator) Eval(queries []ast.Body) ([]ast.Body, error) {
    var result []ast.Body
    
    for _, query := range queries {
        partial, err := pe.evalQuery(query)
        if err != nil {
            return nil, err
        }
        
        if len(partial) > 0 {
            result = append(result, partial)
        }
    }
    
    return result, nil
}
```

---

## 2. 求值过程

### 2.1 表达式分类

```go
// classifyExpr: 分类表达式
func (pe *PartialEvaluator) classifyExpr(expr *ast.Expr) ExprType {
    // 检查是否依赖未知输入
    if pe.dependsOnUnknowns(expr) {
        return ExprUnknown
    }
    
    // 检查是否可以完全求值
    if pe.isFullyGround(expr) {
        return ExprGround
    }
    
    return ExprPartial
}

// ExprType: 表达式类型
type ExprType int

const (
    ExprGround   ExprType = iota  // 完全已知
    ExprUnknown                    // 依赖未知输入
    ExprPartial                    // 部分已知
)
```

### 2.2 求值策略

```go
// evalQuery: 求值查询
func (pe *PartialEvaluator) evalQuery(query ast.Body) (ast.Body, error) {
    result := make(ast.Body, 0)
    
    for _, expr := range query {
        typ := pe.classifyExpr(expr)
        
        switch typ {
        case ExprGround:
            // 完全求值
            val, err := pe.evaluate(expr)
            if err != nil {
                return nil, err
            }
            
            if val == ast.BooleanTerm(false) {
                // 矛盾，整个查询失败
                return nil, nil
            }
            // true则忽略
            
        case ExprUnknown:
            // 保留原表达式
            result = append(result, expr)
            
        case ExprPartial:
            // 部分求值
            partial, err := pe.evalPartial(expr)
            if err != nil {
                return nil, err
            }
            result = append(result, partial...)
        }
    }
    
    return result, nil
}
```

---

## 3. 优化技术

### 3.1 常量传播

```go
// propagateConstants: 常量传播
func (pe *PartialEvaluator) propagateConstants(body ast.Body) ast.Body {
    constants := make(map[ast.Var]ast.Value)
    
    // 第一遍：收集常量绑定
    for _, expr := range body {
        if pe.isAssignment(expr) {
            left, right := pe.getAssignmentTerms(expr)
            
            if v, ok := left.Value.(ast.Var); ok {
                if right.IsGround() {
                    constants[v] = right.Value
                }
            }
        }
    }
    
    // 第二遍：替换常量
    result := make(ast.Body, 0)
    
    for _, expr := range body {
        newExpr := pe.replaceConstants(expr, constants)
        result = append(result, newExpr)
    }
    
    return result
}
```

### 3.2 死代码消除

```go
// eliminateDeadCode: 消除死代码
func (pe *PartialEvaluator) eliminateDeadCode(body ast.Body) ast.Body {
    result := make(ast.Body, 0)
    
    for _, expr := range body {
        // 跳过恒真表达式
        if pe.isTautology(expr) {
            continue
        }
        
        // 检测矛盾
        if pe.isContradiction(expr) {
            return ast.Body{}  // 整个body为false
        }
        
        result = append(result, expr)
    }
    
    return result
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日

**相关阅读**:

- [部分求值理论](../06-形式化证明/06.6-部分求值理论.md)
- [编译器实现详解](10.4-编译器实现详解.md)
