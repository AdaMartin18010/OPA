# éƒ¨åˆ†æ±‚å€¼å¼•æ“

> **æ–‡æ¡£ç±»å‹**: æºç å®ç°åˆ†æ  
> **æ ¸å¿ƒæ¨¡å—**: `internal/planner/`, `compile/partial.go`  
> **é€‚ç”¨è¯»è€…**: ç¼–è¯‘ä¼˜åŒ–å·¥ç¨‹å¸ˆã€é«˜çº§OPAç”¨æˆ·  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 2.8 - éƒ¨åˆ†æ±‚å€¼  
> **OPAç‰ˆæœ¬**: v0.68.0

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

éƒ¨åˆ†æ±‚å€¼ï¼ˆPartial Evaluationï¼‰æ˜¯OPAçš„é«˜çº§ä¼˜åŒ–æŠ€æœ¯ï¼Œé€šè¿‡åœ¨ç¼–è¯‘æ—¶é¢„è®¡ç®—å·²çŸ¥éƒ¨åˆ†ï¼Œç”Ÿæˆä¼˜åŒ–çš„ç­–ç•¥ã€‚

**åº”ç”¨åœºæ™¯**:

- WASMç¼–è¯‘ä¼˜åŒ–
- ç­–ç•¥é¢„å¤„ç†
- æŸ¥è¯¢ä¸“é—¨åŒ–
- æ€§èƒ½åŠ é€Ÿ

---

## 1. éƒ¨åˆ†æ±‚å€¼åŸç†

### 1.1 åŸºæœ¬æ¦‚å¿µ

```text
åŸå§‹ç­–ç•¥:
  allow if {
      input.method == "GET"
      user := data.users[input.user_id]
      user.role == "admin"
  }

å·²çŸ¥è¾“å…¥: input.method = "GET"

éƒ¨åˆ†æ±‚å€¼ç»“æœ:
  allow if {
      user := data.users[input.user_id]
      user.role == "admin"
  }
```

### 1.2 PartialEvaluator

```go
// PartialEvaluator: éƒ¨åˆ†æ±‚å€¼å™¨
type PartialEvaluator struct {
    compiler *ast.Compiler
    unknowns []string  // æœªçŸ¥è¾“å…¥è·¯å¾„
    queries  []ast.Body // å¾…æ±‚å€¼æŸ¥è¯¢
}

// NewPartialEvaluator: åˆ›å»ºéƒ¨åˆ†æ±‚å€¼å™¨
func NewPartialEvaluator(c *ast.Compiler, unknowns []string) *PartialEvaluator {
    return &PartialEvaluator{
        compiler: c,
        unknowns: unknowns,
    }
}

// Eval: æ‰§è¡Œéƒ¨åˆ†æ±‚å€¼
func (pe *PartialEvaluator) Eval(queries []ast.Body) ([]ast.Body, error) {
    var result []ast.Body
    
    for _, query := range queries {
        partial, err := pe.evalQuery(query)
        if err != nil {
            return nil, err
        }
        
        if len(partial) > 0 {
            result = append(result, partial)
        }
    }
    
    return result, nil
}
```

---

## 2. æ±‚å€¼è¿‡ç¨‹

### 2.1 è¡¨è¾¾å¼åˆ†ç±»

```go
// classifyExpr: åˆ†ç±»è¡¨è¾¾å¼
func (pe *PartialEvaluator) classifyExpr(expr *ast.Expr) ExprType {
    // æ£€æŸ¥æ˜¯å¦ä¾èµ–æœªçŸ¥è¾“å…¥
    if pe.dependsOnUnknowns(expr) {
        return ExprUnknown
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å®Œå…¨æ±‚å€¼
    if pe.isFullyGround(expr) {
        return ExprGround
    }
    
    return ExprPartial
}

// ExprType: è¡¨è¾¾å¼ç±»å‹
type ExprType int

const (
    ExprGround   ExprType = iota  // å®Œå…¨å·²çŸ¥
    ExprUnknown                    // ä¾èµ–æœªçŸ¥è¾“å…¥
    ExprPartial                    // éƒ¨åˆ†å·²çŸ¥
)
```

### 2.2 æ±‚å€¼ç­–ç•¥

```go
// evalQuery: æ±‚å€¼æŸ¥è¯¢
func (pe *PartialEvaluator) evalQuery(query ast.Body) (ast.Body, error) {
    result := make(ast.Body, 0)
    
    for _, expr := range query {
        typ := pe.classifyExpr(expr)
        
        switch typ {
        case ExprGround:
            // å®Œå…¨æ±‚å€¼
            val, err := pe.evaluate(expr)
            if err != nil {
                return nil, err
            }
            
            if val == ast.BooleanTerm(false) {
                // çŸ›ç›¾ï¼Œæ•´ä¸ªæŸ¥è¯¢å¤±è´¥
                return nil, nil
            }
            // trueåˆ™å¿½ç•¥
            
        case ExprUnknown:
            // ä¿ç•™åŸè¡¨è¾¾å¼
            result = append(result, expr)
            
        case ExprPartial:
            // éƒ¨åˆ†æ±‚å€¼
            partial, err := pe.evalPartial(expr)
            if err != nil {
                return nil, err
            }
            result = append(result, partial...)
        }
    }
    
    return result, nil
}
```

---

## 3. ä¼˜åŒ–æŠ€æœ¯

### 3.1 å¸¸é‡ä¼ æ’­

```go
// propagateConstants: å¸¸é‡ä¼ æ’­
func (pe *PartialEvaluator) propagateConstants(body ast.Body) ast.Body {
    constants := make(map[ast.Var]ast.Value)
    
    // ç¬¬ä¸€éï¼šæ”¶é›†å¸¸é‡ç»‘å®š
    for _, expr := range body {
        if pe.isAssignment(expr) {
            left, right := pe.getAssignmentTerms(expr)
            
            if v, ok := left.Value.(ast.Var); ok {
                if right.IsGround() {
                    constants[v] = right.Value
                }
            }
        }
    }
    
    // ç¬¬äºŒéï¼šæ›¿æ¢å¸¸é‡
    result := make(ast.Body, 0)
    
    for _, expr := range body {
        newExpr := pe.replaceConstants(expr, constants)
        result = append(result, newExpr)
    }
    
    return result
}
```

### 3.2 æ­»ä»£ç æ¶ˆé™¤

```go
// eliminateDeadCode: æ¶ˆé™¤æ­»ä»£ç 
func (pe *PartialEvaluator) eliminateDeadCode(body ast.Body) ast.Body {
    result := make(ast.Body, 0)
    
    for _, expr := range body {
        // è·³è¿‡æ’çœŸè¡¨è¾¾å¼
        if pe.isTautology(expr) {
            continue
        }
        
        // æ£€æµ‹çŸ›ç›¾
        if pe.isContradiction(expr) {
            return ast.Body{}  // æ•´ä¸ªbodyä¸ºfalse
        }
        
        result = append(result, expr)
    }
    
    return result
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥

**ç›¸å…³é˜…è¯»**:

- [éƒ¨åˆ†æ±‚å€¼ç†è®º](../06-å½¢å¼åŒ–è¯æ˜/06.6-éƒ¨åˆ†æ±‚å€¼ç†è®º.md)
- [ç¼–è¯‘å™¨å®ç°è¯¦è§£](10.4-ç¼–è¯‘å™¨å®ç°è¯¦è§£.md)
