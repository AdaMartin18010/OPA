# ç´¢å¼•ç³»ç»Ÿå®ç°

> **æ–‡æ¡£ç±»å‹**: æºç å®ç°åˆ†æ  
> **æ ¸å¿ƒæ¨¡å—**: `topdown/indexing.go`, `compile/index.go`  
> **é€‚ç”¨è¯»è€…**: æ€§èƒ½ä¼˜åŒ–å·¥ç¨‹å¸ˆã€OPAæ ¸å¿ƒå¼€å‘è€…  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… Phase 2.7 - ç´¢å¼•ç³»ç»Ÿ  
> **OPAç‰ˆæœ¬**: v0.68.0

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

OPAçš„ç´¢å¼•ç³»ç»Ÿæ˜¯æ€§èƒ½ä¼˜åŒ–çš„å…³é”®ç»„ä»¶ï¼Œé€šè¿‡é¢„æ„å»ºç´¢å¼•å¤§å¹…åŠ é€Ÿè§„åˆ™åŒ¹é…å’Œæ•°æ®æŸ¥æ‰¾ã€‚

**æ ¸å¿ƒç´¢å¼•ç±»å‹**:

1. **è§„åˆ™ç´¢å¼•** (Rule Index): å¿«é€Ÿå®šä½è§„åˆ™
2. **æ•°æ®ç´¢å¼•** (Data Index): åŠ é€Ÿæ•°æ®æŸ¥æ‰¾
3. **æ¨å¯¼å¼ç´¢å¼•** (Comprehension Index): ä¼˜åŒ–æ¨å¯¼å¼
4. **è§¦å‘å™¨ç´¢å¼•** (Trigger Index): å¢é‡æ›´æ–°

---

## 1. è§„åˆ™ç´¢å¼•

### 1.1 RuleIndexç»“æ„

```go
// RuleIndex: è§„åˆ™ç´¢å¼•
type RuleIndex struct {
    // å®Œå…¨è§„åˆ™ç´¢å¼•
    complete map[string][]*ast.Rule
    
    // éƒ¨åˆ†è§„åˆ™ç´¢å¼•
    partial map[string]*PartialIndex
    
    // å‡½æ•°ç´¢å¼•
    functions map[string]*FunctionIndex
}

// PartialIndex: éƒ¨åˆ†è§„åˆ™ç´¢å¼•
type PartialIndex struct {
    // ground keyç´¢å¼•
    ground map[interface{}]*ast.Rule
    
    // åŠ¨æ€keyè§„åˆ™
    dynamic []*ast.Rule
}
```

### 1.2 ç´¢å¼•æ„å»º

```go
// BuildRuleIndex: æ„å»ºè§„åˆ™ç´¢å¼•
func BuildRuleIndex(modules map[string]*ast.Module) *RuleIndex {
    idx := &RuleIndex{
        complete:  make(map[string][]*ast.Rule),
        partial:   make(map[string]*PartialIndex),
        functions: make(map[string]*FunctionIndex),
    }
    
    for _, module := range modules {
        for _, rule := range module.Rules {
            idx.addRule(rule)
        }
    }
    
    return idx
}

// addRule: æ·»åŠ è§„åˆ™
func (idx *RuleIndex) addRule(rule *ast.Rule) {
    ref := rule.Head.Reference
    path := ref.String()
    
    if rule.Head.Key == nil {
        // å®Œå…¨è§„åˆ™
        idx.complete[path] = append(idx.complete[path], rule)
    } else {
        // éƒ¨åˆ†è§„åˆ™
        if idx.partial[path] == nil {
            idx.partial[path] = &PartialIndex{
                ground:  make(map[interface{}]*ast.Rule),
                dynamic: []*ast.Rule{},
            }
        }
        
        if rule.Head.Key.IsGround() {
            // ground key
            key := rule.Head.Key.Value
            idx.partial[path].ground[key] = rule
        } else {
            // åŠ¨æ€key
            idx.partial[path].dynamic = append(idx.partial[path].dynamic, rule)
        }
    }
}
```

### 1.3 ç´¢å¼•æŸ¥æ‰¾

```go
// Lookup: æŸ¥æ‰¾è§„åˆ™
func (idx *RuleIndex) Lookup(ref ast.Ref) []*ast.Rule {
    if len(ref) == 0 {
        return nil
    }
    
    // å°è¯•å®Œå…¨åŒ¹é…
    path := ref.String()
    if rules, ok := idx.complete[path]; ok {
        return rules
    }
    
    // å°è¯•éƒ¨åˆ†è§„åˆ™
    if len(ref) > 1 {
        basePath := ref[:len(ref)-1].String()
        key := ref[len(ref)-1]
        
        if partial, ok := idx.partial[basePath]; ok {
            return idx.lookupPartial(partial, key)
        }
    }
    
    return nil
}

// lookupPartial: æŸ¥æ‰¾éƒ¨åˆ†è§„åˆ™
func (idx *RuleIndex) lookupPartial(partial *PartialIndex, key *ast.Term) []*ast.Rule {
    var result []*ast.Rule
    
    // æŸ¥æ‰¾ground key
    if key.IsGround() {
        if rule, ok := partial.ground[key.Value]; ok {
            result = append(result, rule)
        }
    }
    
    // æ·»åŠ åŠ¨æ€keyè§„åˆ™
    result = append(result, partial.dynamic...)
    
    return result
}
```

---

## 2. æ•°æ®ç´¢å¼•

### 2.1 Trieç´¢å¼•

```go
// TrieIndex: å‰ç¼€æ ‘ç´¢å¼•
type TrieIndex struct {
    root *TrieNode
}

// TrieNode: TrieèŠ‚ç‚¹
type TrieNode struct {
    key      interface{}
    value    interface{}
    children map[interface{}]*TrieNode
}

// Insert: æ’å…¥è·¯å¾„
func (t *TrieIndex) Insert(path []interface{}, value interface{}) {
    node := t.root
    
    for _, key := range path {
        if node.children[key] == nil {
            node.children[key] = &TrieNode{
                key:      key,
                children: make(map[interface{}]*TrieNode),
            }
        }
        node = node.children[key]
    }
    
    node.value = value
}

// Lookup: æŸ¥æ‰¾è·¯å¾„
func (t *TrieIndex) Lookup(path []interface{}) interface{} {
    node := t.root
    
    for _, key := range path {
        if node.children[key] == nil {
            return nil
        }
        node = node.children[key]
    }
    
    return node.value
}
```

---

## 3. è§¦å‘å™¨ç´¢å¼•

### 3.1 TriggerIndex

```go
// TriggerIndex: è§¦å‘å™¨ç´¢å¼•ï¼ˆç”¨äºå¢é‡æ›´æ–°ï¼‰
type TriggerIndex struct {
    // è·¯å¾„ â†’ ä¾èµ–æ­¤è·¯å¾„çš„è§„åˆ™
    triggers map[string][]*ast.Rule
}

// BuildTriggerIndex: æ„å»ºè§¦å‘å™¨ç´¢å¼•
func BuildTriggerIndex(modules map[string]*ast.Module) *TriggerIndex {
    idx := &TriggerIndex{
        triggers: make(map[string][]*ast.Rule),
    }
    
    for _, module := range modules {
        for _, rule := range module.Rules {
            // æ”¶é›†è§„åˆ™ä½“ä¸­å¼•ç”¨çš„æ•°æ®è·¯å¾„
            refs := collectDataRefs(rule.Body)
            
            for _, ref := range refs {
                path := ref.String()
                idx.triggers[path] = append(idx.triggers[path], rule)
            }
        }
    }
    
    return idx
}

// GetAffectedRules: è·å–å—å½±å“çš„è§„åˆ™
func (idx *TriggerIndex) GetAffectedRules(path string) []*ast.Rule {
    // æŸ¥æ‰¾ç²¾ç¡®åŒ¹é…
    rules := idx.triggers[path]
    
    // æŸ¥æ‰¾å‰ç¼€åŒ¹é…
    for triggerPath, triggerRules := range idx.triggers {
        if strings.HasPrefix(path, triggerPath) {
            rules = append(rules, triggerRules...)
        }
    }
    
    return rules
}
```

---

## 4. ä¼˜åŒ–æŠ€æœ¯

### 4.1 ç´¢å¼•é€‰æ‹©

```go
// IndexSelector: ç´¢å¼•é€‰æ‹©å™¨
type IndexSelector struct {
    indices []Index
    stats   *Statistics
}

// SelectBest: é€‰æ‹©æœ€ä¼˜ç´¢å¼•
func (s *IndexSelector) SelectBest(query ast.Body) Index {
    var bestIdx Index
    bestScore := -1
    
    for _, idx := range s.indices {
        score := s.scoreIndex(idx, query)
        if score > bestScore {
            bestScore = score
            bestIdx = idx
        }
    }
    
    return bestIdx
}

// scoreIndex: è¯„åˆ†ç´¢å¼•
func (s *IndexSelector) scoreIndex(idx Index, query ast.Body) int {
    // åŸºäºç»Ÿè®¡ä¿¡æ¯è¯„åˆ†
    coverage := idx.Coverage(query)
    selectivity := s.stats.Selectivity(idx)
    
    return int(coverage * selectivity * 100)
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ23æ—¥

**ç›¸å…³é˜…è¯»**:

- [ç¼–è¯‘å™¨å®ç°è¯¦è§£](10.4-ç¼–è¯‘å™¨å®ç°è¯¦è§£.md)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../08-æœ€ä½³å®è·µ/08.2-æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md)
