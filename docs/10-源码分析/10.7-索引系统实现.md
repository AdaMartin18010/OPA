# 索引系统实现

> **文档类型**: 源码实现分析  
> **核心模块**: `topdown/indexing.go`, `compile/index.go`  
> **适用读者**: 性能优化工程师、OPA核心开发者  
> **最后更新**: 2025年10月23日  
> **文档状态**: ✅ Phase 2.7 - 索引系统  
> **OPA版本**: v0.68.0

---

## 📋 文档概述

OPA的索引系统是性能优化的关键组件，通过预构建索引大幅加速规则匹配和数据查找。

**核心索引类型**:

1. **规则索引** (Rule Index): 快速定位规则
2. **数据索引** (Data Index): 加速数据查找
3. **推导式索引** (Comprehension Index): 优化推导式
4. **触发器索引** (Trigger Index): 增量更新

---

## 1. 规则索引

### 1.1 RuleIndex结构

```go
// RuleIndex: 规则索引
type RuleIndex struct {
    // 完全规则索引
    complete map[string][]*ast.Rule
    
    // 部分规则索引
    partial map[string]*PartialIndex
    
    // 函数索引
    functions map[string]*FunctionIndex
}

// PartialIndex: 部分规则索引
type PartialIndex struct {
    // ground key索引
    ground map[interface{}]*ast.Rule
    
    // 动态key规则
    dynamic []*ast.Rule
}
```

### 1.2 索引构建

```go
// BuildRuleIndex: 构建规则索引
func BuildRuleIndex(modules map[string]*ast.Module) *RuleIndex {
    idx := &RuleIndex{
        complete:  make(map[string][]*ast.Rule),
        partial:   make(map[string]*PartialIndex),
        functions: make(map[string]*FunctionIndex),
    }
    
    for _, module := range modules {
        for _, rule := range module.Rules {
            idx.addRule(rule)
        }
    }
    
    return idx
}

// addRule: 添加规则
func (idx *RuleIndex) addRule(rule *ast.Rule) {
    ref := rule.Head.Reference
    path := ref.String()
    
    if rule.Head.Key == nil {
        // 完全规则
        idx.complete[path] = append(idx.complete[path], rule)
    } else {
        // 部分规则
        if idx.partial[path] == nil {
            idx.partial[path] = &PartialIndex{
                ground:  make(map[interface{}]*ast.Rule),
                dynamic: []*ast.Rule{},
            }
        }
        
        if rule.Head.Key.IsGround() {
            // ground key
            key := rule.Head.Key.Value
            idx.partial[path].ground[key] = rule
        } else {
            // 动态key
            idx.partial[path].dynamic = append(idx.partial[path].dynamic, rule)
        }
    }
}
```

### 1.3 索引查找

```go
// Lookup: 查找规则
func (idx *RuleIndex) Lookup(ref ast.Ref) []*ast.Rule {
    if len(ref) == 0 {
        return nil
    }
    
    // 尝试完全匹配
    path := ref.String()
    if rules, ok := idx.complete[path]; ok {
        return rules
    }
    
    // 尝试部分规则
    if len(ref) > 1 {
        basePath := ref[:len(ref)-1].String()
        key := ref[len(ref)-1]
        
        if partial, ok := idx.partial[basePath]; ok {
            return idx.lookupPartial(partial, key)
        }
    }
    
    return nil
}

// lookupPartial: 查找部分规则
func (idx *RuleIndex) lookupPartial(partial *PartialIndex, key *ast.Term) []*ast.Rule {
    var result []*ast.Rule
    
    // 查找ground key
    if key.IsGround() {
        if rule, ok := partial.ground[key.Value]; ok {
            result = append(result, rule)
        }
    }
    
    // 添加动态key规则
    result = append(result, partial.dynamic...)
    
    return result
}
```

---

## 2. 数据索引

### 2.1 Trie索引

```go
// TrieIndex: 前缀树索引
type TrieIndex struct {
    root *TrieNode
}

// TrieNode: Trie节点
type TrieNode struct {
    key      interface{}
    value    interface{}
    children map[interface{}]*TrieNode
}

// Insert: 插入路径
func (t *TrieIndex) Insert(path []interface{}, value interface{}) {
    node := t.root
    
    for _, key := range path {
        if node.children[key] == nil {
            node.children[key] = &TrieNode{
                key:      key,
                children: make(map[interface{}]*TrieNode),
            }
        }
        node = node.children[key]
    }
    
    node.value = value
}

// Lookup: 查找路径
func (t *TrieIndex) Lookup(path []interface{}) interface{} {
    node := t.root
    
    for _, key := range path {
        if node.children[key] == nil {
            return nil
        }
        node = node.children[key]
    }
    
    return node.value
}
```

---

## 3. 触发器索引

### 3.1 TriggerIndex

```go
// TriggerIndex: 触发器索引（用于增量更新）
type TriggerIndex struct {
    // 路径 → 依赖此路径的规则
    triggers map[string][]*ast.Rule
}

// BuildTriggerIndex: 构建触发器索引
func BuildTriggerIndex(modules map[string]*ast.Module) *TriggerIndex {
    idx := &TriggerIndex{
        triggers: make(map[string][]*ast.Rule),
    }
    
    for _, module := range modules {
        for _, rule := range module.Rules {
            // 收集规则体中引用的数据路径
            refs := collectDataRefs(rule.Body)
            
            for _, ref := range refs {
                path := ref.String()
                idx.triggers[path] = append(idx.triggers[path], rule)
            }
        }
    }
    
    return idx
}

// GetAffectedRules: 获取受影响的规则
func (idx *TriggerIndex) GetAffectedRules(path string) []*ast.Rule {
    // 查找精确匹配
    rules := idx.triggers[path]
    
    // 查找前缀匹配
    for triggerPath, triggerRules := range idx.triggers {
        if strings.HasPrefix(path, triggerPath) {
            rules = append(rules, triggerRules...)
        }
    }
    
    return rules
}
```

---

## 4. 优化技术

### 4.1 索引选择

```go
// IndexSelector: 索引选择器
type IndexSelector struct {
    indices []Index
    stats   *Statistics
}

// SelectBest: 选择最优索引
func (s *IndexSelector) SelectBest(query ast.Body) Index {
    var bestIdx Index
    bestScore := -1
    
    for _, idx := range s.indices {
        score := s.scoreIndex(idx, query)
        if score > bestScore {
            bestScore = score
            bestIdx = idx
        }
    }
    
    return bestIdx
}

// scoreIndex: 评分索引
func (s *IndexSelector) scoreIndex(idx Index, query ast.Body) int {
    // 基于统计信息评分
    coverage := idx.Coverage(query)
    selectivity := s.stats.Selectivity(idx)
    
    return int(coverage * selectivity * 100)
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月23日

**相关阅读**:

- [编译器实现详解](10.4-编译器实现详解.md)
- [性能优化指南](../08-最佳实践/08.2-性能优化指南.md)
